{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/uploads/avatar.png","path":"uploads/avatar.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16.ico","path":"images/favicon-16x16.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32.ico","path":"images/favicon-32x32.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/affix.js","path":"js/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/post-details.js","path":"js/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"21b84ab2d415b4e6914f149dc6359c218f5d529e","modified":1566279053027},{"_id":"themes/next/.all-contributorsrc","hash":"a5a536579490546f2275da03765738ceabe45584","modified":1565706697104},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1565706697105},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1565706697106},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1565706697105},{"_id":"themes/next/.gitignore","hash":"b80cec1d5e6a73d1cec382aad8046d1352a1e963","modified":1565706697116},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1565706697116},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1565706697117},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1565706697117},{"_id":"themes/next/README.md","hash":"2fcc7621e898732ef7976b89ca2511f84c577c35","modified":1565706697118},{"_id":"themes/next/_config.yml","hash":"be43c50b2dae409ebd07d27bc6e550bb02c6776a","modified":1566276477572},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1565706697119},{"_id":"themes/next/gulpfile.coffee","hash":"2ba4aeddc257a74a209edf5218137010662cd5fb","modified":1565706697135},{"_id":"themes/next/package.json","hash":"170e67ca35a7c1ddc7dae50a90f6d4270143331f","modified":1565706697221},{"_id":"source/_posts/HCNNG.md","hash":"06a3b4f8bd9141916169789490105f3b76961ce6","modified":1566053246202},{"_id":"source/_posts/Q-HNSW.md","hash":"c6ed2f782ed70fa98f7127f4bd2aa5be35966c9f","modified":1565879901413},{"_id":"source/_posts/anns-nsg-code1.md","hash":"50716ba359e0016546e8d86b201bbce6505c504f","modified":1565706697088},{"_id":"source/_posts/anns-nsg-code2.md","hash":"5d650b32201ce164e913559d90dbeec9fe44fc56","modified":1565706697089},{"_id":"source/_posts/anns-nsg-code3.md","hash":"070cc55a31bccb8bee3aeb8c02753ffc2dab85ad","modified":1565706697090},{"_id":"source/_posts/hdf5使用.md","hash":"475c5d1894f07067169548e7e4737f548fd79dd1","modified":1567742828043},{"_id":"source/_posts/pat1001.md","hash":"e854e665f046a2c6bedb389062e3594039be160a","modified":1565755956723},{"_id":"source/_posts/pat1002.md","hash":"525cdc0fe026a9fcbee519bd59ae623844c1061f","modified":1565707782141},{"_id":"source/_posts/pat1003.md","hash":"11df71855b4c7c56d0a805e05ef545c49dece381","modified":1565706697091},{"_id":"source/_posts/pat1004.md","hash":"592b44883239e1537918066b8c162bdacddf343c","modified":1565706697091},{"_id":"source/_posts/pat1005.md","hash":"f846ac85752193f64824d5d56056ac81480d74dc","modified":1565757401938},{"_id":"source/_posts/pat1006.md","hash":"fccf5137461be16da2c7c3a42b3afdbd12b97470","modified":1565757759141},{"_id":"source/_posts/pat1007.md","hash":"c0004b9ade8497a9a92d66bc21231cbe6036f688","modified":1565844646385},{"_id":"source/_posts/pat1008.md","hash":"37454ec41860e70f6ecac068e78ce7f4f164708f","modified":1566053246207},{"_id":"source/_posts/pat1009.md","hash":"5c23a6050f7878f2568eddb2d04dec977dd15805","modified":1565844454942},{"_id":"source/_posts/pat1010.md","hash":"a17ff5b4b513a18fd2d58497785c62158bcff682","modified":1565844466590},{"_id":"source/_posts/patb1022.md","hash":"2559de9f83f76351369ebc8a26351193614adf60","modified":1566535118699},{"_id":"source/_posts/patb1023.md","hash":"5da58ce943805654eb0e13c8694f47409cd798d5","modified":1566534253483},{"_id":"source/_posts/patb1024.md","hash":"d3d961ecefb48b545e9bdafab02539a7d779d0b2","modified":1566534672495},{"_id":"source/_posts/patb1025.md","hash":"33a0b9dcd267a7c975a07ed53970b281e161c1b0","modified":1566535136533},{"_id":"source/_posts/patb1026.md","hash":"40015b120c89d340ff17cc1577f558698f325df3","modified":1566878271530},{"_id":"source/_posts/patb1027.md","hash":"07977a20f1727fea100ada61aa179560464ba401","modified":1567745851210},{"_id":"source/_posts/patb1028.md","hash":"28e4dbcedbcbac3691220765e673d692fd108cdb","modified":1567745986481},{"_id":"source/_posts/patb1029.md","hash":"938ae67be9904ca19e28c3841fb4890f8016f0e1","modified":1567746294530},{"_id":"source/_posts/patb1030.md","hash":"f2502f627b6edc5e4ac695473f99489cf9c1a870","modified":1567746575758},{"_id":"source/_posts/pat乙级1011.md","hash":"c4629782c8be08b3396c428a96dfdef364030727","modified":1565922822128},{"_id":"source/_posts/pat乙级1012.md","hash":"6df8c393921b7deeee310206409a84766ff88017","modified":1565922846377},{"_id":"source/_posts/pat乙级1013.md","hash":"da1f08e5ccd51fb33ddee730b61fb91cf2b66674","modified":1565923031724},{"_id":"source/_posts/pat乙级1014.md","hash":"eb8eb3dabadde05df4e618722c48d68c2d6ef66d","modified":1565923648541},{"_id":"source/_posts/pat乙级1015.md","hash":"47357a0276c9d9a75b2332d92ebdd7dc247e7f97","modified":1566054383983},{"_id":"source/_posts/pat乙级1016.md","hash":"a379587c8d7641bda84b22a17e21030a5e089fa1","modified":1566363393359},{"_id":"source/_posts/pat乙级1017.md","hash":"9a5292569b72643613dc4f2c26f78deca1beee2d","modified":1566363407220},{"_id":"source/_posts/pat乙级1018.md","hash":"f0bb5497113484e8749f63ca1d794f4b9a87cd77","modified":1566363419679},{"_id":"source/_posts/pat乙级1019.md","hash":"d50bfe15078f9f033b9e88e485a1ceab3844f561","modified":1566363432069},{"_id":"source/_posts/pat乙级1020.md","hash":"7c4dccc24eeca9ce46d7f0bc8f4a13a93488cd0c","modified":1566363443242},{"_id":"source/_posts/pat乙级1021.md","hash":"77ae722fea03cc48f1a7aaaf86c955b0b0598e02","modified":1566363488422},{"_id":"source/tags/index.md","hash":"f86715088a98cda558f1bf4ffe975995139ad2a0","modified":1565706697093},{"_id":"source/categories/index.md","hash":"6a8071844e89dfd70d36e2146f4255d77d893fd4","modified":1565706697092},{"_id":"source/uploads/avatar.png","hash":"cd9d8967569834b632c4e195471555e993c519a3","modified":1565706697094},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"c149f003d03501565e7688915cd8f2e99fbf8f42","modified":1565706697107},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"d91296a4c9facf6e2dc15815820b6444262f575c","modified":1565706697107},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1565706697108},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3239625bb2573e61f7bcce27a74882a9ff7021e9","modified":1565706697111},{"_id":"themes/next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1565706697111},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1565706697112},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1565706697112},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"b795f819d4e85197c31ac8892aab55e19bca970a","modified":1565706697112},{"_id":"themes/next/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1565706697113},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1565706697113},{"_id":"themes/next/.github/release-drafter.yml","hash":"fbd6210c4454c2db6cad1960dd03c89488d68c87","modified":1565706697114},{"_id":"themes/next/.github/stale.yml","hash":"41bf97ee86b8940a0b2e754499ec77fd2b44b717","modified":1565706697115},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1565706697116},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1565706697120},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"4094dab82cbdfdd0de117e94b508bbd5ceb3d363","modified":1565706697121},{"_id":"themes/next/docs/AUTHORS.md","hash":"9b6dea4c6ad89b1cf588251e0886c028d8f427e2","modified":1565706697122},{"_id":"themes/next/docs/DATA-FILES.md","hash":"290237970f023ad1345dcb8825fe3004de69900c","modified":1565706697122},{"_id":"themes/next/docs/INSTALLATION.md","hash":"5385246ab4756e3e26ec9fe1f6a6759812177cc4","modified":1565706697123},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"1fb2c852fad03b73882069f1ec0659db2e1f2da0","modified":1565706697123},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1565706697124},{"_id":"themes/next/docs/MATH.md","hash":"026d2cff73c22a30ea39c50783557ff4913aceac","modified":1565706697124},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"a07ca23c38f6e4dddd4b74016b30e88cd3796f75","modified":1565706697124},{"_id":"themes/next/languages/de.yml","hash":"88dcfa3e53cef1b7f858f98ca9f980179169ae4c","modified":1565706697135},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1565706697136},{"_id":"themes/next/languages/en.yml","hash":"4de207d89824422ccec5bc754a81af032d5e30f9","modified":1565706697136},{"_id":"themes/next/languages/es.yml","hash":"a5203c7bbae70bc40f2ee526f9e8105ca9be851e","modified":1565706697137},{"_id":"themes/next/languages/fa.yml","hash":"cc1f3a13e020e2cc666ddc57aaebc4c1ebd669d0","modified":1565706697137},{"_id":"themes/next/languages/fr.yml","hash":"c1e2e892c678920854e1f3df409118398523849e","modified":1565706697138},{"_id":"themes/next/languages/hu.yml","hash":"3b4c10c86a228da70dc4b1a1784a6f942e186032","modified":1565706697139},{"_id":"themes/next/languages/id.yml","hash":"3a9f4485e6801e0e6fae749133a52e3797760795","modified":1565706697139},{"_id":"themes/next/languages/it.yml","hash":"28ff9197a3d21e838e33bb026d8adb544320cb1a","modified":1565706697140},{"_id":"themes/next/languages/ja.yml","hash":"8f85a6500716191159f16c7f484ba61ddd16eeb6","modified":1565706697140},{"_id":"themes/next/languages/ko.yml","hash":"1df31bf037bcb6868a4bd60c49ff55eec5b8167f","modified":1565706697141},{"_id":"themes/next/languages/nl.yml","hash":"6f4a339ecc67a140f3f9c7bec369cbda6b45afd7","modified":1565706697141},{"_id":"themes/next/languages/pt-BR.yml","hash":"301a0535df5de7b585c7c9752053c41c6ef26f9b","modified":1565706697142},{"_id":"themes/next/languages/pt.yml","hash":"6d87701443e33a13574049e613f064f1eb250c95","modified":1565706697142},{"_id":"themes/next/languages/ru.yml","hash":"93872ac01074159566ee3e1738eea6e9216bab8e","modified":1565706697142},{"_id":"themes/next/languages/tr.yml","hash":"5489606e6c40c0b226a3414c8e5037aac965211d","modified":1565706697143},{"_id":"themes/next/languages/uk.yml","hash":"765ba405778f07d7ec3713606568852b04e1a862","modified":1565706697143},{"_id":"themes/next/languages/vi.yml","hash":"6a812db8606498980cd64f001e9ef2f50e124809","modified":1565706697144},{"_id":"themes/next/languages/zh-CN.yml","hash":"844d201c96fc7b50ee69e57e81d3418b4e367f65","modified":1566053246210},{"_id":"themes/next/languages/zh-HK.yml","hash":"7a5e47f561d4b6e132f7f3b09676afbf8520264e","modified":1565706697145},{"_id":"themes/next/languages/zh-TW.yml","hash":"3f3674cac8f47a9a509a7557ea1557bbfbd027e8","modified":1565706697145},{"_id":"themes/next/layout/_layout.swig","hash":"7c7eeb42b631c46ec02cb723b22b68ae80409aa3","modified":1565706697146},{"_id":"themes/next/layout/archive.swig","hash":"9941337701a8c0377a7af0024d948fcbb3a29a58","modified":1565706697218},{"_id":"themes/next/layout/category.swig","hash":"3020f7646dc3c79d44e3b5f1ce24b06d5b9fc13a","modified":1565706697219},{"_id":"themes/next/layout/index.swig","hash":"8cf3451dd2d5727920b351a8f5eefdddb5bf3638","modified":1565706697219},{"_id":"themes/next/layout/page.swig","hash":"dc48085a0c69c60155d57aa546ded835a1ff767e","modified":1565706697219},{"_id":"themes/next/layout/post.swig","hash":"4291b34b17fc6f1c06eb69852c894913e889a774","modified":1565706697220},{"_id":"themes/next/layout/tag.swig","hash":"02b5dfdfa1d1ff61f161f592d38b09454c941036","modified":1565706697220},{"_id":"themes/next/scripts/codeblock.js","hash":"080e262bc3b0cb1d43baf3881a7d9a0f0cbe6ce5","modified":1565706697221},{"_id":"source/_posts/HCNNG/directed selection1.png","hash":"d50290e0eaed07cd49396f0c74d553def9877918","modified":1566053246204},{"_id":"source/_posts/HCNNG/guided search2.png","hash":"f205acd008ed89f3c3872fd3ecacbef5801fc243","modified":1566053246205},{"_id":"source/_posts/hdf5使用/hdf5结构1.png","hash":"55a8923b6608bb952319aeee9b758a266e62c99f","modified":1567742828044},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c37a60580c901c79ccb22564b228a46e06207445","modified":1565706697109},{"_id":"themes/next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"57e1e06e845193e80c7df4a4454af28352526f7a","modified":1565706697109},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"07c423cce4157b8e2dbf60907ccbf3f18c4cf98a","modified":1565706697110},{"_id":"themes/next/.github/ISSUE_TEMPLATE/non-english.md","hash":"0b0727ff4d5180ae67f930fb4f8e9488e33eda9f","modified":1565706697110},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"67d04e3e29a2675d1a9f87d1ae6ea0769e963ff1","modified":1565706697125},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1565706697126},{"_id":"themes/next/docs/ru/README.md","hash":"932d3965d8b1a1ff653c07a0cafcdbf5892d6945","modified":1565706697126},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1565706697127},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"caa624092175d44e3d3a8c6ca23922718da2354c","modified":1565706697128},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"0dfb458370a0ffbbe37c00f53c15e3aa3e79b125","modified":1565706697128},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"2949ccf2cba5238f01a1386a9e91e646c7a22260","modified":1565706697129},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"c46f3f7496fc422207cc5954e10a2bc972b650aa","modified":1565706697130},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"c13546dd70a99a7d2d409cddf5d59f2f4d4d44a4","modified":1565706697132},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"e568a1b3c532e0ecf33cc237e1425b2579bd006d","modified":1565706697133},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"83feca62190abcca0332915ffe0eefe582573085","modified":1565706697133},{"_id":"themes/next/docs/zh-CN/README.md","hash":"79a73361b24e7fb7022992702961faacd6a2f9fe","modified":1565706697134},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"ba918bbd8faf32c28335693f03ff37c6acaff7f3","modified":1565706697134},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"41625b8424b680e7c81fc9294e0bb1859434ce01","modified":1565706697149},{"_id":"themes/next/layout/_macro/post.swig","hash":"77c85ee0310c75face777a3bcc190439e49020dc","modified":1565706697149},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a5ceff84bbe9ad2be780ff58aeea91972c32d44","modified":1565706697150},{"_id":"themes/next/layout/_partials/comments.swig","hash":"62f1556e9b8cc3217dad9ab4db8f474088fa1383","modified":1565706697153},{"_id":"themes/next/layout/_partials/footer.swig","hash":"ff9a950a81c1c66f2d3cbe9304c427c728716d7f","modified":1565706697154},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"40e940c3213b74933e529cd64f64c1f6f512b5ca","modified":1565706697154},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"769a983fe2f77908bfc8590ff37a0d8958b47598","modified":1565706697162},{"_id":"themes/next/layout/_partials/pjax.swig","hash":"6d7d2e1676f0abd7d4a4d607eca51065e02d07f4","modified":1565706697163},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"4b0c972c44bfa7ab07604280563deb9cc3974657","modified":1565706697164},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"e3c54ae7eca24a85148ec3bfb6712abf07c418c9","modified":1565706697172},{"_id":"themes/next/layout/_scripts/index.swig","hash":"3807bed8ae3f632019f26e282ef613d2275287ee","modified":1565706697172},{"_id":"themes/next/layout/_scripts/next-boot.swig","hash":"283e78eb795f52236026434dab6a0667f14d3c08","modified":1565706697172},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1565706697175},{"_id":"themes/next/layout/_scripts/three.swig","hash":"216849ad2503f578839c500ede529744a3abaf03","modified":1565706697179},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"70482f40ed63cfc3cef805ff93cf1a7c4b512fbc","modified":1565706697179},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1565706697184},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"2aec6040ac80977dd0c04b918fcc8851ed569947","modified":1565706697187},{"_id":"themes/next/layout/_third-party/facebook-sdk.swig","hash":"e7103dc133c8a6109e2a2e086c8e65ac80dbf6bb","modified":1565706697192},{"_id":"themes/next/layout/_third-party/index.swig","hash":"56133a4237a5cdee2bd874a2b3c0be2ac967dd2b","modified":1565706697192},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"ccef9c8ef5406a33af56fe5493492ee8ac2bb965","modified":1565706697194},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1565706697195},{"_id":"themes/next/layout/_third-party/vkontakte-api.swig","hash":"dc9c90c69734e658ec82995f3cfa286003c01281","modified":1565706697218},{"_id":"themes/next/scripts/events/core.js","hash":"a25690d8b03779f7e318108c8eace9baf6d4283a","modified":1565706697222},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"834599d2b83f06e90f8cf618cddc106fe900ba5c","modified":1565706697229},{"_id":"themes/next/scripts/filters/exturl.js","hash":"9c32675f64121ffbe454189b8e418b408f79d9c2","modified":1565706697230},{"_id":"themes/next/scripts/filters/lazyload.js","hash":"51672320fff6b39f56fe6a2881c611afe4e79b8e","modified":1565706697230},{"_id":"themes/next/scripts/helpers/engine.js","hash":"896a581feb9432e58a325ad04d66d6310a12374e","modified":1565706697232},{"_id":"themes/next/scripts/filters/minify.js","hash":"ef2c0280521462da88f220ba69b047d5d99adc76","modified":1565706697231},{"_id":"themes/next/scripts/helpers/font.js","hash":"53169e2d04f0c21e68beb07c212be0a6c2a9aaea","modified":1565706697232},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1565706697233},{"_id":"themes/next/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1565706697233},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1565706697233},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1565706697234},{"_id":"themes/next/scripts/tags/full-image.js","hash":"70b1d6ed969143e3912daf051ccc3585d984c146","modified":1565706697234},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"8fc05f22b88553bc1d96e0c925799cd97920fc6a","modified":1565706697235},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"60f880c1e11a7df1aee4f2e01d65451fecc0372c","modified":1565706697236},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1565706697236},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1565706697236},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1565706697237},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1565706697237},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1565706697237},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1565706697237},{"_id":"themes/next/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1565706697334},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1565706697335},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1565706697335},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1565706697336},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1565706697336},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1565706697337},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1565706697338},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1565706697339},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1565706697340},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1565706697341},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1565706697342},{"_id":"themes/next/source/images/favicon-16x16.ico","hash":"fb7335cd332555e9ab364c99a35e5c239f0d1af6","modified":1566278148966},{"_id":"themes/next/source/images/favicon-32x32.ico","hash":"358555ebcd35408bf74c6e901687da2f43f5953a","modified":1566278196069},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1565706697343},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1565706697344},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1565706697344},{"_id":"themes/next/source/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1565706697345},{"_id":"themes/next/source/js/algolia-search.js","hash":"955ae621677ae99416dd8f362eea02ef39811eca","modified":1565706697346},{"_id":"themes/next/source/js/local-search.js","hash":"a857346f051001d6fe0c7ef1780b313f9e5c7955","modified":1565706697346},{"_id":"themes/next/source/js/motion.js","hash":"4d1a9ab5ce397c093711769045288ce48fd392bd","modified":1565706697347},{"_id":"themes/next/source/js/next-boot.js","hash":"1fc6c1b80f265396cb193b37d4138cc3c8fe08c7","modified":1565706697350},{"_id":"themes/next/source/js/post-details.js","hash":"b72c145c7995fe6975b637ef3bcbb2c41b47c289","modified":1565706697351},{"_id":"themes/next/source/js/scrollspy.js","hash":"e630d9b05ab6bcc9ebab92435587d5a554eb0e3b","modified":1565706697354},{"_id":"themes/next/source/js/utils.js","hash":"6c83632baed3fb9b55c23ee3ecbea5c63072f2b0","modified":1565706697355},{"_id":"source/_posts/Q-HNSW/pq.png","hash":"36be539633c975ca81544a5e9874d2a6f9b0d0f1","modified":1565706697086},{"_id":"source/_posts/Q-HNSW/pq2.png","hash":"912a0020d0c2b0f97216bc5376950c47abd35546","modified":1565706697088},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565706697304},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565706697303},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565706697328},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"9e959646899a1dd381c0bea870408cd392c93c70","modified":1565706697148},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"1dc3875981923aee38b7b1e3ca3813b75ed6ab9c","modified":1565706697148},{"_id":"themes/next/layout/_partials/analytics/busuanzi-counter.swig","hash":"b35b2bf2ce3d73cabe8c443a45c2a82d45baf151","modified":1565706697151},{"_id":"themes/next/layout/_partials/analytics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1565706697151},{"_id":"themes/next/layout/_partials/analytics/index.swig","hash":"2925f6353934b1b2adc2808059e64dd7d220edd7","modified":1565706697152},{"_id":"themes/next/layout/_partials/analytics/tencent-mta.swig","hash":"198813a3f382bda4278fe3759bf0f18a5769bb33","modified":1565706697153},{"_id":"themes/next/layout/_partials/analytics/tencent-analytics.swig","hash":"493a1ef6c8f475d4dd3156a6ab37690dc75695ea","modified":1565706697152},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"6f02724e24945d7e5f0dcd351deebc90996ad38d","modified":1565706697155},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"62c54241724fb7da90b9598c356691f3b4fda7a1","modified":1565706697156},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"8dd7ac5ccc52848b3d0fb0f102874c1a8c1c45b6","modified":1565706697157},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"536421ab2e32436211a604cf9ddd6924e20a56ce","modified":1565706697158},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"a14a301e3d7187595b37b2ab419709a9c81a3a76","modified":1565706697158},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"a72e33e11df9d3639cdebab4f480e397c70deacb","modified":1565706697161},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"883ea1d024a8262eb8d3213de71c8ccb30daf095","modified":1565706697162},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"d3c25d70f0fd76121e4cacb9f8af4ccbe2a3c74d","modified":1565706697162},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"3ed15de413b9ca83641bbd0b740f94b450630357","modified":1565706697164},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"38683b340b199ab204a43f3d2cd41e21f01ceb06","modified":1565706697165},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"e2549106ea26ac48019aa3f8023b8fdc78c0f6db","modified":1565706697166},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"40483139657cde24356c6a4033a6386b909327a9","modified":1565706697166},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"2edfaf1579ea58e15cb5583fb7962dfee9af2257","modified":1565706697166},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"d9fe715fee716f78c7976c4e8838da71439ee0e0","modified":1565706697167},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"7bce91d429216724db5e337ec64cf7f05b022c97","modified":1565706697167},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1565706697168},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"15b542f5b06b7532234af367340b9ed9fcebb0ac","modified":1565706697169},{"_id":"themes/next/layout/_partials/share/index.swig","hash":"609ce79f47756977b90bce365614d4f8d1020196","modified":1565706697169},{"_id":"themes/next/layout/_partials/share/likely.swig","hash":"3ca3fe150c4dc4fd938410f367814445436fb67a","modified":1565706697169},{"_id":"themes/next/layout/_partials/share/needsharebutton.swig","hash":"09ae1250c1e142d251cc0e979097f1dd95e277bb","modified":1565706697170},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"84a4201867c034afbf25862b63af4a582f7086b1","modified":1565706697171},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"5b05f165547391bf231e52f56f3d925efc09bc44","modified":1565706697176},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"5258d3dbfbb6d585f798c697463f8b67b7dea02b","modified":1565706697176},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1565706697177},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1565706697177},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"f2ff7799baac49eb9779f66e0cd083fac70b87a2","modified":1565706697178},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"509621f1a68e7ab41193a14a2c50a21aff976f9e","modified":1565706697178},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-jquery.swig","hash":"b485797073495e24bf2f0b85880d513257bfed72","modified":1565706697181},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"7fd0459d2f1cfe1254f2c2b8087dc094c8cb0e84","modified":1565706697181},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1565706697182},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"3b9c50e3cbfa2c4d6cb0ffd443a994a212f3dbfc","modified":1565706697183},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"051fadd4cb777769fc4c0fe3cb0b309e3236e5c2","modified":1565706697183},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"20fcbed44aede1b908bd17d7a0279b03639068b1","modified":1565706697184},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"4dc2a96ad40b40d9b89da21105feee05df81ff35","modified":1565706697184},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"753ae34ed3852ea3c75a9f29d057f53a9829f247","modified":1565706697182},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1565706697188},{"_id":"themes/next/layout/_third-party/chat/index.swig","hash":"5ab4a8b4306c837d2f8c211a9d7fdaed76fa254d","modified":1565706697188},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1565706697189},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"1130b8bd60f3b84397974486e6586d7f0afaf836","modified":1565706697189},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"4e076cb5d50588c8fc5e032b6c9e8f6601628561","modified":1565706697190},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"1e27f34b06f8144905e6904b67dfc03c99d16499","modified":1565706697190},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"620ae7b01e6272ce31fb214c2c9422df60aa589a","modified":1565706697191},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f95bc4d7ffaddc3c0df0ef3eeeaac58ff83f560","modified":1565706697191},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"f40c1ca8ed4e7e92bc47f130243ef2cc396f38a8","modified":1565706697192},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"8b2b0997ebf5e9d17dcd6c0b7601dea0eec26b2e","modified":1565706697193},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"079910669dcc9b0606dde15c66bfdcf1c97b8119","modified":1565706697193},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"68d38da0762e82f7188b589479fa1cf80c7688ea","modified":1565706697194},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"157abdff4c5fddceae5af2631b5fff202abc0e5e","modified":1565706697195},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"b2fd17688f0433571b37704bc8df798e175e7811","modified":1565706697196},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"353da7ea00400897ae920a085aa4bee2224da50d","modified":1565706697196},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1565706697215},{"_id":"themes/next/layout/_third-party/tags/index.swig","hash":"83d0a8f71878c6b96a04ba08567b9064de6cce83","modified":1565706697216},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"119f67181cde1bd5391bc073b11343ea853513fb","modified":1565706697216},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"f3357db3b0d829f5f104ce740bee16abb4b0f473","modified":1565706697218},{"_id":"themes/next/scripts/events/lib/config.js","hash":"867b23bb231224064a79df5278ba0a02215044eb","modified":1565706697223},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1565706697223},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"251dcc22ed213da9b6135e1b958010e3352408d4","modified":1565706697224},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"00922e352b5585ae15cc19eaec8f5c31bd57814c","modified":1565706697225},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1565706697225},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"8f4643a844f90ca0ad853de1fe7c687c7569503d","modified":1565706697225},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"0388d10adf2330be20ec932010e35a81f4296c5d","modified":1565706697226},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"a9ebe8e80edb5e19ec4b845090d260ae9de1566a","modified":1565706697226},{"_id":"themes/next/scripts/filters/comment/facebook-comments-plugin.js","hash":"8d5379344310ae67c1e8880e517d643e40670874","modified":1565706697228},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"4505867a0598b83583f9740ecba3e4f053d18ebe","modified":1565706697228},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"71ee48847a1e54962640a4b64298ecc3e76565f8","modified":1565706697228},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"0c12943b5d681cf070431c3ff9256eaf358d4a3c","modified":1565706697229},{"_id":"themes/next/scripts/filters/comment/vkontakte.js","hash":"2aa608a4bc664e87e4e56b016a28dc7d798d9966","modified":1565706697229},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1565706697303},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2bb4c78b5da482751085beb73ab01ecd2dcbccda","modified":1565706697306},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"b82c5b13ca6d1a6424dcc1245fb7722cac090579","modified":1565706697307},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"451f1f904df8b39015ccff5ce804c047f132b1f4","modified":1565706697327},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"4c101c21b4f2712e47dba869ccc116b245fb0909","modified":1565706697327},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"db52bce619bb848189e83b7bfabd1b2a06fd5578","modified":1565706697331},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f1308b410fb4ed648631d301e981db4dc72d6cd5","modified":1565706697332},{"_id":"themes/next/source/js/schemes/muse.js","hash":"3367e85556ba4d138b4f9ad33d00b723bb75557a","modified":1565706697352},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b1bfc528190a93256fda7863685d5424636e87ed","modified":1565706697353},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1565706697356},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1565706697357},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1565706697358},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1565706697359},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1565706697359},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1565706697378},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1565706697379},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1565706697380},{"_id":"themes/next/source/lib/jquery/index.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1565706697375},{"_id":"source/_posts/Q-HNSW/SQ量化计算示例.png","hash":"8d291107c44eaa85656ca8bcad574c52e90cab56","modified":1565706697084},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"1c178041435de8076a1ce31304184007a837fcbb","modified":1565706697239},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"58a80925a845d590d4a9736ae92a6b03dc7c575f","modified":1565706697239},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"2b14d2a3f814c9dbd92c00835878925f9f10ca28","modified":1565706697241},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"dc658f44f4cda38684a584c95a6823e96c970a6d","modified":1565706697241},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"1960299fe99163f44f1cd90210eea1ef4b2cb723","modified":1565706697242},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"390993b47942a47d23ed8904c92e0186b6e9af29","modified":1565706697261},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"4bec027d48ebb95acd5f5786456ee1eb19a23ee4","modified":1565706697272},{"_id":"themes/next/source/css/_common/components/scrollbar.styl","hash":"202ee1f1f8e64d8292df16f40ee176ff4e5d7e71","modified":1565706697273},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"bdf464ee7972a007949acbe555d82e57621b3714","modified":1565706697293},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"442f7598991b92ec8bc3ce5343e18730da92e4fb","modified":1565706697293},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1238932450efc3f4c2e25c704794437ac78e6164","modified":1565706697294},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"4c4986b704c3cc3167c3c2a69c454446cf152528","modified":1565706697301},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"4f7140cc0db08b47a25c4c7aad71047d433051a1","modified":1565706697301},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"e9e3bcef3f9a3541a11e5f3edfed2a3d13d22b80","modified":1565706697302},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"173fe462331ba12d612f7ade8f18c0f9e259fa5d","modified":1565706697302},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"65328fbc073901d78729463e46cb28a4c37a6fac","modified":1565706697309},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"71d75fa309cf5b96d876da536f57c047e57afcff","modified":1565706697309},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"87d19a45db10689aae9a09736efd1eb896a35b3d","modified":1565706697310},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"3462ffd270f3e218e0a8362262466e79d731f975","modified":1565706697310},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f87b7a7d30e9111f7af269dcf7bd8c1893343fe8","modified":1565706697313},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"0c4ab171ecf12e49c95b66b3f1aa2ab2f3281c87","modified":1566053246212},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"49c6c656ed6e7348f967c01f8302fe1f6a5e3cd9","modified":1565706697316},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"bdc0ada1eec3c1d625bfe2c148cdfc1b3460fa32","modified":1565706697317},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"54c5e23ec3dcbbc77848ededba76e861cf0f4719","modified":1565706697317},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"0138165021be463f19e092f8972ac41aea3fb68a","modified":1565706697318},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"45f03b3bb80e32fd5648ce723055d7552b87d97c","modified":1565706697319},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"2fa573d7c04b8fa4717fc50265d7e4273f4325ea","modified":1565706697322},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"cbeb23488b707418a60b59ef8d6abc4f0d671959","modified":1565706697322},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"2e0681fa265a55f0259969109a3b9e3788bf516c","modified":1565706697323},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ce3820f199b54d09f7216a5df14d4492736c4520","modified":1565706697325},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"10b4794ba62726fc052c74d786d962ed79d0780b","modified":1565706697326},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"4b976940b728a78428e88f40acf9a801223af88a","modified":1565706697326},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1565706697360},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1565706697361},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1565706697365},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1565706697373},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"0442cccb1111eec0d38357fba810319d781b7ef9","modified":1565706697242},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"f3f48387850e4df28a62daa6f2980a7d52237040","modified":1566275457019},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"172a83db23cb3f8a95e7cd6046befbc841caa869","modified":1565706697243},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1565706697244},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"cf37dc0ef20a8423a28b056458e1fa609875789a","modified":1565706697245},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"dada73ae88f01fab2ab4d2c83eddfc558de2110a","modified":1565706697246},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"080f22922d89ca714a2463d6eaedfd4cb68e8aef","modified":1565706697246},{"_id":"themes/next/source/css/_common/components/highlight/copy-code.styl","hash":"d42c19193bd6d398cd1196a2848659c2b63b17d7","modified":1565706697246},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1565706697249},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"d58080515f4392e08ca69728d842dc798f7e662a","modified":1565706697250},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"d416014be2accb53931ac0b4c60a0c5e3cf2d180","modified":1565706697254},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"a67dc85f6d158dac20e951ab55988ff7e9e1739b","modified":1565706697253},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"1f217159862b12a89350e11b5097a8f3031af28f","modified":1565706697255},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1565706697258},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"621dc55fe935afe68a19f67b7447524292bc7e56","modified":1565706697258},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"207019d9e4911060dc23f01f821727fe0fe4717c","modified":1565706697260},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1565706697260},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1565706697262},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"83afee4c02f63642267a4d1487d028dc83c7739c","modified":1565706697262},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"7cee1dc30f323e9f46e1fd4cf61c1a3d4cebb8b0","modified":1565706697265},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"f96b241dea210e494b9173be76cce65faee7157a","modified":1565706697266},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"bb892e5934a3b525afd1e578db991b747ea4c1eb","modified":1565706697266},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"8b0dde1df553a5a2f5e0765e4e4ce48e9ab2c90e","modified":1565706697267},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"c60afb603d58cad3ad13e1a16c66832538510063","modified":1565706697267},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2e2a09dddd2a394a635bcefb6207b6cddcb784c7","modified":1565706697268},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"c898a67edb271c26f81e98acab93299a99fe3b95","modified":1565706697268},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"fdebe803d61e781883453d6301b7e2bcf5a8ec05","modified":1565706697269},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1565706697269},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"70d13702896e03013f694f89d5a68adbf0fff4af","modified":1565706697270},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"556140847ee1333cf97d4ee63a5f58cb371a9369","modified":1565706697270},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"6d379b38cab56666e24463a7a4d52006e232a8b1","modified":1565706697271},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"dcf801bd2478e125dffc0e23c0e720d048cf580f","modified":1565706697271},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"e292224b3d01a845b303a04ff83dc5c6945a553c","modified":1565706697272},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2ef546b4cfa5038ebb050c592c5135bbeb51af41","modified":1565706697273},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1565706697274},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"cd7ab38366a73edf3e7576d2629339660080b6f6","modified":1565706697275},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"1d9f17a59b030dd05732ccdc5b187705f0353130","modified":1565706697275},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"8fc3facb9e9d4dae2578d0a271648d997a7f9bf3","modified":1565706697276},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"f3108a247549fbdf11071d023add3f1b34ad2b23","modified":1565706697276},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"b2eca1259b9df8df81c5768bbb9b7ef65826e360","modified":1565706697281},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"bfa93a958115ddd562cd10f74b2eb887b6d3f187","modified":1565706697282},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"92381084e1aaf6798f058668aacef15bf1721739","modified":1565706697282},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"02e5a998748a67fa885fb06fae242bcf3f2786fb","modified":1565706697283},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"0527bc64708a9446dc7bbb2c7e39ab3a61251c26","modified":1565706697284},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"5d63f7479ee0f645e7538c60e827036fad74766d","modified":1565706697284},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"78d309e22206a4addda3c393282518dae02250ed","modified":1565706697285},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"278c31ed96474cd8a2ba465ed4131327e9d598bd","modified":1565706697285},{"_id":"themes/next/source/css/_common/components/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1565706697286},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"f211554f09a9005fad30b3e8f031be7f3fb7016a","modified":1565706697287},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1565706697287},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"90edaf377646093a07ea4e26accb861be9ebbb2b","modified":1565706697288},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1565706697288},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"438f3f7209fa6b8ab092a6f200a8c8c009565291","modified":1565706697290},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1565706697290},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"c2fc1a5105d6691d680f7b77b9301db416ebac8b","modified":1565706697291},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"85b8606763f4177d2f9a11c1909a21ab1ae2011c","modified":1565706697291},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"d048206fad5ace7f8df16cbc0b074b46ade16f81","modified":1565706697292},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"dd55feb43312489b5ec5692cc9d83ad150d7b389","modified":1565706697317},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"a29de6af7503a854e962eca8a3b8b911525ef2e5","modified":1565706697321},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/_sidebar.styl","hash":"1c3371551dadb86a4bf662c1adaa0dc2d2654ff7","modified":1565706697320},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1565706697372},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1565706697370},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1565706697377}],"Category":[{"name":"近似最近邻搜索","_id":"ck07nwfcw0004fk0r0byho7ie"},{"name":"HDF5","_id":"ck07nwfdp000kfk0rpnn44m43"},{"name":"PAT","_id":"ck07nwfdv000rfk0r3du7vd8v"}],"Data":[],"Page":[{"title":"tags","date":"2019-08-09T12:35:11.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-08-09 20:35:11\ntype: \"tags\"\n---\n","updated":"2019-08-13T14:31:37.093Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck07nwfcn0001fk0r7nanhe9l","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2019-08-09T12:35:42.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-08-09 20:35:42\ntype: \"categories\"\n---\n","updated":"2019-08-13T14:31:37.092Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck07nwfcs0003fk0r545ajr1j","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"量化编码的分层可通航小世界图（HNSW）笔记","date":"2019-08-11T10:23:46.000Z","mathjax":true,"_content":"\n\n## 引言\n\n### 两种改进方法\n\nHNSW内存开销大，基于量化编码的检索算法能够压缩数据集向量，大幅度降低内存占用。将量化编码与HNSW结合，有两种改进方法：\n\n1. 使用标量量化编码向量的HNSWSQ算法\n2. 使用乘积量化编码向量的HNSWPQ算法\n\n### HNSW内存开销大的原因\n\n1. 需要存储全部的数据集元素\n2. 需要存储每一层中节点之间的连接关系\n\n## 乘积量化\n\n### PQ乘积量化\n\n#### 建立码本和量化编码\n<img src=\"pq.png\">\n\n将`N * 128`的数据集进行切分，划分为4个子空间，每个子空间中向量的维数为32，得到`N * 4 * 32`。每个字段（子空间）同样有`N`个向量，对这`N`个向量进行聚类得到256个类中心，这样4个字段一共有`4 * 256`个类中心。每个子空间的所有`N`个向量都可以用该子空间的256个类中心的某一向量表示，对256个类中心进行编码只需8位即可，从而任一向量在该子空间的子向量的编码就可以用该子向量所属的类中心的编码来表示。\n\n待编码样本如何编码？\n\n对于待编码的样本，将它进行相同的切分，然后在各个子空间里逐一找到距离它们最近的类中心，然后用类中心的id来表示它们，即完成了待编码样本的编码。\n\n#### 码字的搜索算法\n\n<img src=\"pq2.png\">\n\n对于某个查询向量，要查询离其最近的k个向量，关键就是计算查询向量与dataset中的样本距离了。暴力方法就是计算数据集中所有的样本与查询向量的距离，然后进行排序，选出top@k个最近的样本返回。对数据集进行PQ乘积量化编码后，这个过程就变成下面的方式：\n\n将查询向量进行切分，切分方式与对数据集切分的相同，计算查询向量的每个子向量在相应的子空间中到256个类中心的距离，从而得到`4 * 256`的距离矩阵。某个样本到查询向量的距离就可以通过以下方式得到（不需单独计算了）：\n\n比如该样本的编码是(124, 56, 132, 222)，在`4 * 256`的距离矩阵中依次找出（查表）查询向量的相应子向量到编码为124（第一个子空间），编码为56（第二个子空间），编码为132（第三个子空间），编码为222（第四个子空间）的类中心的距离，将这4个距离相加的和作为该样本（编码是(124, 56, 132, 222)）到查询向量的距离。\n\n#### PQ乘积量化能够加速索引的原理\n\n* 将全样本的距离计算，转化为到子空间类中心的距离计算（加快查询）\n* 对特征进行编码后，可以用一个相对比较短的编码来表示样本（降低内存消耗）\n* 存储时只需存储类中心的向量值（计算距离时只需要它们 ）\n\n注：暴力搜索的距离计算的次数随样本数目`N`成线性增长，对于上面的例子，PQ乘积量化只需`4 * 256`次距离计算。\n\n## HNSWPQ算法\n\n与原始的HNSW算法相比，不再需要在内存中保持原始向量。将HNSW算法作为索引算法，采用PQ算法进行向量编码，由于使用PQ算法对原始向量编码，需要将HNSW算法插入过程中与近邻点距离的计算相应地修改为PQ的距离计算。\n\n### HNSWPQ的构建过程\n\n1. 对**原始向量**量化编码建立码本存储在内存中\n2. 新插入的结点作为查询结点，得到其能达到的最大层（指数衰减概率分布）\n3. 选邻居时，计算某结点与查询向量的距离应为PQ的距离计算\n\n与原HNSW算法相比，主要有两方面的不同：\n\n* 原HNSW算法直接在原始向量上构建，而HNSWPQ算法需要先对原始向量进行量化编码建立码本在此基础上再逐个插入结点构建（增加了一步）\n* 原HNSW算法计算距离时是直接计算，而HNSWPQ算法采用PQ距离计算方法（计算速度快）\n\n## HNSWSQ算法\n\n标量量化（SQ）对向量的每一维都进行量化，HNSWSQ算法采用最大最小量化方法。对于向量的第 $ i $ 维，通过样本集训练获取该维出现的最大值 $ vmax[i] $ 和最小值 $ vmin[i] $ ，然后将向量 $ \\vec{a} $ 第 $ i $ 维的值量化为:\n$$\n\\frac{x_i - vmin[i]} {vmax[i]}\n$$\n其中，$ i = 1, ..., n $ ，量化后的值编码存储，假设每一维编码为１个字节，则进一步处理为：\n$$\nf(x_i) = \\lfloor \\varphi( \\frac{x_i - vmin[i]} {vmax[i]} ) \\times 255\\rfloor\n$$\n其中：\n\n$$\n \\varphi(x) = \\begin{cases}\n1 & x \\geq 1\\\\\nx & 0 < x < 1\\\\\n0 & x \\leq 0\n\\end{cases}\n$$\nHNSWSQ算法在插入结点计算距离时，首先将编码后的向量解码还原，然后计算查询向量与解码向量的距离。\n\n<img src=\"SQ量化计算示例.png\">\n\n## 量化后性能分析\n### HNSWPQ算法性能分析\n\n与原始的HNSW算法相比，HNSWPQ算法在同样查询时间下Recall@1准确率要低很多，内存占用几乎只有 HNSW算法的一半（主要是结点连接关系），构建索引耗时是HNSW的几倍，主要是编码引起。\n\n随着PQ子量化器（子空间）的增多，由于量化误差的降低，各算法的Recall@1准确率逐步提高。\n\n### HNSWSQ算法性能分析\n\n在GIST-1M数据集上HNSWSQ8的内存开销只有HNSW算法的29.5%，两者性能相当；在SIFT-1M数据集上，两者性能相当，构建索引耗时相当，HNSWSQ8的内存占用比HNSW低45%。\n\n## 参考文献\n\n> [1]李秋珍,白兴强,李立夏,王赢.量化编码的分层可通航小世界图算法[J].计算机工程与科学,2019,41(04):618-625.\n> [2]Yong Yuan, 图像检索：再叙ANN Search, http://yongyuan.name/blog/ann-search.html, 2019.7.30.","source":"_posts/Q-HNSW.md","raw":"---\ntitle: 量化编码的分层可通航小世界图（HNSW）笔记\ndate: 2019-08-11 18:23:46\ntags:\n- 论文阅读\n- ANNS\ncategories:\n- 近似最近邻搜索\nmathjax: true\n---\n\n\n## 引言\n\n### 两种改进方法\n\nHNSW内存开销大，基于量化编码的检索算法能够压缩数据集向量，大幅度降低内存占用。将量化编码与HNSW结合，有两种改进方法：\n\n1. 使用标量量化编码向量的HNSWSQ算法\n2. 使用乘积量化编码向量的HNSWPQ算法\n\n### HNSW内存开销大的原因\n\n1. 需要存储全部的数据集元素\n2. 需要存储每一层中节点之间的连接关系\n\n## 乘积量化\n\n### PQ乘积量化\n\n#### 建立码本和量化编码\n<img src=\"pq.png\">\n\n将`N * 128`的数据集进行切分，划分为4个子空间，每个子空间中向量的维数为32，得到`N * 4 * 32`。每个字段（子空间）同样有`N`个向量，对这`N`个向量进行聚类得到256个类中心，这样4个字段一共有`4 * 256`个类中心。每个子空间的所有`N`个向量都可以用该子空间的256个类中心的某一向量表示，对256个类中心进行编码只需8位即可，从而任一向量在该子空间的子向量的编码就可以用该子向量所属的类中心的编码来表示。\n\n待编码样本如何编码？\n\n对于待编码的样本，将它进行相同的切分，然后在各个子空间里逐一找到距离它们最近的类中心，然后用类中心的id来表示它们，即完成了待编码样本的编码。\n\n#### 码字的搜索算法\n\n<img src=\"pq2.png\">\n\n对于某个查询向量，要查询离其最近的k个向量，关键就是计算查询向量与dataset中的样本距离了。暴力方法就是计算数据集中所有的样本与查询向量的距离，然后进行排序，选出top@k个最近的样本返回。对数据集进行PQ乘积量化编码后，这个过程就变成下面的方式：\n\n将查询向量进行切分，切分方式与对数据集切分的相同，计算查询向量的每个子向量在相应的子空间中到256个类中心的距离，从而得到`4 * 256`的距离矩阵。某个样本到查询向量的距离就可以通过以下方式得到（不需单独计算了）：\n\n比如该样本的编码是(124, 56, 132, 222)，在`4 * 256`的距离矩阵中依次找出（查表）查询向量的相应子向量到编码为124（第一个子空间），编码为56（第二个子空间），编码为132（第三个子空间），编码为222（第四个子空间）的类中心的距离，将这4个距离相加的和作为该样本（编码是(124, 56, 132, 222)）到查询向量的距离。\n\n#### PQ乘积量化能够加速索引的原理\n\n* 将全样本的距离计算，转化为到子空间类中心的距离计算（加快查询）\n* 对特征进行编码后，可以用一个相对比较短的编码来表示样本（降低内存消耗）\n* 存储时只需存储类中心的向量值（计算距离时只需要它们 ）\n\n注：暴力搜索的距离计算的次数随样本数目`N`成线性增长，对于上面的例子，PQ乘积量化只需`4 * 256`次距离计算。\n\n## HNSWPQ算法\n\n与原始的HNSW算法相比，不再需要在内存中保持原始向量。将HNSW算法作为索引算法，采用PQ算法进行向量编码，由于使用PQ算法对原始向量编码，需要将HNSW算法插入过程中与近邻点距离的计算相应地修改为PQ的距离计算。\n\n### HNSWPQ的构建过程\n\n1. 对**原始向量**量化编码建立码本存储在内存中\n2. 新插入的结点作为查询结点，得到其能达到的最大层（指数衰减概率分布）\n3. 选邻居时，计算某结点与查询向量的距离应为PQ的距离计算\n\n与原HNSW算法相比，主要有两方面的不同：\n\n* 原HNSW算法直接在原始向量上构建，而HNSWPQ算法需要先对原始向量进行量化编码建立码本在此基础上再逐个插入结点构建（增加了一步）\n* 原HNSW算法计算距离时是直接计算，而HNSWPQ算法采用PQ距离计算方法（计算速度快）\n\n## HNSWSQ算法\n\n标量量化（SQ）对向量的每一维都进行量化，HNSWSQ算法采用最大最小量化方法。对于向量的第 $ i $ 维，通过样本集训练获取该维出现的最大值 $ vmax[i] $ 和最小值 $ vmin[i] $ ，然后将向量 $ \\vec{a} $ 第 $ i $ 维的值量化为:\n$$\n\\frac{x_i - vmin[i]} {vmax[i]}\n$$\n其中，$ i = 1, ..., n $ ，量化后的值编码存储，假设每一维编码为１个字节，则进一步处理为：\n$$\nf(x_i) = \\lfloor \\varphi( \\frac{x_i - vmin[i]} {vmax[i]} ) \\times 255\\rfloor\n$$\n其中：\n\n$$\n \\varphi(x) = \\begin{cases}\n1 & x \\geq 1\\\\\nx & 0 < x < 1\\\\\n0 & x \\leq 0\n\\end{cases}\n$$\nHNSWSQ算法在插入结点计算距离时，首先将编码后的向量解码还原，然后计算查询向量与解码向量的距离。\n\n<img src=\"SQ量化计算示例.png\">\n\n## 量化后性能分析\n### HNSWPQ算法性能分析\n\n与原始的HNSW算法相比，HNSWPQ算法在同样查询时间下Recall@1准确率要低很多，内存占用几乎只有 HNSW算法的一半（主要是结点连接关系），构建索引耗时是HNSW的几倍，主要是编码引起。\n\n随着PQ子量化器（子空间）的增多，由于量化误差的降低，各算法的Recall@1准确率逐步提高。\n\n### HNSWSQ算法性能分析\n\n在GIST-1M数据集上HNSWSQ8的内存开销只有HNSW算法的29.5%，两者性能相当；在SIFT-1M数据集上，两者性能相当，构建索引耗时相当，HNSWSQ8的内存占用比HNSW低45%。\n\n## 参考文献\n\n> [1]李秋珍,白兴强,李立夏,王赢.量化编码的分层可通航小世界图算法[J].计算机工程与科学,2019,41(04):618-625.\n> [2]Yong Yuan, 图像检索：再叙ANN Search, http://yongyuan.name/blog/ann-search.html, 2019.7.30.","slug":"Q-HNSW","published":1,"updated":"2019-08-15T14:38:21.413Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfcc0000fk0rh49koqon","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><h3 id=\"两种改进方法\"><a href=\"#两种改进方法\" class=\"headerlink\" title=\"两种改进方法\"></a>两种改进方法</h3><p>HNSW内存开销大，基于量化编码的检索算法能够压缩数据集向量，大幅度降低内存占用。将量化编码与HNSW结合，有两种改进方法：</p>\n<ol>\n<li>使用标量量化编码向量的HNSWSQ算法</li>\n<li>使用乘积量化编码向量的HNSWPQ算法</li>\n</ol>\n<h3 id=\"HNSW内存开销大的原因\"><a href=\"#HNSW内存开销大的原因\" class=\"headerlink\" title=\"HNSW内存开销大的原因\"></a>HNSW内存开销大的原因</h3><ol>\n<li>需要存储全部的数据集元素</li>\n<li>需要存储每一层中节点之间的连接关系</li>\n</ol>\n<h2 id=\"乘积量化\"><a href=\"#乘积量化\" class=\"headerlink\" title=\"乘积量化\"></a>乘积量化</h2><h3 id=\"PQ乘积量化\"><a href=\"#PQ乘积量化\" class=\"headerlink\" title=\"PQ乘积量化\"></a>PQ乘积量化</h3><h4 id=\"建立码本和量化编码\"><a href=\"#建立码本和量化编码\" class=\"headerlink\" title=\"建立码本和量化编码\"></a>建立码本和量化编码</h4><p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/pq.png\"></p>\n<p>将<code>N * 128</code>的数据集进行切分，划分为4个子空间，每个子空间中向量的维数为32，得到<code>N * 4 * 32</code>。每个字段（子空间）同样有<code>N</code>个向量，对这<code>N</code>个向量进行聚类得到256个类中心，这样4个字段一共有<code>4 * 256</code>个类中心。每个子空间的所有<code>N</code>个向量都可以用该子空间的256个类中心的某一向量表示，对256个类中心进行编码只需8位即可，从而任一向量在该子空间的子向量的编码就可以用该子向量所属的类中心的编码来表示。</p>\n<p>待编码样本如何编码？</p>\n<p>对于待编码的样本，将它进行相同的切分，然后在各个子空间里逐一找到距离它们最近的类中心，然后用类中心的id来表示它们，即完成了待编码样本的编码。</p>\n<h4 id=\"码字的搜索算法\"><a href=\"#码字的搜索算法\" class=\"headerlink\" title=\"码字的搜索算法\"></a>码字的搜索算法</h4><p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/pq2.png\"></p>\n<p>对于某个查询向量，要查询离其最近的k个向量，关键就是计算查询向量与dataset中的样本距离了。暴力方法就是计算数据集中所有的样本与查询向量的距离，然后进行排序，选出top@k个最近的样本返回。对数据集进行PQ乘积量化编码后，这个过程就变成下面的方式：</p>\n<p>将查询向量进行切分，切分方式与对数据集切分的相同，计算查询向量的每个子向量在相应的子空间中到256个类中心的距离，从而得到<code>4 * 256</code>的距离矩阵。某个样本到查询向量的距离就可以通过以下方式得到（不需单独计算了）：</p>\n<p>比如该样本的编码是(124, 56, 132, 222)，在<code>4 * 256</code>的距离矩阵中依次找出（查表）查询向量的相应子向量到编码为124（第一个子空间），编码为56（第二个子空间），编码为132（第三个子空间），编码为222（第四个子空间）的类中心的距离，将这4个距离相加的和作为该样本（编码是(124, 56, 132, 222)）到查询向量的距离。</p>\n<h4 id=\"PQ乘积量化能够加速索引的原理\"><a href=\"#PQ乘积量化能够加速索引的原理\" class=\"headerlink\" title=\"PQ乘积量化能够加速索引的原理\"></a>PQ乘积量化能够加速索引的原理</h4><ul>\n<li>将全样本的距离计算，转化为到子空间类中心的距离计算（加快查询）</li>\n<li>对特征进行编码后，可以用一个相对比较短的编码来表示样本（降低内存消耗）</li>\n<li>存储时只需存储类中心的向量值（计算距离时只需要它们 ）</li>\n</ul>\n<p>注：暴力搜索的距离计算的次数随样本数目<code>N</code>成线性增长，对于上面的例子，PQ乘积量化只需<code>4 * 256</code>次距离计算。</p>\n<h2 id=\"HNSWPQ算法\"><a href=\"#HNSWPQ算法\" class=\"headerlink\" title=\"HNSWPQ算法\"></a>HNSWPQ算法</h2><p>与原始的HNSW算法相比，不再需要在内存中保持原始向量。将HNSW算法作为索引算法，采用PQ算法进行向量编码，由于使用PQ算法对原始向量编码，需要将HNSW算法插入过程中与近邻点距离的计算相应地修改为PQ的距离计算。</p>\n<h3 id=\"HNSWPQ的构建过程\"><a href=\"#HNSWPQ的构建过程\" class=\"headerlink\" title=\"HNSWPQ的构建过程\"></a>HNSWPQ的构建过程</h3><ol>\n<li>对<strong>原始向量</strong>量化编码建立码本存储在内存中</li>\n<li>新插入的结点作为查询结点，得到其能达到的最大层（指数衰减概率分布）</li>\n<li>选邻居时，计算某结点与查询向量的距离应为PQ的距离计算</li>\n</ol>\n<p>与原HNSW算法相比，主要有两方面的不同：</p>\n<ul>\n<li>原HNSW算法直接在原始向量上构建，而HNSWPQ算法需要先对原始向量进行量化编码建立码本在此基础上再逐个插入结点构建（增加了一步）</li>\n<li>原HNSW算法计算距离时是直接计算，而HNSWPQ算法采用PQ距离计算方法（计算速度快）</li>\n</ul>\n<h2 id=\"HNSWSQ算法\"><a href=\"#HNSWSQ算法\" class=\"headerlink\" title=\"HNSWSQ算法\"></a>HNSWSQ算法</h2><p>标量量化（SQ）对向量的每一维都进行量化，HNSWSQ算法采用最大最小量化方法。对于向量的第 $ i $ 维，通过样本集训练获取该维出现的最大值 $ vmax[i] $ 和最小值 $ vmin[i] $ ，然后将向量 $ \\vec{a} $ 第 $ i $ 维的值量化为:</p>\n<script type=\"math/tex; mode=display\">\n\\frac{x_i - vmin[i]} {vmax[i]}</script><p>其中，$ i = 1, …, n $ ，量化后的值编码存储，假设每一维编码为１个字节，则进一步处理为：</p>\n<script type=\"math/tex; mode=display\">\nf(x_i) = \\lfloor \\varphi( \\frac{x_i - vmin[i]} {vmax[i]} ) \\times 255\\rfloor</script><p>其中：</p>\n<script type=\"math/tex; mode=display\">\n \\varphi(x) = \\begin{cases}\n1 & x \\geq 1\\\\\nx & 0 < x < 1\\\\\n0 & x \\leq 0\n\\end{cases}</script><p>HNSWSQ算法在插入结点计算距离时，首先将编码后的向量解码还原，然后计算查询向量与解码向量的距离。</p>\n<p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/SQ量化计算示例.png\"></p>\n<h2 id=\"量化后性能分析\"><a href=\"#量化后性能分析\" class=\"headerlink\" title=\"量化后性能分析\"></a>量化后性能分析</h2><h3 id=\"HNSWPQ算法性能分析\"><a href=\"#HNSWPQ算法性能分析\" class=\"headerlink\" title=\"HNSWPQ算法性能分析\"></a>HNSWPQ算法性能分析</h3><p>与原始的HNSW算法相比，HNSWPQ算法在同样查询时间下Recall@1准确率要低很多，内存占用几乎只有 HNSW算法的一半（主要是结点连接关系），构建索引耗时是HNSW的几倍，主要是编码引起。</p>\n<p>随着PQ子量化器（子空间）的增多，由于量化误差的降低，各算法的Recall@1准确率逐步提高。</p>\n<h3 id=\"HNSWSQ算法性能分析\"><a href=\"#HNSWSQ算法性能分析\" class=\"headerlink\" title=\"HNSWSQ算法性能分析\"></a>HNSWSQ算法性能分析</h3><p>在GIST-1M数据集上HNSWSQ8的内存开销只有HNSW算法的29.5%，两者性能相当；在SIFT-1M数据集上，两者性能相当，构建索引耗时相当，HNSWSQ8的内存占用比HNSW低45%。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]李秋珍,白兴强,李立夏,王赢.量化编码的分层可通航小世界图算法[J].计算机工程与科学,2019,41(04):618-625.<br>[2]Yong Yuan, 图像检索：再叙ANN Search, <a href=\"http://yongyuan.name/blog/ann-search.html\" target=\"_blank\" rel=\"noopener\">http://yongyuan.name/blog/ann-search.html</a>, 2019.7.30.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><h3 id=\"两种改进方法\"><a href=\"#两种改进方法\" class=\"headerlink\" title=\"两种改进方法\"></a>两种改进方法</h3><p>HNSW内存开销大，基于量化编码的检索算法能够压缩数据集向量，大幅度降低内存占用。将量化编码与HNSW结合，有两种改进方法：</p>\n<ol>\n<li>使用标量量化编码向量的HNSWSQ算法</li>\n<li>使用乘积量化编码向量的HNSWPQ算法</li>\n</ol>\n<h3 id=\"HNSW内存开销大的原因\"><a href=\"#HNSW内存开销大的原因\" class=\"headerlink\" title=\"HNSW内存开销大的原因\"></a>HNSW内存开销大的原因</h3><ol>\n<li>需要存储全部的数据集元素</li>\n<li>需要存储每一层中节点之间的连接关系</li>\n</ol>\n<h2 id=\"乘积量化\"><a href=\"#乘积量化\" class=\"headerlink\" title=\"乘积量化\"></a>乘积量化</h2><h3 id=\"PQ乘积量化\"><a href=\"#PQ乘积量化\" class=\"headerlink\" title=\"PQ乘积量化\"></a>PQ乘积量化</h3><h4 id=\"建立码本和量化编码\"><a href=\"#建立码本和量化编码\" class=\"headerlink\" title=\"建立码本和量化编码\"></a>建立码本和量化编码</h4><p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/pq.png\"></p>\n<p>将<code>N * 128</code>的数据集进行切分，划分为4个子空间，每个子空间中向量的维数为32，得到<code>N * 4 * 32</code>。每个字段（子空间）同样有<code>N</code>个向量，对这<code>N</code>个向量进行聚类得到256个类中心，这样4个字段一共有<code>4 * 256</code>个类中心。每个子空间的所有<code>N</code>个向量都可以用该子空间的256个类中心的某一向量表示，对256个类中心进行编码只需8位即可，从而任一向量在该子空间的子向量的编码就可以用该子向量所属的类中心的编码来表示。</p>\n<p>待编码样本如何编码？</p>\n<p>对于待编码的样本，将它进行相同的切分，然后在各个子空间里逐一找到距离它们最近的类中心，然后用类中心的id来表示它们，即完成了待编码样本的编码。</p>\n<h4 id=\"码字的搜索算法\"><a href=\"#码字的搜索算法\" class=\"headerlink\" title=\"码字的搜索算法\"></a>码字的搜索算法</h4><p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/pq2.png\"></p>\n<p>对于某个查询向量，要查询离其最近的k个向量，关键就是计算查询向量与dataset中的样本距离了。暴力方法就是计算数据集中所有的样本与查询向量的距离，然后进行排序，选出top@k个最近的样本返回。对数据集进行PQ乘积量化编码后，这个过程就变成下面的方式：</p>\n<p>将查询向量进行切分，切分方式与对数据集切分的相同，计算查询向量的每个子向量在相应的子空间中到256个类中心的距离，从而得到<code>4 * 256</code>的距离矩阵。某个样本到查询向量的距离就可以通过以下方式得到（不需单独计算了）：</p>\n<p>比如该样本的编码是(124, 56, 132, 222)，在<code>4 * 256</code>的距离矩阵中依次找出（查表）查询向量的相应子向量到编码为124（第一个子空间），编码为56（第二个子空间），编码为132（第三个子空间），编码为222（第四个子空间）的类中心的距离，将这4个距离相加的和作为该样本（编码是(124, 56, 132, 222)）到查询向量的距离。</p>\n<h4 id=\"PQ乘积量化能够加速索引的原理\"><a href=\"#PQ乘积量化能够加速索引的原理\" class=\"headerlink\" title=\"PQ乘积量化能够加速索引的原理\"></a>PQ乘积量化能够加速索引的原理</h4><ul>\n<li>将全样本的距离计算，转化为到子空间类中心的距离计算（加快查询）</li>\n<li>对特征进行编码后，可以用一个相对比较短的编码来表示样本（降低内存消耗）</li>\n<li>存储时只需存储类中心的向量值（计算距离时只需要它们 ）</li>\n</ul>\n<p>注：暴力搜索的距离计算的次数随样本数目<code>N</code>成线性增长，对于上面的例子，PQ乘积量化只需<code>4 * 256</code>次距离计算。</p>\n<h2 id=\"HNSWPQ算法\"><a href=\"#HNSWPQ算法\" class=\"headerlink\" title=\"HNSWPQ算法\"></a>HNSWPQ算法</h2><p>与原始的HNSW算法相比，不再需要在内存中保持原始向量。将HNSW算法作为索引算法，采用PQ算法进行向量编码，由于使用PQ算法对原始向量编码，需要将HNSW算法插入过程中与近邻点距离的计算相应地修改为PQ的距离计算。</p>\n<h3 id=\"HNSWPQ的构建过程\"><a href=\"#HNSWPQ的构建过程\" class=\"headerlink\" title=\"HNSWPQ的构建过程\"></a>HNSWPQ的构建过程</h3><ol>\n<li>对<strong>原始向量</strong>量化编码建立码本存储在内存中</li>\n<li>新插入的结点作为查询结点，得到其能达到的最大层（指数衰减概率分布）</li>\n<li>选邻居时，计算某结点与查询向量的距离应为PQ的距离计算</li>\n</ol>\n<p>与原HNSW算法相比，主要有两方面的不同：</p>\n<ul>\n<li>原HNSW算法直接在原始向量上构建，而HNSWPQ算法需要先对原始向量进行量化编码建立码本在此基础上再逐个插入结点构建（增加了一步）</li>\n<li>原HNSW算法计算距离时是直接计算，而HNSWPQ算法采用PQ距离计算方法（计算速度快）</li>\n</ul>\n<h2 id=\"HNSWSQ算法\"><a href=\"#HNSWSQ算法\" class=\"headerlink\" title=\"HNSWSQ算法\"></a>HNSWSQ算法</h2><p>标量量化（SQ）对向量的每一维都进行量化，HNSWSQ算法采用最大最小量化方法。对于向量的第 $ i $ 维，通过样本集训练获取该维出现的最大值 $ vmax[i] $ 和最小值 $ vmin[i] $ ，然后将向量 $ \\vec{a} $ 第 $ i $ 维的值量化为:</p>\n<script type=\"math/tex; mode=display\">\n\\frac{x_i - vmin[i]} {vmax[i]}</script><p>其中，$ i = 1, …, n $ ，量化后的值编码存储，假设每一维编码为１个字节，则进一步处理为：</p>\n<script type=\"math/tex; mode=display\">\nf(x_i) = \\lfloor \\varphi( \\frac{x_i - vmin[i]} {vmax[i]} ) \\times 255\\rfloor</script><p>其中：</p>\n<script type=\"math/tex; mode=display\">\n \\varphi(x) = \\begin{cases}\n1 & x \\geq 1\\\\\nx & 0 < x < 1\\\\\n0 & x \\leq 0\n\\end{cases}</script><p>HNSWSQ算法在插入结点计算距离时，首先将编码后的向量解码还原，然后计算查询向量与解码向量的距离。</p>\n<p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/SQ量化计算示例.png\"></p>\n<h2 id=\"量化后性能分析\"><a href=\"#量化后性能分析\" class=\"headerlink\" title=\"量化后性能分析\"></a>量化后性能分析</h2><h3 id=\"HNSWPQ算法性能分析\"><a href=\"#HNSWPQ算法性能分析\" class=\"headerlink\" title=\"HNSWPQ算法性能分析\"></a>HNSWPQ算法性能分析</h3><p>与原始的HNSW算法相比，HNSWPQ算法在同样查询时间下Recall@1准确率要低很多，内存占用几乎只有 HNSW算法的一半（主要是结点连接关系），构建索引耗时是HNSW的几倍，主要是编码引起。</p>\n<p>随着PQ子量化器（子空间）的增多，由于量化误差的降低，各算法的Recall@1准确率逐步提高。</p>\n<h3 id=\"HNSWSQ算法性能分析\"><a href=\"#HNSWSQ算法性能分析\" class=\"headerlink\" title=\"HNSWSQ算法性能分析\"></a>HNSWSQ算法性能分析</h3><p>在GIST-1M数据集上HNSWSQ8的内存开销只有HNSW算法的29.5%，两者性能相当；在SIFT-1M数据集上，两者性能相当，构建索引耗时相当，HNSWSQ8的内存占用比HNSW低45%。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]李秋珍,白兴强,李立夏,王赢.量化编码的分层可通航小世界图算法[J].计算机工程与科学,2019,41(04):618-625.<br>[2]Yong Yuan, 图像检索：再叙ANN Search, <a href=\"http://yongyuan.name/blog/ann-search.html\" target=\"_blank\" rel=\"noopener\">http://yongyuan.name/blog/ann-search.html</a>, 2019.7.30.</p>\n</blockquote>\n"},{"title":"C++读取ivecs格式数据","date":"2019-08-12T13:54:50.000Z","_content":"\n## 引言\n\n近似最近邻搜索中通常会涉及到`fvecs`和`ivecs`格式的数据，其中，原始数据一般为`fvecs`格式的数据，查询结果一般为`ivecs`格式的。`ivecs`内部存储的主要是数据的`id`，数据类型为`unsigned`类型。就其内部数据结构而言，行数为查询点的个数，列数为对每个查询点查询返回个数再加1，因为每行的第一个位置存储的是对每个查询点查询返回个数。\n\n可以通过程序来读取`ivecs`格式数据的内容，下面是用`c++`程序读取`ivecs`格式数据内容并输出其查询数据个数和对每个查询点查询返回个数。\n\n## C++读取`ivecs`格式数据\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nvoid load_ivecs_data(const char* filename,\n                 std::vector<std::vector<unsigned> >& results, unsigned &num, unsigned &dim) {\n  std::ifstream in(filename, std::ios::binary);\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\n  //std::cout<<\"data dimension: \"<<dim<<std::endl;\n  in.seekg(0, std::ios::end);\n  std::ios::pos_type ss = in.tellg();\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\n  results.resize(num);\n  for (unsigned i = 0; i < num; i++) results[i].resize(dim);\n\n  in.seekg(0, std::ios::beg);\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\n    in.read((char*)results[i].data(), dim * 4);\n  }\n  in.close();\n}\n\nint main(int argc, char** argv) {\n  std::vector<std::vector<unsigned> > true_load;\n  unsigned dim, num;\n  load_ivecs_data(argv[1], true_load, num, dim);\n  for(size_t i = 0; i < num; i++) {\n    for(size_t j = 0; j < dim; j++) {\n      std::cout << true_load[i][j] << \" \";\n    }\n    std::cout << std::endl;\n  }\n  std::cout << \"result_num：\"<< num << std::endl << \"result dimension：\" << dim << std::endl;\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","source":"_posts/anns-nsg-code1.md","raw":"---\ntitle: C++读取ivecs格式数据\ndate: 2019-08-12 21:54:50\ntags:\n- C/C++\n- ANNS\n- 源码阅读\ncategories:\n- 近似最近邻搜索\n---\n\n## 引言\n\n近似最近邻搜索中通常会涉及到`fvecs`和`ivecs`格式的数据，其中，原始数据一般为`fvecs`格式的数据，查询结果一般为`ivecs`格式的。`ivecs`内部存储的主要是数据的`id`，数据类型为`unsigned`类型。就其内部数据结构而言，行数为查询点的个数，列数为对每个查询点查询返回个数再加1，因为每行的第一个位置存储的是对每个查询点查询返回个数。\n\n可以通过程序来读取`ivecs`格式数据的内容，下面是用`c++`程序读取`ivecs`格式数据内容并输出其查询数据个数和对每个查询点查询返回个数。\n\n## C++读取`ivecs`格式数据\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nvoid load_ivecs_data(const char* filename,\n                 std::vector<std::vector<unsigned> >& results, unsigned &num, unsigned &dim) {\n  std::ifstream in(filename, std::ios::binary);\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\n  //std::cout<<\"data dimension: \"<<dim<<std::endl;\n  in.seekg(0, std::ios::end);\n  std::ios::pos_type ss = in.tellg();\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\n  results.resize(num);\n  for (unsigned i = 0; i < num; i++) results[i].resize(dim);\n\n  in.seekg(0, std::ios::beg);\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\n    in.read((char*)results[i].data(), dim * 4);\n  }\n  in.close();\n}\n\nint main(int argc, char** argv) {\n  std::vector<std::vector<unsigned> > true_load;\n  unsigned dim, num;\n  load_ivecs_data(argv[1], true_load, num, dim);\n  for(size_t i = 0; i < num; i++) {\n    for(size_t j = 0; j < dim; j++) {\n      std::cout << true_load[i][j] << \" \";\n    }\n    std::cout << std::endl;\n  }\n  std::cout << \"result_num：\"<< num << std::endl << \"result dimension：\" << dim << std::endl;\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","slug":"anns-nsg-code1","published":1,"updated":"2019-08-13T14:31:37.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfcp0002fk0rqnsk5stl","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>近似最近邻搜索中通常会涉及到<code>fvecs</code>和<code>ivecs</code>格式的数据，其中，原始数据一般为<code>fvecs</code>格式的数据，查询结果一般为<code>ivecs</code>格式的。<code>ivecs</code>内部存储的主要是数据的<code>id</code>，数据类型为<code>unsigned</code>类型。就其内部数据结构而言，行数为查询点的个数，列数为对每个查询点查询返回个数再加1，因为每行的第一个位置存储的是对每个查询点查询返回个数。</p>\n<p>可以通过程序来读取<code>ivecs</code>格式数据的内容，下面是用<code>c++</code>程序读取<code>ivecs</code>格式数据内容并输出其查询数据个数和对每个查询点查询返回个数。</p>\n<h2 id=\"C-读取ivecs格式数据\"><a href=\"#C-读取ivecs格式数据\" class=\"headerlink\" title=\"C++读取ivecs格式数据\"></a>C++读取<code>ivecs</code>格式数据</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_ivecs_data</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filename,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt;&amp; results, <span class=\"keyword\">unsigned</span> &amp;num, <span class=\"keyword\">unsigned</span> &amp;dim)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"comment\">//std::cout&lt;&lt;\"data dimension: \"&lt;&lt;dim&lt;&lt;std::endl;</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);</span><br><span class=\"line\">  results.resize(num);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>; i &lt; num; i++) results[i].resize(dim);</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);</span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)results[i].data(), dim * <span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_load;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> dim, num;</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">1</span>], true_load, num, dim);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; dim; j++) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; true_load[i][j] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"result_num：\"</span>&lt;&lt; num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"result dimension：\"</span> &lt;&lt; dim &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>近似最近邻搜索中通常会涉及到<code>fvecs</code>和<code>ivecs</code>格式的数据，其中，原始数据一般为<code>fvecs</code>格式的数据，查询结果一般为<code>ivecs</code>格式的。<code>ivecs</code>内部存储的主要是数据的<code>id</code>，数据类型为<code>unsigned</code>类型。就其内部数据结构而言，行数为查询点的个数，列数为对每个查询点查询返回个数再加1，因为每行的第一个位置存储的是对每个查询点查询返回个数。</p>\n<p>可以通过程序来读取<code>ivecs</code>格式数据的内容，下面是用<code>c++</code>程序读取<code>ivecs</code>格式数据内容并输出其查询数据个数和对每个查询点查询返回个数。</p>\n<h2 id=\"C-读取ivecs格式数据\"><a href=\"#C-读取ivecs格式数据\" class=\"headerlink\" title=\"C++读取ivecs格式数据\"></a>C++读取<code>ivecs</code>格式数据</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_ivecs_data</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filename,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt;&amp; results, <span class=\"keyword\">unsigned</span> &amp;num, <span class=\"keyword\">unsigned</span> &amp;dim)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"comment\">//std::cout&lt;&lt;\"data dimension: \"&lt;&lt;dim&lt;&lt;std::endl;</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);</span><br><span class=\"line\">  results.resize(num);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>; i &lt; num; i++) results[i].resize(dim);</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);</span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)results[i].data(), dim * <span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_load;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> dim, num;</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">1</span>], true_load, num, dim);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; dim; j++) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; true_load[i][j] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"result_num：\"</span>&lt;&lt; num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"result dimension：\"</span> &lt;&lt; dim &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n"},{"title":"C++读取fvecs格式数据（SIFT1M数据集的结构）","date":"2019-08-12T14:00:18.000Z","mathjax":true,"_content":"\n## 引言\n\nsift1M是一个近似最近邻搜索（ANNS）的数据集，它可用于评估ANNS的性能。它包含3个向量子集，分别为：\n\n* 基矢量：执行搜索的矢量\n* 查询向量 \n* 学习向量：查找特定方法中涉及的参数\n\n此外，它以预先计算的k个最近邻居及其平方欧式距离的形式为每个集合提供真值。\n每个向量取 $ 4+d\\times 4B$ ，其中 $ d$ 是维数，$B$ 是字节，具体如下：\n\n| 域值 | 域值类型 | 描述     |\n| ---- | :------: | -------- |\n| d    |   int    | 向量维度 |\n| d*4B |  float   | 向量分量 |\n\n## C++读取`.fvecs`格式数据\n\n```cpp\n#include <iostream>\n#include <fstream>\n\nvoid load_data(char* filename, float*& data, unsigned& num, unsigned& dim) { \n  std::ifstream in(filename, std::ios::binary);\t//以二进制的方式打开文件\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\t//读取向量维度\n  in.seekg(0, std::ios::end);\t//光标定位到文件末尾\n  std::ios::pos_type ss = in.tellg();\t//获取文件大小（多少字节）\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\t//数据的个数\n  data = new float[(size_t)num * (size_t)dim];\n\n  in.seekg(0, std::ios::beg);\t//光标定位到起始处\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\t//光标向右移动4个字节\n    in.read((char*)(data + i * dim), dim * 4);\t//读取数据到一维数据data中\n  }\n  for(size_t i = 0; i < num * dim; i++) {\t//输出数据\n    std::cout << (float)data[i];\n    if(!i) {\n        std::cout << \" \";\n        continue;\n    }\n    if(i % (dim - 1) != 0) {\n      std::cout << \" \";\n    }\n    else{\n      std::cout << std::endl;\n    }\n  }\n  in.close();\n}\n\nint main(int argc, char** argv) {\n  float* data_load = NULL;\n  unsigned points_num, dim;\n  load_data(argv[1], data_load, points_num, dim);\n  std::cout << \"points_num：\"<< points_num << std::endl << \"data dimension：\" << dim << std::endl;\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","source":"_posts/anns-nsg-code2.md","raw":"---\ntitle: C++读取fvecs格式数据（SIFT1M数据集的结构）\ndate: 2019-08-12 22:00:18\ntags:\n- C/C++\n- ANNS\n- 源码阅读\ncategories:\n- 近似最近邻搜索\nmathjax: true\n---\n\n## 引言\n\nsift1M是一个近似最近邻搜索（ANNS）的数据集，它可用于评估ANNS的性能。它包含3个向量子集，分别为：\n\n* 基矢量：执行搜索的矢量\n* 查询向量 \n* 学习向量：查找特定方法中涉及的参数\n\n此外，它以预先计算的k个最近邻居及其平方欧式距离的形式为每个集合提供真值。\n每个向量取 $ 4+d\\times 4B$ ，其中 $ d$ 是维数，$B$ 是字节，具体如下：\n\n| 域值 | 域值类型 | 描述     |\n| ---- | :------: | -------- |\n| d    |   int    | 向量维度 |\n| d*4B |  float   | 向量分量 |\n\n## C++读取`.fvecs`格式数据\n\n```cpp\n#include <iostream>\n#include <fstream>\n\nvoid load_data(char* filename, float*& data, unsigned& num, unsigned& dim) { \n  std::ifstream in(filename, std::ios::binary);\t//以二进制的方式打开文件\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\t//读取向量维度\n  in.seekg(0, std::ios::end);\t//光标定位到文件末尾\n  std::ios::pos_type ss = in.tellg();\t//获取文件大小（多少字节）\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\t//数据的个数\n  data = new float[(size_t)num * (size_t)dim];\n\n  in.seekg(0, std::ios::beg);\t//光标定位到起始处\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\t//光标向右移动4个字节\n    in.read((char*)(data + i * dim), dim * 4);\t//读取数据到一维数据data中\n  }\n  for(size_t i = 0; i < num * dim; i++) {\t//输出数据\n    std::cout << (float)data[i];\n    if(!i) {\n        std::cout << \" \";\n        continue;\n    }\n    if(i % (dim - 1) != 0) {\n      std::cout << \" \";\n    }\n    else{\n      std::cout << std::endl;\n    }\n  }\n  in.close();\n}\n\nint main(int argc, char** argv) {\n  float* data_load = NULL;\n  unsigned points_num, dim;\n  load_data(argv[1], data_load, points_num, dim);\n  std::cout << \"points_num：\"<< points_num << std::endl << \"data dimension：\" << dim << std::endl;\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","slug":"anns-nsg-code2","published":1,"updated":"2019-08-13T14:31:37.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfd00006fk0r6ea8ces9","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>sift1M是一个近似最近邻搜索（ANNS）的数据集，它可用于评估ANNS的性能。它包含3个向量子集，分别为：</p>\n<ul>\n<li>基矢量：执行搜索的矢量</li>\n<li>查询向量 </li>\n<li>学习向量：查找特定方法中涉及的参数</li>\n</ul>\n<p>此外，它以预先计算的k个最近邻居及其平方欧式距离的形式为每个集合提供真值。<br>每个向量取 $ 4+d\\times 4B$ ，其中 $ d$ 是维数，$B$ 是字节，具体如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>域值</th>\n<th style=\"text-align:center\">域值类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>d</td>\n<td style=\"text-align:center\">int</td>\n<td>向量维度</td>\n</tr>\n<tr>\n<td>d*4B</td>\n<td style=\"text-align:center\">float</td>\n<td>向量分量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"C-读取-fvecs格式数据\"><a href=\"#C-读取-fvecs格式数据\" class=\"headerlink\" title=\"C++读取.fvecs格式数据\"></a>C++读取<code>.fvecs</code>格式数据</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_data</span><span class=\"params\">(<span class=\"keyword\">char</span>* filename, <span class=\"keyword\">float</span>*&amp; data, <span class=\"keyword\">unsigned</span>&amp; num, <span class=\"keyword\">unsigned</span>&amp; dim)</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;\t<span class=\"comment\">//以二进制的方式打开文件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);\t<span class=\"comment\">//读取向量维度</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);\t<span class=\"comment\">//光标定位到文件末尾</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();\t<span class=\"comment\">//获取文件大小（多少字节）</span></span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);\t<span class=\"comment\">//数据的个数</span></span><br><span class=\"line\">  data = <span class=\"keyword\">new</span> <span class=\"keyword\">float</span>[(<span class=\"keyword\">size_t</span>)num * (<span class=\"keyword\">size_t</span>)dim];</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);\t<span class=\"comment\">//光标定位到起始处</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);\t<span class=\"comment\">//光标向右移动4个字节</span></span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)(data + i * dim), dim * <span class=\"number\">4</span>);\t<span class=\"comment\">//读取数据到一维数据data中</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num * dim; i++) &#123;\t<span class=\"comment\">//输出数据</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; (<span class=\"keyword\">float</span>)data[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i % (dim - <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">float</span>* data_load = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> points_num, dim;</span><br><span class=\"line\">  load_data(argv[<span class=\"number\">1</span>], data_load, points_num, dim);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"points_num：\"</span>&lt;&lt; points_num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"data dimension：\"</span> &lt;&lt; dim &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>sift1M是一个近似最近邻搜索（ANNS）的数据集，它可用于评估ANNS的性能。它包含3个向量子集，分别为：</p>\n<ul>\n<li>基矢量：执行搜索的矢量</li>\n<li>查询向量 </li>\n<li>学习向量：查找特定方法中涉及的参数</li>\n</ul>\n<p>此外，它以预先计算的k个最近邻居及其平方欧式距离的形式为每个集合提供真值。<br>每个向量取 $ 4+d\\times 4B$ ，其中 $ d$ 是维数，$B$ 是字节，具体如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>域值</th>\n<th style=\"text-align:center\">域值类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>d</td>\n<td style=\"text-align:center\">int</td>\n<td>向量维度</td>\n</tr>\n<tr>\n<td>d*4B</td>\n<td style=\"text-align:center\">float</td>\n<td>向量分量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"C-读取-fvecs格式数据\"><a href=\"#C-读取-fvecs格式数据\" class=\"headerlink\" title=\"C++读取.fvecs格式数据\"></a>C++读取<code>.fvecs</code>格式数据</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_data</span><span class=\"params\">(<span class=\"keyword\">char</span>* filename, <span class=\"keyword\">float</span>*&amp; data, <span class=\"keyword\">unsigned</span>&amp; num, <span class=\"keyword\">unsigned</span>&amp; dim)</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;\t<span class=\"comment\">//以二进制的方式打开文件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);\t<span class=\"comment\">//读取向量维度</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);\t<span class=\"comment\">//光标定位到文件末尾</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();\t<span class=\"comment\">//获取文件大小（多少字节）</span></span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);\t<span class=\"comment\">//数据的个数</span></span><br><span class=\"line\">  data = <span class=\"keyword\">new</span> <span class=\"keyword\">float</span>[(<span class=\"keyword\">size_t</span>)num * (<span class=\"keyword\">size_t</span>)dim];</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);\t<span class=\"comment\">//光标定位到起始处</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);\t<span class=\"comment\">//光标向右移动4个字节</span></span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)(data + i * dim), dim * <span class=\"number\">4</span>);\t<span class=\"comment\">//读取数据到一维数据data中</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num * dim; i++) &#123;\t<span class=\"comment\">//输出数据</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; (<span class=\"keyword\">float</span>)data[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i % (dim - <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">float</span>* data_load = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> points_num, dim;</span><br><span class=\"line\">  load_data(argv[<span class=\"number\">1</span>], data_load, points_num, dim);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"points_num：\"</span>&lt;&lt; points_num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"data dimension：\"</span> &lt;&lt; dim &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n"},{"title":"C++计算召回率","date":"2019-08-12T14:00:22.000Z","mathjax":true,"_content":"\n## 引言\n\n近似最近邻搜索中评估算法的搜索性能经常用到召回率，召回率的计算公式一般为：\n$$\nRecall@K = \\frac{R_1 \\bigcap R_2}{K}\n$$\n其中，$R_1$ 为搜索算法返回的 $K$ 个元素组成的集合，$R_2$ 为查询点真实的 $K$ 个近邻点，$Recall@K$ 为返回 $K$ 个近邻点时的召回率。\n\n## C++代码实现召回率的计算\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nvoid load_ivecs_data(const char* filename,\t//从文件中读取ivecs格式的数据\n                 std::vector<std::vector<unsigned> >& results, unsigned &num, unsigned &dim) {\n  std::ifstream in(filename, std::ios::binary);\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\n  //std::cout<<\"data dimension: \"<<dim<<std::endl;\n  in.seekg(0, std::ios::end);\n  std::ios::pos_type ss = in.tellg();\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\n  results.resize(num);\n  for (unsigned i = 0; i < num; i++) results[i].resize(dim);\n\n  in.seekg(0, std::ios::beg);\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\n    in.read((char*)results[i].data(), dim * 4);\n  }\n  in.close();\n}\n\nvoid cal_recall(std::vector<std::vector<unsigned> > results, std::vector<std::vector<unsigned> > true_data, unsigned num, unsigned k) {//召回率计算\n  float mean_acc = 0;\n  for(size_t i = 0; i < num; i++) {\n    float acc = 0;\n    for(size_t j = 0; j < k; j++) {\n      for(size_t m = 0; m < k; m++) {\n        if(results[i][j] == true_data[i][m]) {\n          acc++;\n          break;\n        }\n      }\n    }\n    mean_acc += acc / k;\n  }\n  std::cout << \"recall: \" << mean_acc / num << std::endl;\n}\n\nint main(int argc, char** argv) {\n  std::vector<std::vector<unsigned> > true_data;\n  std::vector<std::vector<unsigned> > results;\n  unsigned dim, num;\n  load_ivecs_data(argv[1], true_data, num, dim);\n  load_ivecs_data(argv[2], results, num, dim);\n  cal_recall(results, true_data, num, dim);\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","source":"_posts/anns-nsg-code3.md","raw":"---\ntitle: C++计算召回率\ndate: 2019-08-12 22:00:22\ntags:\n- C/C++\n- ANNS\n- 源码阅读\ncategories:\n- 近似最近邻搜索\nmathjax: true\n---\n\n## 引言\n\n近似最近邻搜索中评估算法的搜索性能经常用到召回率，召回率的计算公式一般为：\n$$\nRecall@K = \\frac{R_1 \\bigcap R_2}{K}\n$$\n其中，$R_1$ 为搜索算法返回的 $K$ 个元素组成的集合，$R_2$ 为查询点真实的 $K$ 个近邻点，$Recall@K$ 为返回 $K$ 个近邻点时的召回率。\n\n## C++代码实现召回率的计算\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nvoid load_ivecs_data(const char* filename,\t//从文件中读取ivecs格式的数据\n                 std::vector<std::vector<unsigned> >& results, unsigned &num, unsigned &dim) {\n  std::ifstream in(filename, std::ios::binary);\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\n  //std::cout<<\"data dimension: \"<<dim<<std::endl;\n  in.seekg(0, std::ios::end);\n  std::ios::pos_type ss = in.tellg();\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\n  results.resize(num);\n  for (unsigned i = 0; i < num; i++) results[i].resize(dim);\n\n  in.seekg(0, std::ios::beg);\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\n    in.read((char*)results[i].data(), dim * 4);\n  }\n  in.close();\n}\n\nvoid cal_recall(std::vector<std::vector<unsigned> > results, std::vector<std::vector<unsigned> > true_data, unsigned num, unsigned k) {//召回率计算\n  float mean_acc = 0;\n  for(size_t i = 0; i < num; i++) {\n    float acc = 0;\n    for(size_t j = 0; j < k; j++) {\n      for(size_t m = 0; m < k; m++) {\n        if(results[i][j] == true_data[i][m]) {\n          acc++;\n          break;\n        }\n      }\n    }\n    mean_acc += acc / k;\n  }\n  std::cout << \"recall: \" << mean_acc / num << std::endl;\n}\n\nint main(int argc, char** argv) {\n  std::vector<std::vector<unsigned> > true_data;\n  std::vector<std::vector<unsigned> > results;\n  unsigned dim, num;\n  load_ivecs_data(argv[1], true_data, num, dim);\n  load_ivecs_data(argv[2], results, num, dim);\n  cal_recall(results, true_data, num, dim);\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","slug":"anns-nsg-code3","published":1,"updated":"2019-08-13T14:31:37.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfd30007fk0r2qkcls48","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>近似最近邻搜索中评估算法的搜索性能经常用到召回率，召回率的计算公式一般为：</p>\n<script type=\"math/tex; mode=display\">\nRecall@K = \\frac{R_1 \\bigcap R_2}{K}</script><p>其中，$R_1$ 为搜索算法返回的 $K$ 个元素组成的集合，$R_2$ 为查询点真实的 $K$ 个近邻点，$Recall@K$ 为返回 $K$ 个近邻点时的召回率。</p>\n<h2 id=\"C-代码实现召回率的计算\"><a href=\"#C-代码实现召回率的计算\" class=\"headerlink\" title=\"C++代码实现召回率的计算\"></a>C++代码实现召回率的计算</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_ivecs_data</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filename,\t<span class=\"comment\">//从文件中读取ivecs格式的数据</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt;&amp; results, <span class=\"keyword\">unsigned</span> &amp;num, <span class=\"keyword\">unsigned</span> &amp;dim)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"comment\">//std::cout&lt;&lt;\"data dimension: \"&lt;&lt;dim&lt;&lt;std::endl;</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);</span><br><span class=\"line\">  results.resize(num);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>; i &lt; num; i++) results[i].resize(dim);</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);</span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)results[i].data(), dim * <span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cal_recall</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; results, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_data, <span class=\"keyword\">unsigned</span> num, <span class=\"keyword\">unsigned</span> k)</span> </span>&#123;<span class=\"comment\">//召回率计算</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> mean_acc = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> acc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; k; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> m = <span class=\"number\">0</span>; m &lt; k; m++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(results[i][j] == true_data[i][m]) &#123;</span><br><span class=\"line\">          acc++;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mean_acc += acc / k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"recall: \"</span> &lt;&lt; mean_acc / num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_data;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; results;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> dim, num;</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">1</span>], true_data, num, dim);</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">2</span>], results, num, dim);</span><br><span class=\"line\">  cal_recall(results, true_data, num, dim);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>近似最近邻搜索中评估算法的搜索性能经常用到召回率，召回率的计算公式一般为：</p>\n<script type=\"math/tex; mode=display\">\nRecall@K = \\frac{R_1 \\bigcap R_2}{K}</script><p>其中，$R_1$ 为搜索算法返回的 $K$ 个元素组成的集合，$R_2$ 为查询点真实的 $K$ 个近邻点，$Recall@K$ 为返回 $K$ 个近邻点时的召回率。</p>\n<h2 id=\"C-代码实现召回率的计算\"><a href=\"#C-代码实现召回率的计算\" class=\"headerlink\" title=\"C++代码实现召回率的计算\"></a>C++代码实现召回率的计算</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_ivecs_data</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filename,\t<span class=\"comment\">//从文件中读取ivecs格式的数据</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt;&amp; results, <span class=\"keyword\">unsigned</span> &amp;num, <span class=\"keyword\">unsigned</span> &amp;dim)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"comment\">//std::cout&lt;&lt;\"data dimension: \"&lt;&lt;dim&lt;&lt;std::endl;</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);</span><br><span class=\"line\">  results.resize(num);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>; i &lt; num; i++) results[i].resize(dim);</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);</span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)results[i].data(), dim * <span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cal_recall</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; results, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_data, <span class=\"keyword\">unsigned</span> num, <span class=\"keyword\">unsigned</span> k)</span> </span>&#123;<span class=\"comment\">//召回率计算</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> mean_acc = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> acc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; k; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> m = <span class=\"number\">0</span>; m &lt; k; m++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(results[i][j] == true_data[i][m]) &#123;</span><br><span class=\"line\">          acc++;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mean_acc += acc / k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"recall: \"</span> &lt;&lt; mean_acc / num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_data;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; results;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> dim, num;</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">1</span>], true_data, num, dim);</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">2</span>], results, num, dim);</span><br><span class=\"line\">  cal_recall(results, true_data, num, dim);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n"},{"title":"python读取HDF5格式文件（HDF5格式文件的结构,附高速下载gist数据集）","date":"2019-09-05T13:34:39.000Z","_content":"\n做近似最近邻搜索的实验时，需要用到一些开源数据集，这些数据集的格式并不都是统一的，常见的有**fvecs**&**ivecs**格式，**hdf5**格式。能够读取和保存这些格式的文件是实验的基础，另一方面，测试不同的数据集时，可能需要将一种格式转换成另一种格式。\n\n因为实验代码是以载入**fvecs**格式数据写的，需要将**hdf5**格式转换成**fvecs**&**ivecs**格式可以用python很方便的读取**hdf5**格式的数据集，在此基础上转换为**fvec**&**ivecs**格式。\n\n## hdf5格式的结构\n\n一个hdf5格式的文件是一个包含两个对象的容器，一个是**数据集**（datasets），另一个是**组**（groups）。数据集的结构非常类似于Numpy的**array**，组的结构非常类似于python的字典，它像一个文件夹一样，它可以包含数据集和其它的组。总结起来：**组像字典一样工作，数据集像NumPy数组一样工作**。\n\n拿hdf5格式数据集**gist-960-euclidean.hdf5**为例（[下载地址](http://ann-benchmarks.com/gist-960-euclidean.hdf5)），整个文件有一个**根组**，就是下图的`\"/\"`。\n\n<center>\n<img src=\"hdf5结构1.png\">\n</center>\n\n根组下有四个键，分别为**distances**、**neighbors**、**test**和**train**，类比于上图中的**A**、**B**和**C**。**distances**对应的是shape为**(1000, 100)**的数据集（类比于Numpy的**array**），为每个查询向量最近的100个向量距该查询向量的距离，数据类型为**float32**；**neighbors**对应的是shape为**(1000, 100)**的数据集，为每个查询向量最近的100个向量，数据类型为**int32**；**test**对应的是shape为**(1000000, 960)**的数据集，这是基数据（原始数据），一共1000000个向量，每个向量的维度为960维，数据类型为**float32**；**train**对应的是shape为**(1000, 960)**的数据集，只是查询数据，一共1000个向量，向量的维度为960维，数据类型为**float32**。\n\n## 读取转换过程\n\n安装**h5py**模块。我的python是用**anaconda**装的，可以用下面命令安装。\n\n```shell\nconda install h5py\n```\n\n读取**hdf5**格式文件\n\n```python\nimport h5py\n\nf = h5py.File('gist-960-euclidean.hdf5', 'r')\t#gist-960-euclidean.hdf5为hdf5格式的文件\nprint(list(f.keys()))\t#展示所有的键\n```\n\n## 参考文献\n\n> [1]GZKPeng, HDF5 的介绍以及在python中的应用, https://blog.csdn.net/zkp_987/article/details/79852236, 2019.9.1.\n>\n> [2]python中使用hdf5格式文件的文档：http://docs.h5py.org/en/stable/quick.html","source":"_posts/hdf5使用.md","raw":"---\ntitle: python读取HDF5格式文件（HDF5格式文件的结构,附高速下载gist数据集）\ndate: 2019-09-05 21:34:39\ntags:\n- HDF5\n- python\ncategories:\n- HDF5\n---\n\n做近似最近邻搜索的实验时，需要用到一些开源数据集，这些数据集的格式并不都是统一的，常见的有**fvecs**&**ivecs**格式，**hdf5**格式。能够读取和保存这些格式的文件是实验的基础，另一方面，测试不同的数据集时，可能需要将一种格式转换成另一种格式。\n\n因为实验代码是以载入**fvecs**格式数据写的，需要将**hdf5**格式转换成**fvecs**&**ivecs**格式可以用python很方便的读取**hdf5**格式的数据集，在此基础上转换为**fvec**&**ivecs**格式。\n\n## hdf5格式的结构\n\n一个hdf5格式的文件是一个包含两个对象的容器，一个是**数据集**（datasets），另一个是**组**（groups）。数据集的结构非常类似于Numpy的**array**，组的结构非常类似于python的字典，它像一个文件夹一样，它可以包含数据集和其它的组。总结起来：**组像字典一样工作，数据集像NumPy数组一样工作**。\n\n拿hdf5格式数据集**gist-960-euclidean.hdf5**为例（[下载地址](http://ann-benchmarks.com/gist-960-euclidean.hdf5)），整个文件有一个**根组**，就是下图的`\"/\"`。\n\n<center>\n<img src=\"hdf5结构1.png\">\n</center>\n\n根组下有四个键，分别为**distances**、**neighbors**、**test**和**train**，类比于上图中的**A**、**B**和**C**。**distances**对应的是shape为**(1000, 100)**的数据集（类比于Numpy的**array**），为每个查询向量最近的100个向量距该查询向量的距离，数据类型为**float32**；**neighbors**对应的是shape为**(1000, 100)**的数据集，为每个查询向量最近的100个向量，数据类型为**int32**；**test**对应的是shape为**(1000000, 960)**的数据集，这是基数据（原始数据），一共1000000个向量，每个向量的维度为960维，数据类型为**float32**；**train**对应的是shape为**(1000, 960)**的数据集，只是查询数据，一共1000个向量，向量的维度为960维，数据类型为**float32**。\n\n## 读取转换过程\n\n安装**h5py**模块。我的python是用**anaconda**装的，可以用下面命令安装。\n\n```shell\nconda install h5py\n```\n\n读取**hdf5**格式文件\n\n```python\nimport h5py\n\nf = h5py.File('gist-960-euclidean.hdf5', 'r')\t#gist-960-euclidean.hdf5为hdf5格式的文件\nprint(list(f.keys()))\t#展示所有的键\n```\n\n## 参考文献\n\n> [1]GZKPeng, HDF5 的介绍以及在python中的应用, https://blog.csdn.net/zkp_987/article/details/79852236, 2019.9.1.\n>\n> [2]python中使用hdf5格式文件的文档：http://docs.h5py.org/en/stable/quick.html","slug":"hdf5使用","published":1,"updated":"2019-09-06T04:07:08.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfd50008fk0rgro7a8y4","content":"<p>做近似最近邻搜索的实验时，需要用到一些开源数据集，这些数据集的格式并不都是统一的，常见的有<strong>fvecs</strong>&amp;<strong>ivecs</strong>格式，<strong>hdf5</strong>格式。能够读取和保存这些格式的文件是实验的基础，另一方面，测试不同的数据集时，可能需要将一种格式转换成另一种格式。</p>\n<p>因为实验代码是以载入<strong>fvecs</strong>格式数据写的，需要将<strong>hdf5</strong>格式转换成<strong>fvecs</strong>&amp;<strong>ivecs</strong>格式可以用python很方便的读取<strong>hdf5</strong>格式的数据集，在此基础上转换为<strong>fvec</strong>&amp;<strong>ivecs</strong>格式。</p>\n<h2 id=\"hdf5格式的结构\"><a href=\"#hdf5格式的结构\" class=\"headerlink\" title=\"hdf5格式的结构\"></a>hdf5格式的结构</h2><p>一个hdf5格式的文件是一个包含两个对象的容器，一个是<strong>数据集</strong>（datasets），另一个是<strong>组</strong>（groups）。数据集的结构非常类似于Numpy的<strong>array</strong>，组的结构非常类似于python的字典，它像一个文件夹一样，它可以包含数据集和其它的组。总结起来：<strong>组像字典一样工作，数据集像NumPy数组一样工作</strong>。</p>\n<p>拿hdf5格式数据集<strong>gist-960-euclidean.hdf5</strong>为例（<a href=\"http://ann-benchmarks.com/gist-960-euclidean.hdf5\" target=\"_blank\" rel=\"noopener\">下载地址</a>），整个文件有一个<strong>根组</strong>，就是下图的<code>&quot;/&quot;</code>。</p>\n<center>\n<img src=\"//whenever5225.github.io/2019/09/05/hdf5使用/hdf5结构1.png\">\n</center>\n\n<p>根组下有四个键，分别为<strong>distances</strong>、<strong>neighbors</strong>、<strong>test</strong>和<strong>train</strong>，类比于上图中的<strong>A</strong>、<strong>B</strong>和<strong>C</strong>。<strong>distances</strong>对应的是shape为<strong>(1000, 100)</strong>的数据集（类比于Numpy的<strong>array</strong>），为每个查询向量最近的100个向量距该查询向量的距离，数据类型为<strong>float32</strong>；<strong>neighbors</strong>对应的是shape为<strong>(1000, 100)</strong>的数据集，为每个查询向量最近的100个向量，数据类型为<strong>int32</strong>；<strong>test</strong>对应的是shape为<strong>(1000000, 960)</strong>的数据集，这是基数据（原始数据），一共1000000个向量，每个向量的维度为960维，数据类型为<strong>float32</strong>；<strong>train</strong>对应的是shape为<strong>(1000, 960)</strong>的数据集，只是查询数据，一共1000个向量，向量的维度为960维，数据类型为<strong>float32</strong>。</p>\n<h2 id=\"读取转换过程\"><a href=\"#读取转换过程\" class=\"headerlink\" title=\"读取转换过程\"></a>读取转换过程</h2><p>安装<strong>h5py</strong>模块。我的python是用<strong>anaconda</strong>装的，可以用下面命令安装。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"SHELL\"><figure class=\"iseeu highlight /shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install h5py</span><br></pre></td></tr></table></figure></div>\n<p>读取<strong>hdf5</strong>格式文件</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PYTHON\"><figure class=\"iseeu highlight /python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> h5py</span><br><span class=\"line\"></span><br><span class=\"line\">f = h5py.File(<span class=\"string\">'gist-960-euclidean.hdf5'</span>, <span class=\"string\">'r'</span>)\t<span class=\"comment\">#gist-960-euclidean.hdf5为hdf5格式的文件</span></span><br><span class=\"line\">print(list(f.keys()))\t<span class=\"comment\">#展示所有的键</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]GZKPeng, HDF5 的介绍以及在python中的应用, <a href=\"https://blog.csdn.net/zkp_987/article/details/79852236\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zkp_987/article/details/79852236</a>, 2019.9.1.</p>\n<p>[2]python中使用hdf5格式文件的文档：<a href=\"http://docs.h5py.org/en/stable/quick.html\" target=\"_blank\" rel=\"noopener\">http://docs.h5py.org/en/stable/quick.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>做近似最近邻搜索的实验时，需要用到一些开源数据集，这些数据集的格式并不都是统一的，常见的有<strong>fvecs</strong>&amp;<strong>ivecs</strong>格式，<strong>hdf5</strong>格式。能够读取和保存这些格式的文件是实验的基础，另一方面，测试不同的数据集时，可能需要将一种格式转换成另一种格式。</p>\n<p>因为实验代码是以载入<strong>fvecs</strong>格式数据写的，需要将<strong>hdf5</strong>格式转换成<strong>fvecs</strong>&amp;<strong>ivecs</strong>格式可以用python很方便的读取<strong>hdf5</strong>格式的数据集，在此基础上转换为<strong>fvec</strong>&amp;<strong>ivecs</strong>格式。</p>\n<h2 id=\"hdf5格式的结构\"><a href=\"#hdf5格式的结构\" class=\"headerlink\" title=\"hdf5格式的结构\"></a>hdf5格式的结构</h2><p>一个hdf5格式的文件是一个包含两个对象的容器，一个是<strong>数据集</strong>（datasets），另一个是<strong>组</strong>（groups）。数据集的结构非常类似于Numpy的<strong>array</strong>，组的结构非常类似于python的字典，它像一个文件夹一样，它可以包含数据集和其它的组。总结起来：<strong>组像字典一样工作，数据集像NumPy数组一样工作</strong>。</p>\n<p>拿hdf5格式数据集<strong>gist-960-euclidean.hdf5</strong>为例（<a href=\"http://ann-benchmarks.com/gist-960-euclidean.hdf5\" target=\"_blank\" rel=\"noopener\">下载地址</a>），整个文件有一个<strong>根组</strong>，就是下图的<code>&quot;/&quot;</code>。</p>\n<center>\n<img src=\"//whenever5225.github.io/2019/09/05/hdf5使用/hdf5结构1.png\">\n</center>\n\n<p>根组下有四个键，分别为<strong>distances</strong>、<strong>neighbors</strong>、<strong>test</strong>和<strong>train</strong>，类比于上图中的<strong>A</strong>、<strong>B</strong>和<strong>C</strong>。<strong>distances</strong>对应的是shape为<strong>(1000, 100)</strong>的数据集（类比于Numpy的<strong>array</strong>），为每个查询向量最近的100个向量距该查询向量的距离，数据类型为<strong>float32</strong>；<strong>neighbors</strong>对应的是shape为<strong>(1000, 100)</strong>的数据集，为每个查询向量最近的100个向量，数据类型为<strong>int32</strong>；<strong>test</strong>对应的是shape为<strong>(1000000, 960)</strong>的数据集，这是基数据（原始数据），一共1000000个向量，每个向量的维度为960维，数据类型为<strong>float32</strong>；<strong>train</strong>对应的是shape为<strong>(1000, 960)</strong>的数据集，只是查询数据，一共1000个向量，向量的维度为960维，数据类型为<strong>float32</strong>。</p>\n<h2 id=\"读取转换过程\"><a href=\"#读取转换过程\" class=\"headerlink\" title=\"读取转换过程\"></a>读取转换过程</h2><p>安装<strong>h5py</strong>模块。我的python是用<strong>anaconda</strong>装的，可以用下面命令安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install h5py</span><br></pre></td></tr></table></figure>\n<p>读取<strong>hdf5</strong>格式文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> h5py</span><br><span class=\"line\"></span><br><span class=\"line\">f = h5py.File(<span class=\"string\">'gist-960-euclidean.hdf5'</span>, <span class=\"string\">'r'</span>)\t<span class=\"comment\">#gist-960-euclidean.hdf5为hdf5格式的文件</span></span><br><span class=\"line\">print(list(f.keys()))\t<span class=\"comment\">#展示所有的键</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]GZKPeng, HDF5 的介绍以及在python中的应用, <a href=\"https://blog.csdn.net/zkp_987/article/details/79852236\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zkp_987/article/details/79852236</a>, 2019.9.1.</p>\n<p>[2]python中使用hdf5格式文件的文档：<a href=\"http://docs.h5py.org/en/stable/quick.html\" target=\"_blank\" rel=\"noopener\">http://docs.h5py.org/en/stable/quick.html</a></p>\n</blockquote>\n"},{"title":"PAT乙级1001 || 害死人不偿命的(3n+1)猜想（详解，C/C++示例，测试点分析）","date":"2019-08-09T06:33:15.000Z","_content":"\n# 害死人不偿命的(3n+1)猜想\n## 题目描述\n卡拉兹(Callatz)猜想：\n对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……\n我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1\n## 输入格式\n每个测试输入包含 1 个测试用例，即给出正整数 *n*的值。\n## 输出格式\n输出从 *n* 计算到 1 需要的步数。\n## 输入样例\n```\n 3\n```\n ## 输出样例\n```\n 5\n```\n\n## 问题解决\n\n### 解题思想\n\n用递归的方法，设置一个全局变量，用于统计砍的步数。n=1时直接返回；n=偶数时加一步，然后除以2；n=奇数时乘以3加1后递归调用函数继续计算。\n\n### 代码示例(C语言)\n\n```c\n#include <stdio.h>\nint count=0;//使用全局变量在递归调用中统计砍的次数\nvoid Count(int n);\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    Count(n);\n    printf(\"%d\\n\",count);\n    return 0;\n}\nvoid Count(int n)\n{\n    if(n==1){\n        return;\n    }\n    else if(n%2==0){\n        count++;\n        Count(n/2);\n    }\n    else{\n        Count(3*n+1);\n    }\n}\n\n```\n> 题目来源：PAT乙级1001\n> 作者：CHEN, Yue\n> 单位：浙江大学","source":"_posts/pat1001.md","raw":"---\ntitle: PAT乙级1001 || 害死人不偿命的(3n+1)猜想（详解，C/C++示例，测试点分析）\ndate: 2019-08-09 14:33:15\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# 害死人不偿命的(3n+1)猜想\n## 题目描述\n卡拉兹(Callatz)猜想：\n对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……\n我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1\n## 输入格式\n每个测试输入包含 1 个测试用例，即给出正整数 *n*的值。\n## 输出格式\n输出从 *n* 计算到 1 需要的步数。\n## 输入样例\n```\n 3\n```\n ## 输出样例\n```\n 5\n```\n\n## 问题解决\n\n### 解题思想\n\n用递归的方法，设置一个全局变量，用于统计砍的步数。n=1时直接返回；n=偶数时加一步，然后除以2；n=奇数时乘以3加1后递归调用函数继续计算。\n\n### 代码示例(C语言)\n\n```c\n#include <stdio.h>\nint count=0;//使用全局变量在递归调用中统计砍的次数\nvoid Count(int n);\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    Count(n);\n    printf(\"%d\\n\",count);\n    return 0;\n}\nvoid Count(int n)\n{\n    if(n==1){\n        return;\n    }\n    else if(n%2==0){\n        count++;\n        Count(n/2);\n    }\n    else{\n        Count(3*n+1);\n    }\n}\n\n```\n> 题目来源：PAT乙级1001\n> 作者：CHEN, Yue\n> 单位：浙江大学","slug":"pat1001","published":1,"updated":"2019-08-14T04:12:36.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfdb000bfk0rtfhfqj5n","content":"<h1 id=\"害死人不偿命的-3n-1-猜想\"><a href=\"#害死人不偿命的-3n-1-猜想\" class=\"headerlink\" title=\"害死人不偿命的(3n+1)猜想\"></a>害死人不偿命的(3n+1)猜想</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>卡拉兹(Callatz)猜想：<br>对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……<br>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em>的值。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>输出从 <em>n</em> 计算到 1 需要的步数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>用递归的方法，设置一个全局变量，用于统计砍的步数。n=1时直接返回；n=偶数时加一步，然后除以2；n=奇数时乘以3加1后递归调用函数继续计算。</p>\n<h3 id=\"代码示例-C语言\"><a href=\"#代码示例-C语言\" class=\"headerlink\" title=\"代码示例(C语言)\"></a>代码示例(C语言)</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;<span class=\"comment\">//使用全局变量在递归调用中统计砍的次数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    Count(n);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        Count(n/<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        Count(<span class=\"number\">3</span>*n+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1001<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"害死人不偿命的-3n-1-猜想\"><a href=\"#害死人不偿命的-3n-1-猜想\" class=\"headerlink\" title=\"害死人不偿命的(3n+1)猜想\"></a>害死人不偿命的(3n+1)猜想</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>卡拉兹(Callatz)猜想：<br>对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……<br>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em>的值。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>输出从 <em>n</em> 计算到 1 需要的步数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>用递归的方法，设置一个全局变量，用于统计砍的步数。n=1时直接返回；n=偶数时加一步，然后除以2；n=奇数时乘以3加1后递归调用函数继续计算。</p>\n<h3 id=\"代码示例-C语言\"><a href=\"#代码示例-C语言\" class=\"headerlink\" title=\"代码示例(C语言)\"></a>代码示例(C语言)</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;<span class=\"comment\">//使用全局变量在递归调用中统计砍的次数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    Count(n);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        Count(n/<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        Count(<span class=\"number\">3</span>*n+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1001<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1002 || 写出这个数（详解，C/C++示例，测试点分析）","date":"2019-08-09T06:34:15.000Z","mathjax":true,"_content":"\n# 写出这个数 \n## 题目描述\n读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。\n## 输入格式\n每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 $10^{100}$。\n## 输出格式\n在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。\n## 输入样例\n```lsl\n12345678901234567\n```\n## 输出样例\n```lsl\nqi san\n```\n\n## 问题解决\n### 解题思想\n此题重点需要解决以下问题：\n1. 大数输入问题\n$10^{100}$ 用int和long long都是远远不够的，因此用字符数组来输入，然后再转换成整数\n2. 数字与拼音的转换\n本题用最基本的方法，使用switch开关语句实现转换\n3. 拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。\n此类问题一般使用以下代码实现：\n```c\nfor(i=0; i < n; i++){\n    printf(\"%d\", a[i]);\n    if(i < n-1){\n        printf(\" \");\n    }\n    else{\n        printf(\"\\n\");\n    }\n}\n```\n\n### 知识拓展\n* 绝对值在 $10^9$范围以内的整数都可以定义成int型\n* 如果在 $10^9$以上，在 $10^{18}$ 以内用long long型来存放\n\n### 代码示例（C）\n```c\n#include <stdio.h>\n#define N 101\nint main()\n{\n    int sum=0,i=0,a[N];\n    char str[N];\n    gets(str);//以字符的方式读入大整数\n    while(str[i]!='\\0'){\n        sum+=str[i]-'0';\n        i++;\n    }\n    i=0;\n    do{\n        a[i]=sum%10;\n        sum=sum/10;\n        i++;\n    }while(sum);//将sum的每一位逆向存入数组a中\n    i--;//循环退出时i多加1\n    do{\n        switch(a[i])\n        {\n            case 0:\n                printf(\"ling\");break;\n            case 1:\n                printf(\"yi\");break;\n            case 2:\n                printf(\"er\");break;\n            case 3:\n                printf(\"san\");break;\n            case 4:\n                printf(\"si\");break;\n            case 5:\n                printf(\"wu\");break;\n            case 6:\n                printf(\"liu\");break;\n            case 7:\n                printf(\"qi\");break;\n            case 8:\n                printf(\"ba\");break;\n            default:\n                printf(\"jiu\");\n        }\n        if(i>0){\n            printf(\" \");\n        }\n        else{\n            printf(\"\\n\");\n        }//每两个输出之间用空格隔开，最后不加空格\n        i--;\n    }while(i>=0);\n    return 0;\n}\n```\n>题目来源：PAT乙级1002\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1002.md","raw":"---\ntitle: PAT乙级1002 || 写出这个数（详解，C/C++示例，测试点分析）\ndate: 2019-08-09 14:34:15\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# 写出这个数 \n## 题目描述\n读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。\n## 输入格式\n每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 $10^{100}$。\n## 输出格式\n在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。\n## 输入样例\n```lsl\n12345678901234567\n```\n## 输出样例\n```lsl\nqi san\n```\n\n## 问题解决\n### 解题思想\n此题重点需要解决以下问题：\n1. 大数输入问题\n$10^{100}$ 用int和long long都是远远不够的，因此用字符数组来输入，然后再转换成整数\n2. 数字与拼音的转换\n本题用最基本的方法，使用switch开关语句实现转换\n3. 拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。\n此类问题一般使用以下代码实现：\n```c\nfor(i=0; i < n; i++){\n    printf(\"%d\", a[i]);\n    if(i < n-1){\n        printf(\" \");\n    }\n    else{\n        printf(\"\\n\");\n    }\n}\n```\n\n### 知识拓展\n* 绝对值在 $10^9$范围以内的整数都可以定义成int型\n* 如果在 $10^9$以上，在 $10^{18}$ 以内用long long型来存放\n\n### 代码示例（C）\n```c\n#include <stdio.h>\n#define N 101\nint main()\n{\n    int sum=0,i=0,a[N];\n    char str[N];\n    gets(str);//以字符的方式读入大整数\n    while(str[i]!='\\0'){\n        sum+=str[i]-'0';\n        i++;\n    }\n    i=0;\n    do{\n        a[i]=sum%10;\n        sum=sum/10;\n        i++;\n    }while(sum);//将sum的每一位逆向存入数组a中\n    i--;//循环退出时i多加1\n    do{\n        switch(a[i])\n        {\n            case 0:\n                printf(\"ling\");break;\n            case 1:\n                printf(\"yi\");break;\n            case 2:\n                printf(\"er\");break;\n            case 3:\n                printf(\"san\");break;\n            case 4:\n                printf(\"si\");break;\n            case 5:\n                printf(\"wu\");break;\n            case 6:\n                printf(\"liu\");break;\n            case 7:\n                printf(\"qi\");break;\n            case 8:\n                printf(\"ba\");break;\n            default:\n                printf(\"jiu\");\n        }\n        if(i>0){\n            printf(\" \");\n        }\n        else{\n            printf(\"\\n\");\n        }//每两个输出之间用空格隔开，最后不加空格\n        i--;\n    }while(i>=0);\n    return 0;\n}\n```\n>题目来源：PAT乙级1002\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1002","published":1,"updated":"2019-08-13T14:49:42.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfdf000cfk0r98kcbxa2","content":"<h1 id=\"写出这个数\"><a href=\"#写出这个数\" class=\"headerlink\" title=\"写出这个数\"></a>写出这个数</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 $10^{100}$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">12345678901234567</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qi san</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题重点需要解决以下问题：</p>\n<ol>\n<li>大数输入问题<br>$10^{100}$ 用int和long long都是远远不够的，因此用字符数组来输入，然后再转换成整数</li>\n<li>数字与拼音的转换<br>本题用最基本的方法，使用switch开关语句实现转换</li>\n<li>拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。<br>此类问题一般使用以下代码实现：<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, a[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; n<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n</li>\n</ol>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><ul>\n<li>绝对值在 $10^9$范围以内的整数都可以定义成int型</li>\n<li>如果在 $10^9$以上，在 $10^{18}$ 以内用long long型来存放</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>,i=<span class=\"number\">0</span>,a[N];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[N];</span><br><span class=\"line\">    gets(str);<span class=\"comment\">//以字符的方式读入大整数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[i]!=<span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        sum+=str[i]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        a[i]=sum%<span class=\"number\">10</span>;</span><br><span class=\"line\">        sum=sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(sum);<span class=\"comment\">//将sum的每一位逆向存入数组a中</span></span><br><span class=\"line\">    i--;<span class=\"comment\">//循环退出时i多加1</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(a[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"ling\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"yi\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"er\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"san\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"si\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"wu\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"liu\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"qi\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"ba\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"jiu\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"comment\">//每两个输出之间用空格隔开，最后不加空格</span></span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(i&gt;=<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1002<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"写出这个数\"><a href=\"#写出这个数\" class=\"headerlink\" title=\"写出这个数\"></a>写出这个数</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 $10^{100}$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">12345678901234567</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qi san</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题重点需要解决以下问题：</p>\n<ol>\n<li>大数输入问题<br>$10^{100}$ 用int和long long都是远远不够的，因此用字符数组来输入，然后再转换成整数</li>\n<li>数字与拼音的转换<br>本题用最基本的方法，使用switch开关语句实现转换</li>\n<li>拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。<br>此类问题一般使用以下代码实现：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, a[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; n<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><ul>\n<li>绝对值在 $10^9$范围以内的整数都可以定义成int型</li>\n<li>如果在 $10^9$以上，在 $10^{18}$ 以内用long long型来存放</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>,i=<span class=\"number\">0</span>,a[N];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[N];</span><br><span class=\"line\">    gets(str);<span class=\"comment\">//以字符的方式读入大整数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[i]!=<span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        sum+=str[i]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        a[i]=sum%<span class=\"number\">10</span>;</span><br><span class=\"line\">        sum=sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(sum);<span class=\"comment\">//将sum的每一位逆向存入数组a中</span></span><br><span class=\"line\">    i--;<span class=\"comment\">//循环退出时i多加1</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(a[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"ling\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"yi\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"er\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"san\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"si\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"wu\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"liu\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"qi\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"ba\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"jiu\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"comment\">//每两个输出之间用空格隔开，最后不加空格</span></span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(i&gt;=<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1002<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1003 || 我要通过！（详解，C/C++示例，测试点分析）","date":"2019-08-10T06:34:15.000Z","mathjax":true,"_content":"\n# **我要通过！**\n## 题目描述\n“**答案正确**”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“**答案正确**”大派送 —— 只要读入的字符串满足下列条件，系统就输出“**答案正确**”，否则输出“**答案错误**”。\n得到“**答案正确**”的条件是：\n1. 字符串中必须仅有 `P`、 `A`、 `T`这三种字符，不可以包含其它字符；\n2. 任意形如 `xPATx` 的字符串都可以获得“**答案正确**”，其中 `x` 或者是空字符串，或者是仅由字母 `A` 组成的字符串；\n3. 如果 `aPbTc` 是正确的，那么 `aPbATca` 也是正确的，其中 `a`、 `b`、 `c` 均或者是空字符串，或者是仅由字母 `A` 组成的字符串。\n现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“**答案正确**”的。\n\n## 输入格式\n每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 *n* (<10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。\n## 输出格式\n每个字符串的检测结果占一行，如果该字符串可以获得“**答案正确**”，则输出 `YES`，否则输出 `NO`。\n## 输入样例\n```lsl\n8\nPAT\nPAAT\nAAPATAA\nAAPAATAAAA\nxPATx\nPT\nWhatever\nAPAAATAA\n```\n## 输出样例\n```lsl\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n```\n\n\n## 问题解决\n### 解题思想\n此题难点在于理解题意，有描述的3个条件可知，“**答案正确**”的字符串应满足以下条件：\n1. 必须只包含'P'，'A'，'T'三种字符，含有其它字符时必然是“**答案错误**”\n\n2. 'PAT'两端只能含有'A'，由条件2知，两端'A'的个数相等时，此字符串输出“**答案正确**”\n\n3. 条件3是最难理解的，要使 `aPbTc` 是正确的，则`b`必定是'A'，`a`与`c`中'A'的个数相等时（可同时为0）恰好是条件2的情况，此时 `aPbATca` 也是正确的，以此迭代下去可以得到如下规律（设'P'之前、'P'与'T'之间及'T'之后'A'的个数为count1、count2和count3）：\n$$\n   count1 \\times count2=count3\n$$\n\n理解了题意，代码过程就比较简单了。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#define N 101\nint main()\n{\n    int n,i,j,count1,count2,count3;\n    //count1统计P之前A的个数\n    //count2统计P与T之间A的个数\n    //count3统计T之后A的个数\n    char str[N];\n    scanf(\"%d\",&n);\n    getchar();//吸收掉缓冲区的换行符\n    for(i = 0; i < n; i++){\n        gets(str);\n        j = 0;\n        count1 = count2 = count3 = 0;\n        while(str[j] != '\\0'){\n            if(str[j] == 'P'||str[j] == 'A'||str[j] == 'T'){\n                //首先判断是否满足条件1\n                //找到第一个P\n                while(str[j] == 'A'&&str[j] != '\\0'){\n                    count1++;\n                    j++;\n                }\n                if(str[j]!='\\0'&&str[j] == 'P'){\n                    j++;\n                    while(str[j] == 'A'&&str[j] != '\\0'){\n                        count2++;\n                        j++;\n                    }\n                    if(str[j]!='\\0'&&str[j] == 'T'){\n                        j++;\n                        while(str[j] == 'A'&&str[j] != '\\0'){\n                            count3++;\n                            j++;\n                        }\n                        if(str[j] != '\\0'){//T之后还有除A之外的字符\n                            printf(\"NO\\n\");\n                            break;\n                        }\n                        else{\n                            //满足count1 * count2 == count3且三者不同时为零\n                            if((count1 * count2 == count3)&&(count1||count2||count3)){\n                                printf(\"YES\\n\");\n                                break;\n                            }\n                            else{\n                                printf(\"NO\\n\");\n                                break;\n                            }\n                        }\n                    }\n                    else{\n                        printf(\"NO\\n\");\n                        break;\n                    }\n                }\n                else{\n                    printf(\"NO\\n\");\n                    break;\n                }\n            }\n            else{//不满足条件1\n                printf(\"NO\\n\");\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n```\n>题目来源：PAT乙级1003\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1003.md","raw":"---\ntitle: PAT乙级1003 || 我要通过！（详解，C/C++示例，测试点分析）\ndate: 2019-08-10 14:34:15\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **我要通过！**\n## 题目描述\n“**答案正确**”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“**答案正确**”大派送 —— 只要读入的字符串满足下列条件，系统就输出“**答案正确**”，否则输出“**答案错误**”。\n得到“**答案正确**”的条件是：\n1. 字符串中必须仅有 `P`、 `A`、 `T`这三种字符，不可以包含其它字符；\n2. 任意形如 `xPATx` 的字符串都可以获得“**答案正确**”，其中 `x` 或者是空字符串，或者是仅由字母 `A` 组成的字符串；\n3. 如果 `aPbTc` 是正确的，那么 `aPbATca` 也是正确的，其中 `a`、 `b`、 `c` 均或者是空字符串，或者是仅由字母 `A` 组成的字符串。\n现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“**答案正确**”的。\n\n## 输入格式\n每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 *n* (<10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。\n## 输出格式\n每个字符串的检测结果占一行，如果该字符串可以获得“**答案正确**”，则输出 `YES`，否则输出 `NO`。\n## 输入样例\n```lsl\n8\nPAT\nPAAT\nAAPATAA\nAAPAATAAAA\nxPATx\nPT\nWhatever\nAPAAATAA\n```\n## 输出样例\n```lsl\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n```\n\n\n## 问题解决\n### 解题思想\n此题难点在于理解题意，有描述的3个条件可知，“**答案正确**”的字符串应满足以下条件：\n1. 必须只包含'P'，'A'，'T'三种字符，含有其它字符时必然是“**答案错误**”\n\n2. 'PAT'两端只能含有'A'，由条件2知，两端'A'的个数相等时，此字符串输出“**答案正确**”\n\n3. 条件3是最难理解的，要使 `aPbTc` 是正确的，则`b`必定是'A'，`a`与`c`中'A'的个数相等时（可同时为0）恰好是条件2的情况，此时 `aPbATca` 也是正确的，以此迭代下去可以得到如下规律（设'P'之前、'P'与'T'之间及'T'之后'A'的个数为count1、count2和count3）：\n$$\n   count1 \\times count2=count3\n$$\n\n理解了题意，代码过程就比较简单了。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#define N 101\nint main()\n{\n    int n,i,j,count1,count2,count3;\n    //count1统计P之前A的个数\n    //count2统计P与T之间A的个数\n    //count3统计T之后A的个数\n    char str[N];\n    scanf(\"%d\",&n);\n    getchar();//吸收掉缓冲区的换行符\n    for(i = 0; i < n; i++){\n        gets(str);\n        j = 0;\n        count1 = count2 = count3 = 0;\n        while(str[j] != '\\0'){\n            if(str[j] == 'P'||str[j] == 'A'||str[j] == 'T'){\n                //首先判断是否满足条件1\n                //找到第一个P\n                while(str[j] == 'A'&&str[j] != '\\0'){\n                    count1++;\n                    j++;\n                }\n                if(str[j]!='\\0'&&str[j] == 'P'){\n                    j++;\n                    while(str[j] == 'A'&&str[j] != '\\0'){\n                        count2++;\n                        j++;\n                    }\n                    if(str[j]!='\\0'&&str[j] == 'T'){\n                        j++;\n                        while(str[j] == 'A'&&str[j] != '\\0'){\n                            count3++;\n                            j++;\n                        }\n                        if(str[j] != '\\0'){//T之后还有除A之外的字符\n                            printf(\"NO\\n\");\n                            break;\n                        }\n                        else{\n                            //满足count1 * count2 == count3且三者不同时为零\n                            if((count1 * count2 == count3)&&(count1||count2||count3)){\n                                printf(\"YES\\n\");\n                                break;\n                            }\n                            else{\n                                printf(\"NO\\n\");\n                                break;\n                            }\n                        }\n                    }\n                    else{\n                        printf(\"NO\\n\");\n                        break;\n                    }\n                }\n                else{\n                    printf(\"NO\\n\");\n                    break;\n                }\n            }\n            else{//不满足条件1\n                printf(\"NO\\n\");\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n```\n>题目来源：PAT乙级1003\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1003","published":1,"updated":"2019-08-13T14:31:37.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfdk000gfk0rk3l855sq","content":"<h1 id=\"我要通过！\"><a href=\"#我要通过！\" class=\"headerlink\" title=\"我要通过！\"></a><strong>我要通过！</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>“<strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。<br>得到“<strong>答案正确</strong>”的条件是：</p>\n<ol>\n<li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li>\n<li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li>\n<li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。<br>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</li>\n</ol>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 <em>n</em> (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\">PAT</span><br><span class=\"line\">PAAT</span><br><span class=\"line\">AAPATAA</span><br><span class=\"line\">AAPAATAAAA</span><br><span class=\"line\">xPATx</span><br><span class=\"line\">PT</span><br><span class=\"line\">Whatever</span><br><span class=\"line\">APAAATAA</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题难点在于理解题意，有描述的3个条件可知，“<strong>答案正确</strong>”的字符串应满足以下条件：</p>\n<ol>\n<li><p>必须只包含’P’，’A’，’T’三种字符，含有其它字符时必然是“<strong>答案错误</strong>”</p>\n</li>\n<li><p>‘PAT’两端只能含有’A’，由条件2知，两端’A’的个数相等时，此字符串输出“<strong>答案正确</strong>”</p>\n</li>\n<li><p>条件3是最难理解的，要使 <code>aPbTc</code> 是正确的，则<code>b</code>必定是’A’，<code>a</code>与<code>c</code>中’A’的个数相等时（可同时为0）恰好是条件2的情况，此时 <code>aPbATca</code> 也是正确的，以此迭代下去可以得到如下规律（设’P’之前、’P’与’T’之间及’T’之后’A’的个数为count1、count2和count3）：</p>\n<script type=\"math/tex; mode=display\">\ncount1 \\times count2=count3</script></li>\n</ol>\n<p>理解了题意，代码过程就比较简单了。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,j,count1,count2,count3;</span><br><span class=\"line\">    <span class=\"comment\">//count1统计P之前A的个数</span></span><br><span class=\"line\">    <span class=\"comment\">//count2统计P与T之间A的个数</span></span><br><span class=\"line\">    <span class=\"comment\">//count3统计T之后A的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[N];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    getchar();<span class=\"comment\">//吸收掉缓冲区的换行符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        gets(str);</span><br><span class=\"line\">        j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        count1 = count2 = count3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[j] == <span class=\"string\">'P'</span>||str[j] == <span class=\"string\">'A'</span>||str[j] == <span class=\"string\">'T'</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//首先判断是否满足条件1</span></span><br><span class=\"line\">                <span class=\"comment\">//找到第一个P</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                    count1++;</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[j]!=<span class=\"string\">'\\0'</span>&amp;&amp;str[j] == <span class=\"string\">'P'</span>)&#123;</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                        count2++;</span><br><span class=\"line\">                        j++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(str[j]!=<span class=\"string\">'\\0'</span>&amp;&amp;str[j] == <span class=\"string\">'T'</span>)&#123;</span><br><span class=\"line\">                        j++;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                            count3++;</span><br><span class=\"line\">                            j++;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(str[j] != <span class=\"string\">'\\0'</span>)&#123;<span class=\"comment\">//T之后还有除A之外的字符</span></span><br><span class=\"line\">                            <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">//满足count1 * count2 == count3且三者不同时为零</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span>((count1 * count2 == count3)&amp;&amp;(count1||count2||count3))&#123;</span><br><span class=\"line\">                                <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                                <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//不满足条件1</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1003<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"我要通过！\"><a href=\"#我要通过！\" class=\"headerlink\" title=\"我要通过！\"></a><strong>我要通过！</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>“<strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。<br>得到“<strong>答案正确</strong>”的条件是：</p>\n<ol>\n<li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li>\n<li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li>\n<li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。<br>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</li>\n</ol>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 <em>n</em> (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\">PAT</span><br><span class=\"line\">PAAT</span><br><span class=\"line\">AAPATAA</span><br><span class=\"line\">AAPAATAAAA</span><br><span class=\"line\">xPATx</span><br><span class=\"line\">PT</span><br><span class=\"line\">Whatever</span><br><span class=\"line\">APAAATAA</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题难点在于理解题意，有描述的3个条件可知，“<strong>答案正确</strong>”的字符串应满足以下条件：</p>\n<ol>\n<li><p>必须只包含’P’，’A’，’T’三种字符，含有其它字符时必然是“<strong>答案错误</strong>”</p>\n</li>\n<li><p>‘PAT’两端只能含有’A’，由条件2知，两端’A’的个数相等时，此字符串输出“<strong>答案正确</strong>”</p>\n</li>\n<li><p>条件3是最难理解的，要使 <code>aPbTc</code> 是正确的，则<code>b</code>必定是’A’，<code>a</code>与<code>c</code>中’A’的个数相等时（可同时为0）恰好是条件2的情况，此时 <code>aPbATca</code> 也是正确的，以此迭代下去可以得到如下规律（设’P’之前、’P’与’T’之间及’T’之后’A’的个数为count1、count2和count3）：</p>\n<script type=\"math/tex; mode=display\">\ncount1 \\times count2=count3</script></li>\n</ol>\n<p>理解了题意，代码过程就比较简单了。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,j,count1,count2,count3;</span><br><span class=\"line\">    <span class=\"comment\">//count1统计P之前A的个数</span></span><br><span class=\"line\">    <span class=\"comment\">//count2统计P与T之间A的个数</span></span><br><span class=\"line\">    <span class=\"comment\">//count3统计T之后A的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[N];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    getchar();<span class=\"comment\">//吸收掉缓冲区的换行符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        gets(str);</span><br><span class=\"line\">        j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        count1 = count2 = count3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[j] == <span class=\"string\">'P'</span>||str[j] == <span class=\"string\">'A'</span>||str[j] == <span class=\"string\">'T'</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//首先判断是否满足条件1</span></span><br><span class=\"line\">                <span class=\"comment\">//找到第一个P</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                    count1++;</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[j]!=<span class=\"string\">'\\0'</span>&amp;&amp;str[j] == <span class=\"string\">'P'</span>)&#123;</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                        count2++;</span><br><span class=\"line\">                        j++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(str[j]!=<span class=\"string\">'\\0'</span>&amp;&amp;str[j] == <span class=\"string\">'T'</span>)&#123;</span><br><span class=\"line\">                        j++;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                            count3++;</span><br><span class=\"line\">                            j++;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(str[j] != <span class=\"string\">'\\0'</span>)&#123;<span class=\"comment\">//T之后还有除A之外的字符</span></span><br><span class=\"line\">                            <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">//满足count1 * count2 == count3且三者不同时为零</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span>((count1 * count2 == count3)&amp;&amp;(count1||count2||count3))&#123;</span><br><span class=\"line\">                                <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                                <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//不满足条件1</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1003<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1004 || 成绩排名（详解，C/C++示例，测试点分析）","date":"2019-08-11T07:03:42.000Z","_content":"\n\n# **成绩排名**\n## **题目描述**\n读入 n（>0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。\n## **输入格式**\n每个测试输入包含 1 个测试用例，格式为\n```\n第 1 行：正整数 n\n第 2 行：第 1 个学生的姓名 学号 成绩\n第 3 行：第 2 个学生的姓名 学号 成绩\n... ... ...\n第 n+1 行：第 n 个学生的姓名 学号 成绩\n```\n其中`姓名`和`学号`均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保>证在一组测试用例中没有两个学生的成绩是相同的。\n## **输出格式**\n对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。\n## **输入样例**\n```\n3\nJoe Math990112 89\nMike CS991301 100\nMary EE990830 95\n```\n## **输出样例**\n```lsl\nMike CS991301\nJoe Math990112\n```\n\n##  问题解决\n### 解题思想\n此题注意以下几点即可：\n\n* 输入整数n后，输入缓冲区会有一个换行符，在输入字符串之前要把它吸收掉\n* 由于在一行内输入多个字符串且用空格隔开，因此，不能用gets来输入字符串了，因为gets会把空格也读入，这里用了scanf\n* 不能用赋值符 `=` 来将一个字符串赋给另一个，要用字符串拷贝函数strcpy，此函数包含在头文件 `string.h` 中\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <string.h>//下面要用到strcpy()函数\n#define N 11\nint main()\n{\n    int n,i,score,maxscore,minscore;\n    char name[N],snum[N];\n    char minname[N],minsnum[N],maxname[N],maxsnum[N];\n    maxscore = -1;//最小分数初始化\n    minscore = 101;//最大分数初始化\n    scanf(\"%d\",&n);\n    getchar();//吸收掉缓冲区的换行符\n    for(i = 0; i < n; i++){\n        //下面要使用scanf()函数输入字符串，不能用gets()\n        //因为scanf()函数是以空格、换行等作为字符串结束符，\n        //而gets()只以换行作为输入结束符\n        scanf(\"%s%s%d\",name,snum,&score);\n        if(maxscore<score){\n            maxscore = score;\n            //注意下面要使用字符串拷贝函数，不可直接赋值\n            strcpy(maxname,name);\n            strcpy(maxsnum,snum);\n        }\n        if(minscore>score){\n            minscore = score;\n            strcpy(minname,name);\n            strcpy(minsnum,snum);\n        }\n    }\n    printf(\"%s %s\\n\",maxname,maxsnum);\n    printf(\"%s %s\\n\",minname,minsnum);\n    return 0;\n}\n\n```\n>题目来源：PAT乙级1004\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1004.md","raw":"---\ntitle: PAT乙级1004 || 成绩排名（详解，C/C++示例，测试点分析）\ndate: 2019-08-11 15:03:42\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n\n# **成绩排名**\n## **题目描述**\n读入 n（>0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。\n## **输入格式**\n每个测试输入包含 1 个测试用例，格式为\n```\n第 1 行：正整数 n\n第 2 行：第 1 个学生的姓名 学号 成绩\n第 3 行：第 2 个学生的姓名 学号 成绩\n... ... ...\n第 n+1 行：第 n 个学生的姓名 学号 成绩\n```\n其中`姓名`和`学号`均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保>证在一组测试用例中没有两个学生的成绩是相同的。\n## **输出格式**\n对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。\n## **输入样例**\n```\n3\nJoe Math990112 89\nMike CS991301 100\nMary EE990830 95\n```\n## **输出样例**\n```lsl\nMike CS991301\nJoe Math990112\n```\n\n##  问题解决\n### 解题思想\n此题注意以下几点即可：\n\n* 输入整数n后，输入缓冲区会有一个换行符，在输入字符串之前要把它吸收掉\n* 由于在一行内输入多个字符串且用空格隔开，因此，不能用gets来输入字符串了，因为gets会把空格也读入，这里用了scanf\n* 不能用赋值符 `=` 来将一个字符串赋给另一个，要用字符串拷贝函数strcpy，此函数包含在头文件 `string.h` 中\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <string.h>//下面要用到strcpy()函数\n#define N 11\nint main()\n{\n    int n,i,score,maxscore,minscore;\n    char name[N],snum[N];\n    char minname[N],minsnum[N],maxname[N],maxsnum[N];\n    maxscore = -1;//最小分数初始化\n    minscore = 101;//最大分数初始化\n    scanf(\"%d\",&n);\n    getchar();//吸收掉缓冲区的换行符\n    for(i = 0; i < n; i++){\n        //下面要使用scanf()函数输入字符串，不能用gets()\n        //因为scanf()函数是以空格、换行等作为字符串结束符，\n        //而gets()只以换行作为输入结束符\n        scanf(\"%s%s%d\",name,snum,&score);\n        if(maxscore<score){\n            maxscore = score;\n            //注意下面要使用字符串拷贝函数，不可直接赋值\n            strcpy(maxname,name);\n            strcpy(maxsnum,snum);\n        }\n        if(minscore>score){\n            minscore = score;\n            strcpy(minname,name);\n            strcpy(minsnum,snum);\n        }\n    }\n    printf(\"%s %s\\n\",maxname,maxsnum);\n    printf(\"%s %s\\n\",minname,minsnum);\n    return 0;\n}\n\n```\n>题目来源：PAT乙级1004\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1004","published":1,"updated":"2019-08-13T14:31:37.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfdn000jfk0rxryasrxq","content":"<h1 id=\"成绩排名\"><a href=\"#成绩排名\" class=\"headerlink\" title=\"成绩排名\"></a><strong>成绩排名</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，格式为<br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第 <span class=\"number\">1</span> 行：正整数 n</span><br><span class=\"line\">第 <span class=\"number\">2</span> 行：第 <span class=\"number\">1</span> 个学生的姓名 学号 成绩</span><br><span class=\"line\">第 <span class=\"number\">3</span> 行：第 <span class=\"number\">2</span> 个学生的姓名 学号 成绩</span><br><span class=\"line\">... ... ...</span><br><span class=\"line\">第 n+<span class=\"number\">1</span> 行：第 n 个学生的姓名 学号 成绩</span><br></pre></td></tr></table></figure></div></p>\n<p>其中<code>姓名</code>和<code>学号</code>均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保&gt;证在一组测试用例中没有两个学生的成绩是相同的。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">Joe Math990112 <span class=\"number\">89</span></span><br><span class=\"line\">Mike CS991301 <span class=\"number\">100</span></span><br><span class=\"line\">Mary EE990830 <span class=\"number\">95</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mike CS991301</span><br><span class=\"line\">Joe Math990112</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题注意以下几点即可：</p>\n<ul>\n<li>输入整数n后，输入缓冲区会有一个换行符，在输入字符串之前要把它吸收掉</li>\n<li>由于在一行内输入多个字符串且用空格隔开，因此，不能用gets来输入字符串了，因为gets会把空格也读入，这里用了scanf</li>\n<li>不能用赋值符 <code>=</code> 来将一个字符串赋给另一个，要用字符串拷贝函数strcpy，此函数包含在头文件 <code>string.h</code> 中</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;//下面要用到strcpy()函数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 11</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,score,maxscore,minscore;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[N],snum[N];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> minname[N],minsnum[N],maxname[N],maxsnum[N];</span><br><span class=\"line\">    maxscore = <span class=\"number\">-1</span>;<span class=\"comment\">//最小分数初始化</span></span><br><span class=\"line\">    minscore = <span class=\"number\">101</span>;<span class=\"comment\">//最大分数初始化</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    getchar();<span class=\"comment\">//吸收掉缓冲区的换行符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//下面要使用scanf()函数输入字符串，不能用gets()</span></span><br><span class=\"line\">        <span class=\"comment\">//因为scanf()函数是以空格、换行等作为字符串结束符，</span></span><br><span class=\"line\">        <span class=\"comment\">//而gets()只以换行作为输入结束符</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s%d\"</span>,name,snum,&amp;score);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(maxscore&lt;score)&#123;</span><br><span class=\"line\">            maxscore = score;</span><br><span class=\"line\">            <span class=\"comment\">//注意下面要使用字符串拷贝函数，不可直接赋值</span></span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(maxname,name);</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(maxsnum,snum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(minscore&gt;score)&#123;</span><br><span class=\"line\">            minscore = score;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(minname,name);</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(minsnum,snum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s\\n\"</span>,maxname,maxsnum);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s\\n\"</span>,minname,minsnum);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1004<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"成绩排名\"><a href=\"#成绩排名\" class=\"headerlink\" title=\"成绩排名\"></a><strong>成绩排名</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，格式为<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第 <span class=\"number\">1</span> 行：正整数 n</span><br><span class=\"line\">第 <span class=\"number\">2</span> 行：第 <span class=\"number\">1</span> 个学生的姓名 学号 成绩</span><br><span class=\"line\">第 <span class=\"number\">3</span> 行：第 <span class=\"number\">2</span> 个学生的姓名 学号 成绩</span><br><span class=\"line\">... ... ...</span><br><span class=\"line\">第 n+<span class=\"number\">1</span> 行：第 n 个学生的姓名 学号 成绩</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>姓名</code>和<code>学号</code>均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保&gt;证在一组测试用例中没有两个学生的成绩是相同的。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">Joe Math990112 <span class=\"number\">89</span></span><br><span class=\"line\">Mike CS991301 <span class=\"number\">100</span></span><br><span class=\"line\">Mary EE990830 <span class=\"number\">95</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mike CS991301</span><br><span class=\"line\">Joe Math990112</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题注意以下几点即可：</p>\n<ul>\n<li>输入整数n后，输入缓冲区会有一个换行符，在输入字符串之前要把它吸收掉</li>\n<li>由于在一行内输入多个字符串且用空格隔开，因此，不能用gets来输入字符串了，因为gets会把空格也读入，这里用了scanf</li>\n<li>不能用赋值符 <code>=</code> 来将一个字符串赋给另一个，要用字符串拷贝函数strcpy，此函数包含在头文件 <code>string.h</code> 中</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;//下面要用到strcpy()函数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 11</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,score,maxscore,minscore;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[N],snum[N];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> minname[N],minsnum[N],maxname[N],maxsnum[N];</span><br><span class=\"line\">    maxscore = <span class=\"number\">-1</span>;<span class=\"comment\">//最小分数初始化</span></span><br><span class=\"line\">    minscore = <span class=\"number\">101</span>;<span class=\"comment\">//最大分数初始化</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    getchar();<span class=\"comment\">//吸收掉缓冲区的换行符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//下面要使用scanf()函数输入字符串，不能用gets()</span></span><br><span class=\"line\">        <span class=\"comment\">//因为scanf()函数是以空格、换行等作为字符串结束符，</span></span><br><span class=\"line\">        <span class=\"comment\">//而gets()只以换行作为输入结束符</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s%d\"</span>,name,snum,&amp;score);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(maxscore&lt;score)&#123;</span><br><span class=\"line\">            maxscore = score;</span><br><span class=\"line\">            <span class=\"comment\">//注意下面要使用字符串拷贝函数，不可直接赋值</span></span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(maxname,name);</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(maxsnum,snum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(minscore&gt;score)&#123;</span><br><span class=\"line\">            minscore = score;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(minname,name);</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(minsnum,snum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s\\n\"</span>,maxname,maxsnum);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s\\n\"</span>,minname,minsnum);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1004<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1006 || 换个格式输出整数（详解，C/C++示例，测试点分析）","date":"2019-08-14T04:37:22.000Z","_content":"\n# **换个格式输出整数**\n## **题目描述**\n让我们用字母 `B` 来表示“百”、字母 `S` 表示“十”，用 `12...n` 来表示不为零的个位数字 `n`（<10），换个格式来输出任一个不超过 3 位的正整数。例如 `234` 应该被输出为 `BBSSS1234`，因为它有 2 个“百”、3 个“十”、以及个位的 4。\n## **输入格式**\n## **输入格式**\n每个测试输入包含 1 个测试用例，给出正整数 *n*（<1000）。\n## **输出格式**\n每个测试用例的输出占一行，用规定的格式输出 *n*。\n## **输入样例**\n```null\n234\n```\n## **输出样例**\n```null\nBBSSS1234\n```\n\n## 问题解决\n\n### 解题思想\n\n如果会提取一个多位数的各位数字，那么此题就没有什么难度。\n\n### 知识拓展\n循环n次可以用for循环，也可以用while简洁的方式。\n\n```c\nfor(i = 0; i < n; i++){\n    //循环体\n}\n```\nwhile更简洁形式\n\n```c\nwhile(n--){\n    //循环体\n}\n```\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\nint main()\n{\n    int n,i,h,t,u;\n    scanf(\"%d\",&n);\n    h = n / 100;//百位\n    t = (n % 100) / 10;//十位\n    u = n % 10;//个位\n    for(i = 0; i < h; i++){\n        printf(\"B\");\n    }\n    for(i = 0; i < t; i++){\n        printf(\"S\");\n    }\n    for(i = 0; i < u; i++){\n        printf(\"%d\",i+1);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1006\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1006.md","raw":"---\ntitle: PAT乙级1006 || 换个格式输出整数（详解，C/C++示例，测试点分析）\ndate: 2019-08-14 12:37:22\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **换个格式输出整数**\n## **题目描述**\n让我们用字母 `B` 来表示“百”、字母 `S` 表示“十”，用 `12...n` 来表示不为零的个位数字 `n`（<10），换个格式来输出任一个不超过 3 位的正整数。例如 `234` 应该被输出为 `BBSSS1234`，因为它有 2 个“百”、3 个“十”、以及个位的 4。\n## **输入格式**\n## **输入格式**\n每个测试输入包含 1 个测试用例，给出正整数 *n*（<1000）。\n## **输出格式**\n每个测试用例的输出占一行，用规定的格式输出 *n*。\n## **输入样例**\n```null\n234\n```\n## **输出样例**\n```null\nBBSSS1234\n```\n\n## 问题解决\n\n### 解题思想\n\n如果会提取一个多位数的各位数字，那么此题就没有什么难度。\n\n### 知识拓展\n循环n次可以用for循环，也可以用while简洁的方式。\n\n```c\nfor(i = 0; i < n; i++){\n    //循环体\n}\n```\nwhile更简洁形式\n\n```c\nwhile(n--){\n    //循环体\n}\n```\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\nint main()\n{\n    int n,i,h,t,u;\n    scanf(\"%d\",&n);\n    h = n / 100;//百位\n    t = (n % 100) / 10;//十位\n    u = n % 10;//个位\n    for(i = 0; i < h; i++){\n        printf(\"B\");\n    }\n    for(i = 0; i < t; i++){\n        printf(\"S\");\n    }\n    for(i = 0; i < u; i++){\n        printf(\"%d\",i+1);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1006\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1006","published":1,"updated":"2019-08-14T04:42:39.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfdr000ofk0rpu8nxj8e","content":"<h1 id=\"换个格式输出整数\"><a href=\"#换个格式输出整数\" class=\"headerlink\" title=\"换个格式输出整数\"></a><strong>换个格式输出整数</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>让我们用字母 <code>B</code> 来表示“百”、字母 <code>S</code> 表示“十”，用 <code>12...n</code> 来表示不为零的个位数字 <code>n</code>（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 <code>234</code> 应该被输出为 <code>BBSSS1234</code>，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><h2 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，给出正整数 <em>n</em>（&lt;1000）。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，用规定的格式输出 <em>n</em>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">234</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BBSSS1234</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>如果会提取一个多位数的各位数字，那么此题就没有什么难度。</p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>循环n次可以用for循环，也可以用while简洁的方式。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//循环体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>while更简洁形式</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//循环体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,h,t,u;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    h = n / <span class=\"number\">100</span>;<span class=\"comment\">//百位</span></span><br><span class=\"line\">    t = (n % <span class=\"number\">100</span>) / <span class=\"number\">10</span>;<span class=\"comment\">//十位</span></span><br><span class=\"line\">    u = n % <span class=\"number\">10</span>;<span class=\"comment\">//个位</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; t; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"S\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; u; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1006<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"换个格式输出整数\"><a href=\"#换个格式输出整数\" class=\"headerlink\" title=\"换个格式输出整数\"></a><strong>换个格式输出整数</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>让我们用字母 <code>B</code> 来表示“百”、字母 <code>S</code> 表示“十”，用 <code>12...n</code> 来表示不为零的个位数字 <code>n</code>（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 <code>234</code> 应该被输出为 <code>BBSSS1234</code>，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><h2 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，给出正整数 <em>n</em>（&lt;1000）。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，用规定的格式输出 <em>n</em>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">234</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BBSSS1234</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>如果会提取一个多位数的各位数字，那么此题就没有什么难度。</p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>循环n次可以用for循环，也可以用while简洁的方式。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//循环体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>while更简洁形式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//循环体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,h,t,u;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    h = n / <span class=\"number\">100</span>;<span class=\"comment\">//百位</span></span><br><span class=\"line\">    t = (n % <span class=\"number\">100</span>) / <span class=\"number\">10</span>;<span class=\"comment\">//十位</span></span><br><span class=\"line\">    u = n % <span class=\"number\">10</span>;<span class=\"comment\">//个位</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; t; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"S\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; u; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1006<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1005 || 继续(3n+1)猜想（详解，C/C++示例，测试点分析）","date":"2019-08-14T04:22:24.000Z","_content":"\n# **继续(3n+1)猜想**\n## **题目描述**\n卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。\n当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。\n现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。\n## **输入格式**\n每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 *K* (<100)，第 2 行给出 *K* 个互不相同的待验证的正整数 *n* (1<*n*≤100)的值，数字间用空格隔开。\n## **输出格式**\n每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。\n## **输入样例**\n```null\n6\n3 5 6 7 8 11\n```\n## **输出样例**\n```null\n7 6\n```\n\n##  问题解决\n### 解题思想\n解决此题的关键是*散列思想*，输入格式给出的n的范围已经暗示了这一思想。\n\n1. 用一个标记数组mark（初始化为-1），将输入的每个待判定的数（各数互不相同）作为数组的下标，输入一个r，就把mark[r]的值置为0；\n2. 然后按照从小到大的顺序（想一想为什么从小到大呢？若从大到小呢？其实是一样的）对每个待检测的数（mark[r]==0的r）找r在砍的时候遇到的数j（比如3在砍的时候会依次遇到5、8、4、2、1），并把mark[j]置为1；\n3. 重复过程2，最后从大到小输出mark数组中mark[r]==0的r，即为题目要求的按从大到小的顺序输出关键数字。\n\n`注`：之前在提交时，部分数据出现了段错误(一般是数组下标越界或栈溢出等引起)，费了好大劲才找到错误（低级错误），错误如下，希望大家不要出现我这种错误。\n\n判断j在砍的时候遇到的数时（错误代码）：\n\n```c\nif((j % 2 == 0)&&(j / 2 < 100)){\n    j /= 2;\n    mark[j] = 1;\n}\nelse{\n    j = 3 * j + 1;\n}\n```\n更正后：\n\n```c\nif(j % 2 == 0){\n    j /= 2;\n    if(j < 100){\n        mark[j] = 1;\n    }\n}\nelse{\n    j = 3 * j + 1;\n}\n```\n### 知识拓展\n* 非顺序输出情况下，各个数之间有空格，最后一个数后无空格。借助flag作标记即可\n\n```c\nint flag = 0;\nif(flag == 0){\n    printf(\"%d\",a[i]);\n    flag = 1;\n}\nelse{\n    printf(\" %d\",a[i]);\n}\n```\n\n* memset函数（对数组的每一个元素赋相同的值）格式为：memset(数组名，值，sizeof(数组名));使用memset时，需要在程序开头添加 `string.h` 头文件。初学者最好只用memset给数组赋-1或0，因为-1二进制补码为全1，0的二进制补码为全0，而memset是按字节赋值的。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <string.h>\n#define N 101\nint main()\n{\n    int n,i,r,j,flag = 0,mark[N];//flag作为标记以控制输出格式\n    scanf(\"%d\",&n);\n    memset(mark,-1,sizeof(mark));//mark数组初始化为-1\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&r);\n        mark[r] = 0;//输入以数组下标形式存入数组mark\n    }\n    for(r = 2; r <= 100; r++){\n        j = r;\n        if(mark[j] == 0){\n            do{\n                if(j % 2 == 0){\n                    //下面的if条件中加上j < 100是为了\n                    //防止数组下标越界\n                    j /= 2;\n                    if(j<100){\n                       mark[j] = 1;\n                    }\n                }\n                else{\n                    j = 3 * j + 1;\n                }\n            }while(j != 2);\n        }\n    }\n    for(i = 100; i > 1; i--){\n        //flag==0时为第一次输出数据，其前面不需加空格\n        //flag==1时为第二次以上输出数据，前面加一空格\n        if((mark[i] == 0)&&(flag == 0)){\n            printf(\"%d\",i);\n            flag = 1;\n        }\n        else if((mark[i] == 0)&&(flag == 1)){\n            printf(\" %d\",i);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1005\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1005.md","raw":"---\ntitle: PAT乙级1005 || 继续(3n+1)猜想（详解，C/C++示例，测试点分析）\ndate: 2019-08-14 12:22:24\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **继续(3n+1)猜想**\n## **题目描述**\n卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。\n当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。\n现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。\n## **输入格式**\n每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 *K* (<100)，第 2 行给出 *K* 个互不相同的待验证的正整数 *n* (1<*n*≤100)的值，数字间用空格隔开。\n## **输出格式**\n每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。\n## **输入样例**\n```null\n6\n3 5 6 7 8 11\n```\n## **输出样例**\n```null\n7 6\n```\n\n##  问题解决\n### 解题思想\n解决此题的关键是*散列思想*，输入格式给出的n的范围已经暗示了这一思想。\n\n1. 用一个标记数组mark（初始化为-1），将输入的每个待判定的数（各数互不相同）作为数组的下标，输入一个r，就把mark[r]的值置为0；\n2. 然后按照从小到大的顺序（想一想为什么从小到大呢？若从大到小呢？其实是一样的）对每个待检测的数（mark[r]==0的r）找r在砍的时候遇到的数j（比如3在砍的时候会依次遇到5、8、4、2、1），并把mark[j]置为1；\n3. 重复过程2，最后从大到小输出mark数组中mark[r]==0的r，即为题目要求的按从大到小的顺序输出关键数字。\n\n`注`：之前在提交时，部分数据出现了段错误(一般是数组下标越界或栈溢出等引起)，费了好大劲才找到错误（低级错误），错误如下，希望大家不要出现我这种错误。\n\n判断j在砍的时候遇到的数时（错误代码）：\n\n```c\nif((j % 2 == 0)&&(j / 2 < 100)){\n    j /= 2;\n    mark[j] = 1;\n}\nelse{\n    j = 3 * j + 1;\n}\n```\n更正后：\n\n```c\nif(j % 2 == 0){\n    j /= 2;\n    if(j < 100){\n        mark[j] = 1;\n    }\n}\nelse{\n    j = 3 * j + 1;\n}\n```\n### 知识拓展\n* 非顺序输出情况下，各个数之间有空格，最后一个数后无空格。借助flag作标记即可\n\n```c\nint flag = 0;\nif(flag == 0){\n    printf(\"%d\",a[i]);\n    flag = 1;\n}\nelse{\n    printf(\" %d\",a[i]);\n}\n```\n\n* memset函数（对数组的每一个元素赋相同的值）格式为：memset(数组名，值，sizeof(数组名));使用memset时，需要在程序开头添加 `string.h` 头文件。初学者最好只用memset给数组赋-1或0，因为-1二进制补码为全1，0的二进制补码为全0，而memset是按字节赋值的。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <string.h>\n#define N 101\nint main()\n{\n    int n,i,r,j,flag = 0,mark[N];//flag作为标记以控制输出格式\n    scanf(\"%d\",&n);\n    memset(mark,-1,sizeof(mark));//mark数组初始化为-1\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&r);\n        mark[r] = 0;//输入以数组下标形式存入数组mark\n    }\n    for(r = 2; r <= 100; r++){\n        j = r;\n        if(mark[j] == 0){\n            do{\n                if(j % 2 == 0){\n                    //下面的if条件中加上j < 100是为了\n                    //防止数组下标越界\n                    j /= 2;\n                    if(j<100){\n                       mark[j] = 1;\n                    }\n                }\n                else{\n                    j = 3 * j + 1;\n                }\n            }while(j != 2);\n        }\n    }\n    for(i = 100; i > 1; i--){\n        //flag==0时为第一次输出数据，其前面不需加空格\n        //flag==1时为第二次以上输出数据，前面加一空格\n        if((mark[i] == 0)&&(flag == 0)){\n            printf(\"%d\",i);\n            flag = 1;\n        }\n        else if((mark[i] == 0)&&(flag == 1)){\n            printf(\" %d\",i);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1005\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1005","published":1,"updated":"2019-08-14T04:36:41.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfdt000pfk0rwn2czmxt","content":"<h1 id=\"继续-3n-1-猜想\"><a href=\"#继续-3n-1-猜想\" class=\"headerlink\" title=\"继续(3n+1)猜想\"></a><strong>继续(3n+1)猜想</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。<br>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。<br>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 <em>K</em> (&lt;100)，第 2 行给出 <em>K</em> 个互不相同的待验证的正整数 <em>n</em> (1&lt;<em>n</em>≤100)的值，数字间用空格隔开。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">3 5 6 7 8 11</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 6</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>解决此题的关键是<em>散列思想</em>，输入格式给出的n的范围已经暗示了这一思想。</p>\n<ol>\n<li>用一个标记数组mark（初始化为-1），将输入的每个待判定的数（各数互不相同）作为数组的下标，输入一个r，就把mark[r]的值置为0；</li>\n<li>然后按照从小到大的顺序（想一想为什么从小到大呢？若从大到小呢？其实是一样的）对每个待检测的数（mark[r]==0的r）找r在砍的时候遇到的数j（比如3在砍的时候会依次遇到5、8、4、2、1），并把mark[j]置为1；</li>\n<li>重复过程2，最后从大到小输出mark数组中mark[r]==0的r，即为题目要求的按从大到小的顺序输出关键数字。</li>\n</ol>\n<p><code>注</code>：之前在提交时，部分数据出现了段错误(一般是数组下标越界或栈溢出等引起)，费了好大劲才找到错误（低级错误），错误如下，希望大家不要出现我这种错误。</p>\n<p>判断j在砍的时候遇到的数时（错误代码）：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&amp;&amp;(j / <span class=\"number\">2</span> &lt; <span class=\"number\">100</span>))&#123;</span><br><span class=\"line\">    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>更正后：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j &lt; <span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">        mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><ul>\n<li>非顺序输出情况下，各个数之间有空格，最后一个数后无空格。借助flag作标记即可</li>\n</ul>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>memset函数（对数组的每一个元素赋相同的值）格式为：memset(数组名，值，sizeof(数组名));使用memset时，需要在程序开头添加 <code>string.h</code> 头文件。初学者最好只用memset给数组赋-1或0，因为-1二进制补码为全1，0的二进制补码为全0，而memset是按字节赋值的。</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,r,j,flag = <span class=\"number\">0</span>,mark[N];<span class=\"comment\">//flag作为标记以控制输出格式</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(mark,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(mark));<span class=\"comment\">//mark数组初始化为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;r);</span><br><span class=\"line\">        mark[r] = <span class=\"number\">0</span>;<span class=\"comment\">//输入以数组下标形式存入数组mark</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(r = <span class=\"number\">2</span>; r &lt;= <span class=\"number\">100</span>; r++)&#123;</span><br><span class=\"line\">        j = r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mark[j] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//下面的if条件中加上j &lt; 100是为了</span></span><br><span class=\"line\">                    <span class=\"comment\">//防止数组下标越界</span></span><br><span class=\"line\">                    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                       mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">while</span>(j != <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">100</span>; i &gt; <span class=\"number\">1</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//flag==0时为第一次输出数据，其前面不需加空格</span></span><br><span class=\"line\">        <span class=\"comment\">//flag==1时为第二次以上输出数据，前面加一空格</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((mark[i] == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((mark[i] == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1005<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"继续-3n-1-猜想\"><a href=\"#继续-3n-1-猜想\" class=\"headerlink\" title=\"继续(3n+1)猜想\"></a><strong>继续(3n+1)猜想</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。<br>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。<br>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 <em>K</em> (&lt;100)，第 2 行给出 <em>K</em> 个互不相同的待验证的正整数 <em>n</em> (1&lt;<em>n</em>≤100)的值，数字间用空格隔开。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">3 5 6 7 8 11</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 6</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>解决此题的关键是<em>散列思想</em>，输入格式给出的n的范围已经暗示了这一思想。</p>\n<ol>\n<li>用一个标记数组mark（初始化为-1），将输入的每个待判定的数（各数互不相同）作为数组的下标，输入一个r，就把mark[r]的值置为0；</li>\n<li>然后按照从小到大的顺序（想一想为什么从小到大呢？若从大到小呢？其实是一样的）对每个待检测的数（mark[r]==0的r）找r在砍的时候遇到的数j（比如3在砍的时候会依次遇到5、8、4、2、1），并把mark[j]置为1；</li>\n<li>重复过程2，最后从大到小输出mark数组中mark[r]==0的r，即为题目要求的按从大到小的顺序输出关键数字。</li>\n</ol>\n<p><code>注</code>：之前在提交时，部分数据出现了段错误(一般是数组下标越界或栈溢出等引起)，费了好大劲才找到错误（低级错误），错误如下，希望大家不要出现我这种错误。</p>\n<p>判断j在砍的时候遇到的数时（错误代码）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&amp;&amp;(j / <span class=\"number\">2</span> &lt; <span class=\"number\">100</span>))&#123;</span><br><span class=\"line\">    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正后：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j &lt; <span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">        mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><ul>\n<li>非顺序输出情况下，各个数之间有空格，最后一个数后无空格。借助flag作标记即可</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>memset函数（对数组的每一个元素赋相同的值）格式为：memset(数组名，值，sizeof(数组名));使用memset时，需要在程序开头添加 <code>string.h</code> 头文件。初学者最好只用memset给数组赋-1或0，因为-1二进制补码为全1，0的二进制补码为全0，而memset是按字节赋值的。</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,r,j,flag = <span class=\"number\">0</span>,mark[N];<span class=\"comment\">//flag作为标记以控制输出格式</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(mark,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(mark));<span class=\"comment\">//mark数组初始化为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;r);</span><br><span class=\"line\">        mark[r] = <span class=\"number\">0</span>;<span class=\"comment\">//输入以数组下标形式存入数组mark</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(r = <span class=\"number\">2</span>; r &lt;= <span class=\"number\">100</span>; r++)&#123;</span><br><span class=\"line\">        j = r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mark[j] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//下面的if条件中加上j &lt; 100是为了</span></span><br><span class=\"line\">                    <span class=\"comment\">//防止数组下标越界</span></span><br><span class=\"line\">                    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                       mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">while</span>(j != <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">100</span>; i &gt; <span class=\"number\">1</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//flag==0时为第一次输出数据，其前面不需加空格</span></span><br><span class=\"line\">        <span class=\"comment\">//flag==1时为第二次以上输出数据，前面加一空格</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((mark[i] == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((mark[i] == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1005<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1007 || 素数对猜想（详解，C/C++示例，测试点分析）","date":"2019-08-15T04:19:52.000Z","mathjax":true,"_content":"\n# **素数对猜想**\n## **题目描述**\n让我们定义$d_n$为：$d_n$=p(n+1)-p(n)，其中p(i)是第 $i$ 个素数。显然有$d_1$=1，且对于 $n>1$ 有$d_n$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。\n现给定任意正整数`N`(<$10^5$)，请计算不超过`N`的满足猜想的素数对的个数。\n\n## **输入格式**\n输入在一行给出正整数`N`。\n## **输出格式**\n在一行中输出不超过`N`的满足猜想的素数对的个数。\n## **输入样例**\n```null\n20\n```\n## **输出样例**\n```null\n4\n```\n\n## 问题解决\n\n### 解题思想\n\n此题的关键点为：\n\n* 判断一个数i是否为素数\n* 记录下刚刚判断的最近邻的素数\n\n判定i是否为素数这里我们用判断 $i$ 能够被$2 - \\sqrt{i}$中的某个数所整除，如果$2 - \\sqrt{i}$中存在一个数能整除 $i$，则i就不是素数；反之，如果$2 - \\sqrt{i}$中没有能整除 $i​$ 的数，则i就是素数。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <math.h>\nint main()\n{\n    int n,i,j,pre_prime,count = 0,flag;\n    scanf(\"%d\",&n);\n    pre_prime = 2;//初始化上一个素数为2\n    for(i = 3; i <= n; i++){//当前素数的判定从3开始\n        flag = 0;\n        for(j = 2; j <= sqrt(i); j++){\n            if(i % j == 0){\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0){\n            //如果i是素数（即flag == 0）\n            //且当前素数与上一个素数差为2\n            if(i-pre_prime == 2){\n                count++;\n            }\n            pre_prime = i;//更新上一个素数为当前素数\n        }\n    }\n    printf(\"%d\\n\",count);\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1007\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1007.md","raw":"---\ntitle: PAT乙级1007 || 素数对猜想（详解，C/C++示例，测试点分析）\ndate: 2019-08-15 12:19:52\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **素数对猜想**\n## **题目描述**\n让我们定义$d_n$为：$d_n$=p(n+1)-p(n)，其中p(i)是第 $i$ 个素数。显然有$d_1$=1，且对于 $n>1$ 有$d_n$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。\n现给定任意正整数`N`(<$10^5$)，请计算不超过`N`的满足猜想的素数对的个数。\n\n## **输入格式**\n输入在一行给出正整数`N`。\n## **输出格式**\n在一行中输出不超过`N`的满足猜想的素数对的个数。\n## **输入样例**\n```null\n20\n```\n## **输出样例**\n```null\n4\n```\n\n## 问题解决\n\n### 解题思想\n\n此题的关键点为：\n\n* 判断一个数i是否为素数\n* 记录下刚刚判断的最近邻的素数\n\n判定i是否为素数这里我们用判断 $i$ 能够被$2 - \\sqrt{i}$中的某个数所整除，如果$2 - \\sqrt{i}$中存在一个数能整除 $i$，则i就不是素数；反之，如果$2 - \\sqrt{i}$中没有能整除 $i​$ 的数，则i就是素数。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <math.h>\nint main()\n{\n    int n,i,j,pre_prime,count = 0,flag;\n    scanf(\"%d\",&n);\n    pre_prime = 2;//初始化上一个素数为2\n    for(i = 3; i <= n; i++){//当前素数的判定从3开始\n        flag = 0;\n        for(j = 2; j <= sqrt(i); j++){\n            if(i % j == 0){\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0){\n            //如果i是素数（即flag == 0）\n            //且当前素数与上一个素数差为2\n            if(i-pre_prime == 2){\n                count++;\n            }\n            pre_prime = i;//更新上一个素数为当前素数\n        }\n    }\n    printf(\"%d\\n\",count);\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1007\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1007","published":1,"updated":"2019-08-15T04:50:46.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfdw000tfk0rm52r0ope","content":"<h1 id=\"素数对猜想\"><a href=\"#素数对猜想\" class=\"headerlink\" title=\"素数对猜想\"></a><strong>素数对猜想</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>让我们定义$d_n$为：$d_n$=p(n+1)-p(n)，其中p(i)是第 $i$ 个素数。显然有$d_1$=1，且对于 $n&gt;1$ 有$d_n$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。<br>现给定任意正整数<code>N</code>(&lt;$10^5$)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行给出正整数<code>N</code>。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题的关键点为：</p>\n<ul>\n<li>判断一个数i是否为素数</li>\n<li>记录下刚刚判断的最近邻的素数</li>\n</ul>\n<p>判定i是否为素数这里我们用判断 $i$ 能够被$2 - \\sqrt{i}$中的某个数所整除，如果$2 - \\sqrt{i}$中存在一个数能整除 $i$，则i就不是素数；反之，如果$2 - \\sqrt{i}$中没有能整除 $i​$ 的数，则i就是素数。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,j,pre_prime,count = <span class=\"number\">0</span>,flag;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    pre_prime = <span class=\"number\">2</span>;<span class=\"comment\">//初始化上一个素数为2</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;<span class=\"comment\">//当前素数的判定从3开始</span></span><br><span class=\"line\">        flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">2</span>; j &lt;= <span class=\"built_in\">sqrt</span>(i); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i % j == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果i是素数（即flag == 0）</span></span><br><span class=\"line\">            <span class=\"comment\">//且当前素数与上一个素数差为2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i-pre_prime == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre_prime = i;<span class=\"comment\">//更新上一个素数为当前素数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1007<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"素数对猜想\"><a href=\"#素数对猜想\" class=\"headerlink\" title=\"素数对猜想\"></a><strong>素数对猜想</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>让我们定义$d_n$为：$d_n$=p(n+1)-p(n)，其中p(i)是第 $i$ 个素数。显然有$d_1$=1，且对于 $n&gt;1$ 有$d_n$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。<br>现给定任意正整数<code>N</code>(&lt;$10^5$)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行给出正整数<code>N</code>。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题的关键点为：</p>\n<ul>\n<li>判断一个数i是否为素数</li>\n<li>记录下刚刚判断的最近邻的素数</li>\n</ul>\n<p>判定i是否为素数这里我们用判断 $i$ 能够被$2 - \\sqrt{i}$中的某个数所整除，如果$2 - \\sqrt{i}$中存在一个数能整除 $i$，则i就不是素数；反之，如果$2 - \\sqrt{i}$中没有能整除 $i​$ 的数，则i就是素数。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,j,pre_prime,count = <span class=\"number\">0</span>,flag;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    pre_prime = <span class=\"number\">2</span>;<span class=\"comment\">//初始化上一个素数为2</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;<span class=\"comment\">//当前素数的判定从3开始</span></span><br><span class=\"line\">        flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">2</span>; j &lt;= <span class=\"built_in\">sqrt</span>(i); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i % j == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果i是素数（即flag == 0）</span></span><br><span class=\"line\">            <span class=\"comment\">//且当前素数与上一个素数差为2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i-pre_prime == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre_prime = i;<span class=\"comment\">//更新上一个素数为当前素数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1007<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1008 || 数组元素循环右移问题（详解，C/C++示例，测试点分析）","date":"2019-08-15T04:20:10.000Z","_content":"\n# **数组元素循环右移问题**\n## **题目描述**\n一个数组A中存有N（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A(0),A(1),...,A(N-1))变换为（A(N-M),...,A(N-1),A(0),A(1),...,A(N-M-1)）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？\n## **输入格式**\n每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。\n## **输出格式**\n在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n## **输入样例**\n```null\n6 2\n1 2 3 4 5 6\n```\n## **输出样例**\n```null\n5 6 1 2 3 4\n```\n\n## 问题解决\n\n### 解题思想\n*方法1* (见下面`代码1`)\n题目要求不能用辅助数组，但是由于只需要输出循环右移后的结果，因此，可以“投机取巧”地控制输出就行，这样就比较水了。\n\n*方法2* (见下面`代码2`)\n其实，本题也有高逼格的算法，采用逆置的思想，具体过程如下：\n\n*  对数组a[0],a[1],...,a[n-m-1],a[n-m],...,a[n-1]进行原地逆置得到数组a[n-1],...,a[n-m],a[n-m-1],...,a[1],a[0];\n*  对逆置后的数组的前m个元素进行原地逆置得到a[n-m],...,a[n-1];\n*  对逆置后的数组的后n-m个元素进行原地逆置得到a[0],a[1],...,a[n-m-1];\n*  对上面两个子序列分别逆置后便可得到对原数组循环右移m位的结果。\n\n### 代码示例（C）\n\n`代码1`\n\n```c\n#include <stdio.h>\n#define MAXN 101\nint main()\n{\n    int n,m,i,a[MAXN],flag = 0;//用flag作标记控制输出格式\n    scanf(\"%d%d\",&n,&m);\n    m = m % n;//这一点容易忽略，题目中只给出了M>=0，而没有\n              //说明M与N的大小关系，M是可以大于N的，M大于N\n              //时，右移M位与右移M % N位是等效的\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&a[i]);\n    }\n    for(i = n-m; i < n; i++){\n        if(flag == 0){\n            printf(\"%d\",a[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %d\",a[i]);\n        }\n    }\n    for(i = 0; i < n-m; i++){\n        if(flag == 0){\n            printf(\"%d\",a[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %d\",a[i]);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n`代码2`\n```c\n#include <stdio.h>\n#define MAXN 101\nvoid Reverse_Array(int a[],int start,int stop);\nint main()\n{\n    int n,m,i,a[MAXN];\n    scanf(\"%d%d\",&n,&m);\n    m = m % n;\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&a[i]);\n    }\n    Reverse_Array(a,0,n-1);\n    Reverse_Array(a,0,m-1);\n    Reverse_Array(a,m,n-1);\n    for(i = 0; i < n; i++){\n        printf(\"%d\",a[i]);\n        if(i != n-1){\n            printf(\" \");\n        }\n    }\n    return 0;\n}\n//逆置函数——将数组从下标start位置到stop位置原地逆置\nvoid Reverse_Array(int a[],int start,int stop)\n{\n    int temp;\n    while(start < stop){\n        temp = a[start];\n        a[start] = a[stop];\n        a[stop] = temp;\n        start++;\n        stop--;\n    }\n}\n```\n\n>题目来源：PAT乙级1008\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1008.md","raw":"---\ntitle: PAT乙级1008 || 数组元素循环右移问题（详解，C/C++示例，测试点分析）\ndate: 2019-08-15 12:20:10\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **数组元素循环右移问题**\n## **题目描述**\n一个数组A中存有N（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A(0),A(1),...,A(N-1))变换为（A(N-M),...,A(N-1),A(0),A(1),...,A(N-M-1)）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？\n## **输入格式**\n每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。\n## **输出格式**\n在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n## **输入样例**\n```null\n6 2\n1 2 3 4 5 6\n```\n## **输出样例**\n```null\n5 6 1 2 3 4\n```\n\n## 问题解决\n\n### 解题思想\n*方法1* (见下面`代码1`)\n题目要求不能用辅助数组，但是由于只需要输出循环右移后的结果，因此，可以“投机取巧”地控制输出就行，这样就比较水了。\n\n*方法2* (见下面`代码2`)\n其实，本题也有高逼格的算法，采用逆置的思想，具体过程如下：\n\n*  对数组a[0],a[1],...,a[n-m-1],a[n-m],...,a[n-1]进行原地逆置得到数组a[n-1],...,a[n-m],a[n-m-1],...,a[1],a[0];\n*  对逆置后的数组的前m个元素进行原地逆置得到a[n-m],...,a[n-1];\n*  对逆置后的数组的后n-m个元素进行原地逆置得到a[0],a[1],...,a[n-m-1];\n*  对上面两个子序列分别逆置后便可得到对原数组循环右移m位的结果。\n\n### 代码示例（C）\n\n`代码1`\n\n```c\n#include <stdio.h>\n#define MAXN 101\nint main()\n{\n    int n,m,i,a[MAXN],flag = 0;//用flag作标记控制输出格式\n    scanf(\"%d%d\",&n,&m);\n    m = m % n;//这一点容易忽略，题目中只给出了M>=0，而没有\n              //说明M与N的大小关系，M是可以大于N的，M大于N\n              //时，右移M位与右移M % N位是等效的\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&a[i]);\n    }\n    for(i = n-m; i < n; i++){\n        if(flag == 0){\n            printf(\"%d\",a[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %d\",a[i]);\n        }\n    }\n    for(i = 0; i < n-m; i++){\n        if(flag == 0){\n            printf(\"%d\",a[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %d\",a[i]);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n`代码2`\n```c\n#include <stdio.h>\n#define MAXN 101\nvoid Reverse_Array(int a[],int start,int stop);\nint main()\n{\n    int n,m,i,a[MAXN];\n    scanf(\"%d%d\",&n,&m);\n    m = m % n;\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&a[i]);\n    }\n    Reverse_Array(a,0,n-1);\n    Reverse_Array(a,0,m-1);\n    Reverse_Array(a,m,n-1);\n    for(i = 0; i < n; i++){\n        printf(\"%d\",a[i]);\n        if(i != n-1){\n            printf(\" \");\n        }\n    }\n    return 0;\n}\n//逆置函数——将数组从下标start位置到stop位置原地逆置\nvoid Reverse_Array(int a[],int start,int stop)\n{\n    int temp;\n    while(start < stop){\n        temp = a[start];\n        a[start] = a[stop];\n        a[stop] = temp;\n        start++;\n        stop--;\n    }\n}\n```\n\n>题目来源：PAT乙级1008\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1008","published":1,"updated":"2019-08-17T14:47:26.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfdy000ufk0rkm1q6s5u","content":"<h1 id=\"数组元素循环右移问题\"><a href=\"#数组元素循环右移问题\" class=\"headerlink\" title=\"数组元素循环右移问题\"></a><strong>数组元素循环右移问题</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A(0),A(1),…,A(N-1))变换为（A(N-M),…,A(N-1),A(0),A(1),…,A(N-M-1)）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 2</span><br><span class=\"line\">1 2 3 4 5 6</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 6 1 2 3 4</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p><em>方法1</em> (见下面<code>代码1</code>)<br>题目要求不能用辅助数组，但是由于只需要输出循环右移后的结果，因此，可以“投机取巧”地控制输出就行，这样就比较水了。</p>\n<p><em>方法2</em> (见下面<code>代码2</code>)<br>其实，本题也有高逼格的算法，采用逆置的思想，具体过程如下：</p>\n<ul>\n<li>对数组a[0],a[1],…,a[n-m-1],a[n-m],…,a[n-1]进行原地逆置得到数组a[n-1],…,a[n-m],a[n-m-1],…,a[1],a[0];</li>\n<li>对逆置后的数组的前m个元素进行原地逆置得到a[n-m],…,a[n-1];</li>\n<li>对逆置后的数组的后n-m个元素进行原地逆置得到a[0],a[1],…,a[n-m-1];</li>\n<li>对上面两个子序列分别逆置后便可得到对原数组循环右移m位的结果。</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><p><code>代码1</code></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,m,i,a[MAXN],flag = <span class=\"number\">0</span>;<span class=\"comment\">//用flag作标记控制输出格式</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    m = m % n;<span class=\"comment\">//这一点容易忽略，题目中只给出了M&gt;=0，而没有</span></span><br><span class=\"line\">              <span class=\"comment\">//说明M与N的大小关系，M是可以大于N的，M大于N</span></span><br><span class=\"line\">              <span class=\"comment\">//时，右移M位与右移M % N位是等效的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = n-m; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n-m; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p><code>代码2</code><br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_Array</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> stop)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,m,i,a[MAXN];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    m = m % n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Reverse_Array(a,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    Reverse_Array(a,<span class=\"number\">0</span>,m<span class=\"number\">-1</span>);</span><br><span class=\"line\">    Reverse_Array(a,m,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i != n<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//逆置函数——将数组从下标start位置到stop位置原地逆置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_Array</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> stop)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(start &lt; stop)&#123;</span><br><span class=\"line\">        temp = a[start];</span><br><span class=\"line\">        a[start] = a[stop];</span><br><span class=\"line\">        a[stop] = temp;</span><br><span class=\"line\">        start++;</span><br><span class=\"line\">        stop--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></p>\n<blockquote>\n<p>题目来源：PAT乙级1008<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组元素循环右移问题\"><a href=\"#数组元素循环右移问题\" class=\"headerlink\" title=\"数组元素循环右移问题\"></a><strong>数组元素循环右移问题</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A(0),A(1),…,A(N-1))变换为（A(N-M),…,A(N-1),A(0),A(1),…,A(N-M-1)）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 2</span><br><span class=\"line\">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 6 1 2 3 4</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p><em>方法1</em> (见下面<code>代码1</code>)<br>题目要求不能用辅助数组，但是由于只需要输出循环右移后的结果，因此，可以“投机取巧”地控制输出就行，这样就比较水了。</p>\n<p><em>方法2</em> (见下面<code>代码2</code>)<br>其实，本题也有高逼格的算法，采用逆置的思想，具体过程如下：</p>\n<ul>\n<li>对数组a[0],a[1],…,a[n-m-1],a[n-m],…,a[n-1]进行原地逆置得到数组a[n-1],…,a[n-m],a[n-m-1],…,a[1],a[0];</li>\n<li>对逆置后的数组的前m个元素进行原地逆置得到a[n-m],…,a[n-1];</li>\n<li>对逆置后的数组的后n-m个元素进行原地逆置得到a[0],a[1],…,a[n-m-1];</li>\n<li>对上面两个子序列分别逆置后便可得到对原数组循环右移m位的结果。</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><p><code>代码1</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,m,i,a[MAXN],flag = <span class=\"number\">0</span>;<span class=\"comment\">//用flag作标记控制输出格式</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    m = m % n;<span class=\"comment\">//这一点容易忽略，题目中只给出了M&gt;=0，而没有</span></span><br><span class=\"line\">              <span class=\"comment\">//说明M与N的大小关系，M是可以大于N的，M大于N</span></span><br><span class=\"line\">              <span class=\"comment\">//时，右移M位与右移M % N位是等效的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = n-m; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n-m; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>代码2</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_Array</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> stop)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,m,i,a[MAXN];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    m = m % n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Reverse_Array(a,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    Reverse_Array(a,<span class=\"number\">0</span>,m<span class=\"number\">-1</span>);</span><br><span class=\"line\">    Reverse_Array(a,m,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i != n<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//逆置函数——将数组从下标start位置到stop位置原地逆置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_Array</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> stop)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(start &lt; stop)&#123;</span><br><span class=\"line\">        temp = a[start];</span><br><span class=\"line\">        a[start] = a[stop];</span><br><span class=\"line\">        a[stop] = temp;</span><br><span class=\"line\">        start++;</span><br><span class=\"line\">        stop--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>题目来源：PAT乙级1008<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1009 || 说反话（详解，C/C++示例，测试点分析）","date":"2019-08-15T04:20:16.000Z","_content":"\n# **说反话**\n## **题目描述**\n给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。\n## **输入格式**\n测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。\n## **输出格式**\n每个测试用例的输出占一行，输出倒序后的句子。\n## **输入样例**\n```null\nHello World Here I Come\n```\n## **输出样例**\n```null\nCome I Here World Hello\n```\n\n## 问题解决\n### 解题思想\n*方法1* (见下面`代码1`)\n使用二维数组通过scanf函数输入，遇到一个空格即为一个单词的输入结束，PAT是<u>单点测试</u>，我们知道<u>多点测试</u>的评测系统经常会使用到EOF，scanf函数是有返回值的，它的返回值是其成功读入的参数的个数，scanf函数在读取文件时达到文件末尾导致的无法读取的现象会产生读入失败，读入失败时scanf函数会返回-1，C语言用EOF来表示-1，因此，可用`while(scanf(\"%s\",str[i]) != EOF)`来判断输入是否结束。\n\n**注**：此法代码虽然简单，但有一个点容易出错，如果将如下代码\n\n```c\nwhile(scanf(\"%s\",str[i]) != EOF){\n    i++\n}\n```\n\n写成：\n\n```c\nwhile(scanf(\"%s\",str[i++]) != EOF);\n```\n\n将导致评测系统评测不通过。对于此题，用上面的输入样例检测，上面代码退出循环时i的值是5，而下面的代码退出循环时i的值是6，想一想为什么？可以用笔模拟一下这个过程。\n\n*方法2* (见下面`代码2`)\n使用一维数组，在每个即将输出的单词后面加一个字符串结束符`'\\0'`（否则会输出包含此单词在内后面所有字符串，直到遇到字符串结束符`'\\0'`），用printf函数输出字符串。此法的关键点是控制好i的位置。\n\n### 代码示例（C）\n\n`代码1`\n\n```c\n#include <stdio.h>\n#define MAXN 85\nint main()\n{\n    char str[MAXN][MAXN];\n    int i = 0;\n    //使用EOF来判断输入是否结束\n    while(scanf(\"%s\",str[i]) != EOF){\n        i++;\n    }\n    i--;//i退回到最后一个单词的下标\n    while(i >= 0){\n        //注意要控制输出格式\n        printf(\"%s\",str[i]);\n        if(i > 0){\n            printf(\" \");\n        }\n        i--;\n    }\n    return 0;\n}\n\n```\n\n`代码2`\n```c\n#include <stdio.h>\n#include <string.h>\n#define MAXN 85\n\nint main()\n{\n    int i,flag = 0;\n    char str[MAXN];\n    gets(str);\n    for(i = strlen(str); i >= 0; i--){\n        //在即将输出的单词尾部加一个字符串结束符'\\0'\n        //i移过即将输出的单词\n        str[i] = '\\0';\n        while((str[i] != ' ')&&(i >= 0)){\n            i--;\n        }\n        //如果由于遇到空格退出循环，则i移至即将输出单词的第一个字符\n        if(str[i] == ' '){\n            i++;\n        }\n        //否则i < 0，则即将输出的为第一个单词，i移至其首字符\n        else{\n            i=0;\n        }\n        if(flag == 0){\n            printf(\"%s\",&str[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %s\",&str[i]);\n        }\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1009\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1009.md","raw":"---\ntitle: PAT乙级1009 || 说反话（详解，C/C++示例，测试点分析）\ndate: 2019-08-15 12:20:16\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **说反话**\n## **题目描述**\n给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。\n## **输入格式**\n测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。\n## **输出格式**\n每个测试用例的输出占一行，输出倒序后的句子。\n## **输入样例**\n```null\nHello World Here I Come\n```\n## **输出样例**\n```null\nCome I Here World Hello\n```\n\n## 问题解决\n### 解题思想\n*方法1* (见下面`代码1`)\n使用二维数组通过scanf函数输入，遇到一个空格即为一个单词的输入结束，PAT是<u>单点测试</u>，我们知道<u>多点测试</u>的评测系统经常会使用到EOF，scanf函数是有返回值的，它的返回值是其成功读入的参数的个数，scanf函数在读取文件时达到文件末尾导致的无法读取的现象会产生读入失败，读入失败时scanf函数会返回-1，C语言用EOF来表示-1，因此，可用`while(scanf(\"%s\",str[i]) != EOF)`来判断输入是否结束。\n\n**注**：此法代码虽然简单，但有一个点容易出错，如果将如下代码\n\n```c\nwhile(scanf(\"%s\",str[i]) != EOF){\n    i++\n}\n```\n\n写成：\n\n```c\nwhile(scanf(\"%s\",str[i++]) != EOF);\n```\n\n将导致评测系统评测不通过。对于此题，用上面的输入样例检测，上面代码退出循环时i的值是5，而下面的代码退出循环时i的值是6，想一想为什么？可以用笔模拟一下这个过程。\n\n*方法2* (见下面`代码2`)\n使用一维数组，在每个即将输出的单词后面加一个字符串结束符`'\\0'`（否则会输出包含此单词在内后面所有字符串，直到遇到字符串结束符`'\\0'`），用printf函数输出字符串。此法的关键点是控制好i的位置。\n\n### 代码示例（C）\n\n`代码1`\n\n```c\n#include <stdio.h>\n#define MAXN 85\nint main()\n{\n    char str[MAXN][MAXN];\n    int i = 0;\n    //使用EOF来判断输入是否结束\n    while(scanf(\"%s\",str[i]) != EOF){\n        i++;\n    }\n    i--;//i退回到最后一个单词的下标\n    while(i >= 0){\n        //注意要控制输出格式\n        printf(\"%s\",str[i]);\n        if(i > 0){\n            printf(\" \");\n        }\n        i--;\n    }\n    return 0;\n}\n\n```\n\n`代码2`\n```c\n#include <stdio.h>\n#include <string.h>\n#define MAXN 85\n\nint main()\n{\n    int i,flag = 0;\n    char str[MAXN];\n    gets(str);\n    for(i = strlen(str); i >= 0; i--){\n        //在即将输出的单词尾部加一个字符串结束符'\\0'\n        //i移过即将输出的单词\n        str[i] = '\\0';\n        while((str[i] != ' ')&&(i >= 0)){\n            i--;\n        }\n        //如果由于遇到空格退出循环，则i移至即将输出单词的第一个字符\n        if(str[i] == ' '){\n            i++;\n        }\n        //否则i < 0，则即将输出的为第一个单词，i移至其首字符\n        else{\n            i=0;\n        }\n        if(flag == 0){\n            printf(\"%s\",&str[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %s\",&str[i]);\n        }\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1009\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1009","published":1,"updated":"2019-08-15T04:47:34.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfe1000yfk0rqdiiif2a","content":"<h1 id=\"说反话\"><a href=\"#说反话\" class=\"headerlink\" title=\"说反话\"></a><strong>说反话</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，输出倒序后的句子。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World Here I Come</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Come I Here World Hello</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p><em>方法1</em> (见下面<code>代码1</code>)<br>使用二维数组通过scanf函数输入，遇到一个空格即为一个单词的输入结束，PAT是<u>单点测试</u>，我们知道<u>多点测试</u>的评测系统经常会使用到EOF，scanf函数是有返回值的，它的返回值是其成功读入的参数的个数，scanf函数在读取文件时达到文件末尾导致的无法读取的现象会产生读入失败，读入失败时scanf函数会返回-1，C语言用EOF来表示-1，因此，可用<code>while(scanf(&quot;%s&quot;,str[i]) != EOF)</code>来判断输入是否结束。</p>\n<p><strong>注</strong>：此法代码虽然简单，但有一个点容易出错，如果将如下代码</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>写成：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i++]) != EOF);</span><br></pre></td></tr></table></figure></div>\n<p>将导致评测系统评测不通过。对于此题，用上面的输入样例检测，上面代码退出循环时i的值是5，而下面的代码退出循环时i的值是6，想一想为什么？可以用笔模拟一下这个过程。</p>\n<p><em>方法2</em> (见下面<code>代码2</code>)<br>使用一维数组，在每个即将输出的单词后面加一个字符串结束符<code>&#39;\\0&#39;</code>（否则会输出包含此单词在内后面所有字符串，直到遇到字符串结束符<code>&#39;\\0&#39;</code>），用printf函数输出字符串。此法的关键点是控制好i的位置。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><p><code>代码1</code></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 85</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[MAXN][MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//使用EOF来判断输入是否结束</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i--;<span class=\"comment\">//i退回到最后一个单词的下标</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意要控制输出格式</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,str[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p><code>代码2</code><br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 85</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[MAXN];</span><br><span class=\"line\">    gets(str);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"built_in\">strlen</span>(str); i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//在即将输出的单词尾部加一个字符串结束符'\\0'</span></span><br><span class=\"line\">        <span class=\"comment\">//i移过即将输出的单词</span></span><br><span class=\"line\">        str[i] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>((str[i] != <span class=\"string\">' '</span>)&amp;&amp;(i &gt;= <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果由于遇到空格退出循环，则i移至即将输出单词的第一个字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[i] == <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则i &lt; 0，则即将输出的为第一个单词，i移至其首字符</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,&amp;str[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %s\"</span>,&amp;str[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></p>\n<blockquote>\n<p>题目来源：PAT乙级1009<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说反话\"><a href=\"#说反话\" class=\"headerlink\" title=\"说反话\"></a><strong>说反话</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，输出倒序后的句子。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World Here I Come</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Come I Here World Hello</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p><em>方法1</em> (见下面<code>代码1</code>)<br>使用二维数组通过scanf函数输入，遇到一个空格即为一个单词的输入结束，PAT是<u>单点测试</u>，我们知道<u>多点测试</u>的评测系统经常会使用到EOF，scanf函数是有返回值的，它的返回值是其成功读入的参数的个数，scanf函数在读取文件时达到文件末尾导致的无法读取的现象会产生读入失败，读入失败时scanf函数会返回-1，C语言用EOF来表示-1，因此，可用<code>while(scanf(&quot;%s&quot;,str[i]) != EOF)</code>来判断输入是否结束。</p>\n<p><strong>注</strong>：此法代码虽然简单，但有一个点容易出错，如果将如下代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i++]) != EOF);</span><br></pre></td></tr></table></figure>\n<p>将导致评测系统评测不通过。对于此题，用上面的输入样例检测，上面代码退出循环时i的值是5，而下面的代码退出循环时i的值是6，想一想为什么？可以用笔模拟一下这个过程。</p>\n<p><em>方法2</em> (见下面<code>代码2</code>)<br>使用一维数组，在每个即将输出的单词后面加一个字符串结束符<code>&#39;\\0&#39;</code>（否则会输出包含此单词在内后面所有字符串，直到遇到字符串结束符<code>&#39;\\0&#39;</code>），用printf函数输出字符串。此法的关键点是控制好i的位置。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><p><code>代码1</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 85</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[MAXN][MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//使用EOF来判断输入是否结束</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i--;<span class=\"comment\">//i退回到最后一个单词的下标</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意要控制输出格式</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,str[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>代码2</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 85</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[MAXN];</span><br><span class=\"line\">    gets(str);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"built_in\">strlen</span>(str); i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//在即将输出的单词尾部加一个字符串结束符'\\0'</span></span><br><span class=\"line\">        <span class=\"comment\">//i移过即将输出的单词</span></span><br><span class=\"line\">        str[i] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>((str[i] != <span class=\"string\">' '</span>)&amp;&amp;(i &gt;= <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果由于遇到空格退出循环，则i移至即将输出单词的第一个字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[i] == <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则i &lt; 0，则即将输出的为第一个单词，i移至其首字符</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,&amp;str[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %s\"</span>,&amp;str[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>题目来源：PAT乙级1009<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1010 || 一元多项式求导（详解，C/C++示例，测试点分析）","date":"2019-08-15T04:20:24.000Z","mathjax":true,"_content":"\n# **一元多项式求导**\n## **题目描述**\n设计函数求一元多项式的导数。（注：$x^n$（*n*为整数）的一阶导数为 $n \\cdot x^{n−1}$。)\n## **输入格式**\n以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。\n## **输出格式**\n以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 `0 0`。\n## **输入样例**\n```null\n3 4 -5 2 6 1 -2 0\n```\n## **输出样例**\n```null\n12 3 -10 1 6 0\n```\n\n## 问题解决\n### 解题思想\n本题代码过程非常简单，关键点是要处理到所有的情况，可分为以下3种情况：\n* “零多项式”，求导后仍为“零多项式”，此时输出为：`0 0`\n* 非“零多项式”，求导后变为”零多项式“，此时输出为：`0 0`\n* 非“零多项式”，求导后不为”零多项式“，此时正常输出求导后的系数和指数，但不输出`0 0`\n  对于前两种情况，可用以下条件来判定：\n\n```c\nif((exp == 0)&&(flag == 0))\n```\n\nelse后即为第三种情况，但注意输出格式控制。\n\n### 知识拓展\n我们知道，可以用如下方式来判断是否输入完毕（点击进入相关讲解）：\n\n```c\nwhile(scanf(\"%s\",str[i]) != EOF){\n    //内部操作\n}\n```\n\n这次介绍一种新的方式，如下：\n\n```c\nwhile(~scanf(\"%s\",str[i++])){\n    //内部操作\n}\n```\n\n上面两种方式的效果是完全一样的，原理是什么呢？我们知道，scanf()读入失败时会返回-1，C语言用EOF来表示-1，因此也就有了上面第一种方式。而在机器内部-1的补码表示为全1，`~`是按位取反运算符，全1取反后变为全0，也就是说，当读入结束时，scanf()函数会返回机器补码为全1（也就是-1），经`~`取反后为全0，从而跳出循环。\n\n### 代码示例（C）\n\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int coe,exp,flag = 0;\n    while(~scanf(\"%d%d\",&coe,&exp)){\n        //如果多项式的第一项的指数为0，求导后即为“零多项式”，则应输出0 0\n        //用flag == 0来识别第一项\n        if((exp == 0)&&(flag == 0)){\n            printf(\"%d %d\",exp,exp);\n            break;\n        }\n        //如果第一项的指数不为0，则后面指数为0的项不必输出\n        else if(flag == 0){\n            if(exp != 0){\n                printf(\"%d %d\",coe * exp,exp - 1);\n                flag = 1;\n            }\n        }\n        else{\n            if(exp != 0){\n                printf(\" %d %d\",coe * exp,exp - 1);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1010\n>作者：DS课程组\n>单位：浙江大学","source":"_posts/pat1010.md","raw":"---\ntitle: PAT乙级1010 || 一元多项式求导（详解，C/C++示例，测试点分析）\ndate: 2019-08-15 12:20:24\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **一元多项式求导**\n## **题目描述**\n设计函数求一元多项式的导数。（注：$x^n$（*n*为整数）的一阶导数为 $n \\cdot x^{n−1}$。)\n## **输入格式**\n以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。\n## **输出格式**\n以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 `0 0`。\n## **输入样例**\n```null\n3 4 -5 2 6 1 -2 0\n```\n## **输出样例**\n```null\n12 3 -10 1 6 0\n```\n\n## 问题解决\n### 解题思想\n本题代码过程非常简单，关键点是要处理到所有的情况，可分为以下3种情况：\n* “零多项式”，求导后仍为“零多项式”，此时输出为：`0 0`\n* 非“零多项式”，求导后变为”零多项式“，此时输出为：`0 0`\n* 非“零多项式”，求导后不为”零多项式“，此时正常输出求导后的系数和指数，但不输出`0 0`\n  对于前两种情况，可用以下条件来判定：\n\n```c\nif((exp == 0)&&(flag == 0))\n```\n\nelse后即为第三种情况，但注意输出格式控制。\n\n### 知识拓展\n我们知道，可以用如下方式来判断是否输入完毕（点击进入相关讲解）：\n\n```c\nwhile(scanf(\"%s\",str[i]) != EOF){\n    //内部操作\n}\n```\n\n这次介绍一种新的方式，如下：\n\n```c\nwhile(~scanf(\"%s\",str[i++])){\n    //内部操作\n}\n```\n\n上面两种方式的效果是完全一样的，原理是什么呢？我们知道，scanf()读入失败时会返回-1，C语言用EOF来表示-1，因此也就有了上面第一种方式。而在机器内部-1的补码表示为全1，`~`是按位取反运算符，全1取反后变为全0，也就是说，当读入结束时，scanf()函数会返回机器补码为全1（也就是-1），经`~`取反后为全0，从而跳出循环。\n\n### 代码示例（C）\n\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int coe,exp,flag = 0;\n    while(~scanf(\"%d%d\",&coe,&exp)){\n        //如果多项式的第一项的指数为0，求导后即为“零多项式”，则应输出0 0\n        //用flag == 0来识别第一项\n        if((exp == 0)&&(flag == 0)){\n            printf(\"%d %d\",exp,exp);\n            break;\n        }\n        //如果第一项的指数不为0，则后面指数为0的项不必输出\n        else if(flag == 0){\n            if(exp != 0){\n                printf(\"%d %d\",coe * exp,exp - 1);\n                flag = 1;\n            }\n        }\n        else{\n            if(exp != 0){\n                printf(\" %d %d\",coe * exp,exp - 1);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1010\n>作者：DS课程组\n>单位：浙江大学","slug":"pat1010","published":1,"updated":"2019-08-15T04:47:46.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfe40010fk0rcozgru1m","content":"<h1 id=\"一元多项式求导\"><a href=\"#一元多项式求导\" class=\"headerlink\" title=\"一元多项式求导\"></a><strong>一元多项式求导</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>设计函数求一元多项式的导数。（注：$x^n$（<em>n</em>为整数）的一阶导数为 $n \\cdot x^{n−1}$。)</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 <code>0 0</code>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 4 -5 2 6 1 -2 0</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12 3 -10 1 6 0</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题代码过程非常简单，关键点是要处理到所有的情况，可分为以下3种情况：</p>\n<ul>\n<li>“零多项式”，求导后仍为“零多项式”，此时输出为：<code>0 0</code></li>\n<li>非“零多项式”，求导后变为”零多项式“，此时输出为：<code>0 0</code></li>\n<li>非“零多项式”，求导后不为”零多项式“，此时正常输出求导后的系数和指数，但不输出<code>0 0</code><br>对于前两种情况，可用以下条件来判定：</li>\n</ul>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((<span class=\"built_in\">exp</span> == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure></div>\n<p>else后即为第三种情况，但注意输出格式控制。</p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>我们知道，可以用如下方式来判断是否输入完毕（点击进入相关讲解）：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//内部操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>这次介绍一种新的方式，如下：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i++]))&#123;</span><br><span class=\"line\">    <span class=\"comment\">//内部操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>上面两种方式的效果是完全一样的，原理是什么呢？我们知道，scanf()读入失败时会返回-1，C语言用EOF来表示-1，因此也就有了上面第一种方式。而在机器内部-1的补码表示为全1，<code>~</code>是按位取反运算符，全1取反后变为全0，也就是说，当读入结束时，scanf()函数会返回机器补码为全1（也就是-1），经<code>~</code>取反后为全0，从而跳出循环。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> coe,<span class=\"built_in\">exp</span>,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;coe,&amp;<span class=\"built_in\">exp</span>))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果多项式的第一项的指数为0，求导后即为“零多项式”，则应输出0 0</span></span><br><span class=\"line\">        <span class=\"comment\">//用flag == 0来识别第一项</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((<span class=\"built_in\">exp</span> == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>,<span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果第一项的指数不为0，则后面指数为0的项不必输出</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">exp</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>,coe * <span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">exp</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d %d\"</span>,coe * <span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1010<br>作者：DS课程组<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一元多项式求导\"><a href=\"#一元多项式求导\" class=\"headerlink\" title=\"一元多项式求导\"></a><strong>一元多项式求导</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>设计函数求一元多项式的导数。（注：$x^n$（<em>n</em>为整数）的一阶导数为 $n \\cdot x^{n−1}$。)</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 <code>0 0</code>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 4 -5 2 6 1 -2 0</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12 3 -10 1 6 0</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题代码过程非常简单，关键点是要处理到所有的情况，可分为以下3种情况：</p>\n<ul>\n<li>“零多项式”，求导后仍为“零多项式”，此时输出为：<code>0 0</code></li>\n<li>非“零多项式”，求导后变为”零多项式“，此时输出为：<code>0 0</code></li>\n<li>非“零多项式”，求导后不为”零多项式“，此时正常输出求导后的系数和指数，但不输出<code>0 0</code><br>对于前两种情况，可用以下条件来判定：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((<span class=\"built_in\">exp</span> == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure>\n<p>else后即为第三种情况，但注意输出格式控制。</p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>我们知道，可以用如下方式来判断是否输入完毕（点击进入相关讲解）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//内部操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次介绍一种新的方式，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i++]))&#123;</span><br><span class=\"line\">    <span class=\"comment\">//内部操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种方式的效果是完全一样的，原理是什么呢？我们知道，scanf()读入失败时会返回-1，C语言用EOF来表示-1，因此也就有了上面第一种方式。而在机器内部-1的补码表示为全1，<code>~</code>是按位取反运算符，全1取反后变为全0，也就是说，当读入结束时，scanf()函数会返回机器补码为全1（也就是-1），经<code>~</code>取反后为全0，从而跳出循环。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> coe,<span class=\"built_in\">exp</span>,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;coe,&amp;<span class=\"built_in\">exp</span>))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果多项式的第一项的指数为0，求导后即为“零多项式”，则应输出0 0</span></span><br><span class=\"line\">        <span class=\"comment\">//用flag == 0来识别第一项</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((<span class=\"built_in\">exp</span> == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>,<span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果第一项的指数不为0，则后面指数为0的项不必输出</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">exp</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>,coe * <span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">exp</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d %d\"</span>,coe * <span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1010<br>作者：DS课程组<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1022 || D进制的A+B（详解，C/C++示例，测试点分析）","date":"2019-08-23T04:01:14.000Z","mathjax":true,"_content":"\n# **D进制的A+B**\n## **题目描述**\n输入两个非负 10 进制整数 A 和 B (≤ $2^{30}$ −1)，输出 A+B 的 D (1<D≤10)进制数。\n## **输入格式**\n输入在一行中依次给出 3 个整数 A、B 和 D。\n## **输出格式**\n输出 A+B 的 D 进制数。\n## **输入样例**\n```null\n123 456 8\n```\n## **输出样例**\n```null\n1103\n```\n\n## 问题解决\n### 解题思想\n我们应该都很熟悉十进制转换为二进制的除留取余法，本题的转换为D进制方法同理。先求A加B的十进制和sum，十进制sum转换为D进制具体方法如下：\n1. sum除以D的余数存入数组re[]\n2. sum除以D的结果继续赋值给sum\n3. 重复1,2过程，直到sum为0\n4. 最后顺次倒序输出余数数组re[]\n\n### 代码示例（C/C++）\n\n```cpp\n//除留取余法\n#include <cstdio>\n#define MAXN 32\nusing namespace std;\nint main()\n{\n    unsigned int a,b,d,sum,re[MAXN];//re[]倒序存入sum转换成d进制的每一位,re[0]存sum最高位\n    scanf(\"%d%d%d\",&a,&b,&d);\n    sum = a + b;//a与b的十进制和\n    int i = 0;\n    do{\n        re[i++] = sum % d;\n        sum /= d;\n    }while(sum != 0);\n    while(i--){//上面的循环中i多加了1\n        printf(\"%d\",re[i]);\n    }\n    return 0;\n}\n```\n>题目来源：PAT乙级1022\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/patb1022.md","raw":"---\ntitle: PAT乙级1022 || D进制的A+B（详解，C/C++示例，测试点分析）\ndate: 2019-08-23 12:01:14\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **D进制的A+B**\n## **题目描述**\n输入两个非负 10 进制整数 A 和 B (≤ $2^{30}$ −1)，输出 A+B 的 D (1<D≤10)进制数。\n## **输入格式**\n输入在一行中依次给出 3 个整数 A、B 和 D。\n## **输出格式**\n输出 A+B 的 D 进制数。\n## **输入样例**\n```null\n123 456 8\n```\n## **输出样例**\n```null\n1103\n```\n\n## 问题解决\n### 解题思想\n我们应该都很熟悉十进制转换为二进制的除留取余法，本题的转换为D进制方法同理。先求A加B的十进制和sum，十进制sum转换为D进制具体方法如下：\n1. sum除以D的余数存入数组re[]\n2. sum除以D的结果继续赋值给sum\n3. 重复1,2过程，直到sum为0\n4. 最后顺次倒序输出余数数组re[]\n\n### 代码示例（C/C++）\n\n```cpp\n//除留取余法\n#include <cstdio>\n#define MAXN 32\nusing namespace std;\nint main()\n{\n    unsigned int a,b,d,sum,re[MAXN];//re[]倒序存入sum转换成d进制的每一位,re[0]存sum最高位\n    scanf(\"%d%d%d\",&a,&b,&d);\n    sum = a + b;//a与b的十进制和\n    int i = 0;\n    do{\n        re[i++] = sum % d;\n        sum /= d;\n    }while(sum != 0);\n    while(i--){//上面的循环中i多加了1\n        printf(\"%d\",re[i]);\n    }\n    return 0;\n}\n```\n>题目来源：PAT乙级1022\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"patb1022","published":1,"updated":"2019-08-23T04:38:38.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfe70015fk0rgpzwaups","content":"<h1 id=\"D进制的A-B\"><a href=\"#D进制的A-B\" class=\"headerlink\" title=\"D进制的A+B\"></a><strong>D进制的A+B</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>输入两个非负 10 进制整数 A 和 B (≤ $2^{30}$ −1)，输出 A+B 的 D (1&lt;D≤10)进制数。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行中依次给出 3 个整数 A、B 和 D。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>输出 A+B 的 D 进制数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">123 456 8</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1103</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>我们应该都很熟悉十进制转换为二进制的除留取余法，本题的转换为D进制方法同理。先求A加B的十进制和sum，十进制sum转换为D进制具体方法如下：</p>\n<ol>\n<li>sum除以D的余数存入数组re[]</li>\n<li>sum除以D的结果继续赋值给sum</li>\n<li>重复1,2过程，直到sum为0</li>\n<li>最后顺次倒序输出余数数组re[]</li>\n</ol>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//除留取余法</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 32</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> a,b,d,sum,re[MAXN];<span class=\"comment\">//re[]倒序存入sum转换成d进制的每一位,re[0]存sum最高位</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;a,&amp;b,&amp;d);</span><br><span class=\"line\">    sum = a + b;<span class=\"comment\">//a与b的十进制和</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        re[i++] = sum % d;</span><br><span class=\"line\">        sum /= d;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(sum != <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i--)&#123;<span class=\"comment\">//上面的循环中i多加了1</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,re[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1022<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"D进制的A-B\"><a href=\"#D进制的A-B\" class=\"headerlink\" title=\"D进制的A+B\"></a><strong>D进制的A+B</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>输入两个非负 10 进制整数 A 和 B (≤ $2^{30}$ −1)，输出 A+B 的 D (1&lt;D≤10)进制数。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行中依次给出 3 个整数 A、B 和 D。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>输出 A+B 的 D 进制数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">123 456 8</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1103</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>我们应该都很熟悉十进制转换为二进制的除留取余法，本题的转换为D进制方法同理。先求A加B的十进制和sum，十进制sum转换为D进制具体方法如下：</p>\n<ol>\n<li>sum除以D的余数存入数组re[]</li>\n<li>sum除以D的结果继续赋值给sum</li>\n<li>重复1,2过程，直到sum为0</li>\n<li>最后顺次倒序输出余数数组re[]</li>\n</ol>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//除留取余法</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 32</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> a,b,d,sum,re[MAXN];<span class=\"comment\">//re[]倒序存入sum转换成d进制的每一位,re[0]存sum最高位</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;a,&amp;b,&amp;d);</span><br><span class=\"line\">    sum = a + b;<span class=\"comment\">//a与b的十进制和</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        re[i++] = sum % d;</span><br><span class=\"line\">        sum /= d;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(sum != <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i--)&#123;<span class=\"comment\">//上面的循环中i多加了1</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,re[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1022<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1023 || 组个最小数（详解，C/C++示例，测试点分析）","date":"2019-08-23T04:01:43.000Z","_content":"\n# **组个最小数**\n## **题目描述**\n现给定若干个范围在 0-9 的数字。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定三个 0，一个 1，两个 5，三个 7，我们得到的最小的数就是 100055777。\n现给定数字，请编写程序输出能够组成的最小的数。\n\n## **输入格式**\n输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。\n## **输出格式**\n在一行中输出能够组成的最小的数。\n## **输入样例**\n```null\n3 1 0 0 0 2 0 3 0 0\n```\n## **输出样例**\n```null\n100055777\n```\n\n## 问题解决\n### 解题思想\n设置一个数组存入每个数字的个数；因为至少有一个非零的数字，所以输出不可能为0，第一个必输出一个最小的个数为非零个的非零数字，然后从0开始依次按个数输出每个数字。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\nusing namespace std;\nint main()\n{\n    int num_count[10];\n    for(int i = 0; i < 10; i++){\n        scanf(\"%d\",&num_count[i]);\n    }\n    for(int i = 1; i < 10; i++){//先输出一个最小的个数为非零个的非零数字\n        if(num_count[i] != 0){\n            printf(\"%d\",i);\n            num_count[i]--;//输出后个数减一\n            break;\n        }\n    }\n    for(int i = 0; i < 10; i++){//顺次从小到大按个数输出各数字\n        for(int j = 0; j < num_count[i]; j++){\n            printf(\"%d\",i);\n        }\n    }\n    return 0;\n}\n```\n>题目来源：PAT乙级1023\n>作者：CAO, Peng\n>单位：Google","source":"_posts/patb1023.md","raw":"---\ntitle: PAT乙级1023 || 组个最小数（详解，C/C++示例，测试点分析）\ndate: 2019-08-23 12:01:43\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **组个最小数**\n## **题目描述**\n现给定若干个范围在 0-9 的数字。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定三个 0，一个 1，两个 5，三个 7，我们得到的最小的数就是 100055777。\n现给定数字，请编写程序输出能够组成的最小的数。\n\n## **输入格式**\n输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。\n## **输出格式**\n在一行中输出能够组成的最小的数。\n## **输入样例**\n```null\n3 1 0 0 0 2 0 3 0 0\n```\n## **输出样例**\n```null\n100055777\n```\n\n## 问题解决\n### 解题思想\n设置一个数组存入每个数字的个数；因为至少有一个非零的数字，所以输出不可能为0，第一个必输出一个最小的个数为非零个的非零数字，然后从0开始依次按个数输出每个数字。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\nusing namespace std;\nint main()\n{\n    int num_count[10];\n    for(int i = 0; i < 10; i++){\n        scanf(\"%d\",&num_count[i]);\n    }\n    for(int i = 1; i < 10; i++){//先输出一个最小的个数为非零个的非零数字\n        if(num_count[i] != 0){\n            printf(\"%d\",i);\n            num_count[i]--;//输出后个数减一\n            break;\n        }\n    }\n    for(int i = 0; i < 10; i++){//顺次从小到大按个数输出各数字\n        for(int j = 0; j < num_count[i]; j++){\n            printf(\"%d\",i);\n        }\n    }\n    return 0;\n}\n```\n>题目来源：PAT乙级1023\n>作者：CAO, Peng\n>单位：Google","slug":"patb1023","published":1,"updated":"2019-08-23T04:24:13.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfea0018fk0r9lp7r6dd","content":"<h1 id=\"组个最小数\"><a href=\"#组个最小数\" class=\"headerlink\" title=\"组个最小数\"></a><strong>组个最小数</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>现给定若干个范围在 0-9 的数字。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定三个 0，一个 1，两个 5，三个 7，我们得到的最小的数就是 100055777。<br>现给定数字，请编写程序输出能够组成的最小的数。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出能够组成的最小的数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 1 0 0 0 2 0 3 0 0</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100055777</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>设置一个数组存入每个数字的个数；因为至少有一个非零的数字，所以输出不可能为0，第一个必输出一个最小的个数为非零个的非零数字，然后从0开始依次按个数输出每个数字。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num_count[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;num_count[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;<span class=\"comment\">//先输出一个最小的个数为非零个的非零数字</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num_count[i] != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i);</span><br><span class=\"line\">            num_count[i]--;<span class=\"comment\">//输出后个数减一</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;<span class=\"comment\">//顺次从小到大按个数输出各数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; num_count[i]; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1023<br>作者：CAO, Peng<br>单位：Google</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"组个最小数\"><a href=\"#组个最小数\" class=\"headerlink\" title=\"组个最小数\"></a><strong>组个最小数</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>现给定若干个范围在 0-9 的数字。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定三个 0，一个 1，两个 5，三个 7，我们得到的最小的数就是 100055777。<br>现给定数字，请编写程序输出能够组成的最小的数。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出能够组成的最小的数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 1 0 0 0 2 0 3 0 0</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100055777</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>设置一个数组存入每个数字的个数；因为至少有一个非零的数字，所以输出不可能为0，第一个必输出一个最小的个数为非零个的非零数字，然后从0开始依次按个数输出每个数字。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num_count[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;num_count[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;<span class=\"comment\">//先输出一个最小的个数为非零个的非零数字</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num_count[i] != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i);</span><br><span class=\"line\">            num_count[i]--;<span class=\"comment\">//输出后个数减一</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;<span class=\"comment\">//顺次从小到大按个数输出各数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; num_count[i]; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1023<br>作者：CAO, Peng<br>单位：Google</p>\n</blockquote>\n"},{"title":"PAT乙级1025 || 反转链表（详解，C/C++示例，测试点分析）","date":"2019-08-23T04:01:56.000Z","mathjax":true,"_content":"\n# **反转链表**\n## **题目描述**\n给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。\n## **输入格式**\n每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 *N* (≤$10^5$)、以及正整数 *K* (≤*N*)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。\n\n接下来有 *N* 行，每行格式为：\n\n```null\nAddress Data Next\n```\n\n其中 `Address` 是结点地址，`Data` 是该结点保存的整数数据，`Next` 是下一结点的地址。\n\n## **输出格式**\n对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。\n## **输入样例**\n```null\n00100 6 4\n00000 4 99999\n00100 1 12309\n68237 6 -1\n33218 3 00000\n99999 5 68237\n12309 2 33218\n```\n## **输出样例**\n```null\n00000 4 33218\n33218 3 12309\n12309 2 00100\n00100 1 99999\n99999 5 68237\n68237 6 -1\n```\n\n## 问题解决\n### 解题思想\n本题要处理的细节较多。首先，单链表可采用静态链表的存储结构（当然也可以选择用指针的链式结构），定义一个结构体数组，下标为当前结点地址，两个成员分别是结点数据和下一个结点的地址；然后，需要统计输入的有效结点个数cou_n，cou_n / k即为需要反转的组数（也为调用反转函数的次数）；\n以下几点容易忽略：\n* 统计输入的有效结点个数。若用n / k来表示需要反转的次数，则导致PATOJ的最后一个测试点不通过。\n* 输出格式的控制。除了最后的-1外，其它地址都是5位非负整数，不足5位的左侧要补0。\n* 反转时第一组结点需要特殊处理。第一组结点反转后的第一个结点即为整个链表的第一个结点，需要记录下来，以便输出。\n* 头插法反转防断链处理。采用头插法反转链表，需要设置一个指针指向待处理结点的下一个结点，否则会因断链而无法到达下一个结点。\n\n### 知识拓展\n我们知道在C语言中，要想通过函数来改变变量的值，只通过值传递参数的形式是不能实现的，我们要通过地址传递的方式，比如数组，指针。而在C++中，我们有更为简便的方式——引用，引用相当于给对象取一个别名，通过该别名，我们可以对该对象进行相关操作，并可对主调函数的相应实参进行修改，使用时，在形参名前面加一个&符号即可(例如本题的函数形参中的addre_start，它与实参addre_start[0]对应，改变addre_start的值相应的addre_start[0]的值也会改变)。关于引用的更多讲解，大家可暂时查看C++相关书籍等。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#define MAXN 100000\nusing namespace std;\nvoid Reverse_K(struct node Link_node[],int &addre_start,int k);\n//单链表结点\nstruct node\n{\n    int data;//结点数据\n    int next;//下一个结点地址\n}Link_node[MAXN];//下标为当前结点地址\nint main()\n{\n    int addre,n,k;//addre为第 1 个结点的地址\n    scanf(\"%d%d%d\",&addre,&n,&k);//第一行输入\n    int address;//暂存输入的地址\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\",&address);//当前结点地址\n        //当前结点数据及下一个结点地址\n        scanf(\"%d%d\",&Link_node[address].data,&Link_node[address].next);\n    }\n    int addre_start[2],addre_end;\n    addre_start[0] = addre;\n    int cou_n = 0;//统计有效的结点个数\n    while(addre != -1){\n        cou_n++;\n        addre = Link_node[addre].next;\n    }\n    int flag = 1;//标记第一次反转后的第一个结点(即为整个单链表的第一个结点)\n    for (int i = 0; i < cou_n / k; i++){//需要进行n / k次的反转\n        if(flag){//第一组k个结点特殊处理\n            addre_end = addre_start[0];\n            Reverse_K(Link_node,addre_start[0],k);\n            addre = addre_start[0];\n            flag = 0;\n        }\n        else{\n            addre_start[0] = Link_node[addre_end].next;\n            addre_start[1] = addre_start[0];//暂存当前待处理k个结点的第一个结点，反转后其将变为最后一个结点\n            Reverse_K(Link_node,addre_start[0],k);\n            Link_node[addre_end].next = addre_start[0];\n            addre_end = addre_start[1];\n        }\n    }\n    while(addre != -1){//注意输出格式控制\n        if(Link_node[addre].next != -1){\n            printf(\"%05d %d %05d\\n\",addre,Link_node[addre].data,Link_node[addre].next);\n        }\n        else{\n            printf(\"%05d %d %d\\n\",addre,Link_node[addre].data,Link_node[addre].next);\n        }\n        addre = Link_node[addre].next;\n    }\n    return 0;\n}\n//头插法实现链表反转，通过C++的引用&来返回值，addre_start传入为\n//当前待处理的一组k个结点中的第一个结点，返回为反转后的第一个结点\nvoid Reverse_K(struct node Link_node[],int &addre_start,int k)//注意是Link_node[]，而非Link_node\n{\n    int addre_s = addre_start;//暂存反转前的第一个结点地址\n    int p = Link_node[addre_start].next;//p指向下一个结点，防止断链\n    int q;//q指向当前待处理结点\n    for(int i = 1;i < k; i++){//k个结点要进行k-1次链的反指向\n        q = p;\n        p = Link_node[p].next;//p指向下一个结点，防止断链\n        Link_node[q].next = addre_start;//反转\n        addre_start = q;//当前的第一个结点的地址\n    }\n    Link_node[addre_s].next = p;//反转后第一个结点变成最后一个结点，让其指向下一组待反转的首结点\n}\n```\n>题目来源：PAT乙级1025\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/patb1025.md","raw":"---\ntitle: PAT乙级1025 || 反转链表（详解，C/C++示例，测试点分析）\ndate: 2019-08-23 12:01:56\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **反转链表**\n## **题目描述**\n给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。\n## **输入格式**\n每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 *N* (≤$10^5$)、以及正整数 *K* (≤*N*)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。\n\n接下来有 *N* 行，每行格式为：\n\n```null\nAddress Data Next\n```\n\n其中 `Address` 是结点地址，`Data` 是该结点保存的整数数据，`Next` 是下一结点的地址。\n\n## **输出格式**\n对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。\n## **输入样例**\n```null\n00100 6 4\n00000 4 99999\n00100 1 12309\n68237 6 -1\n33218 3 00000\n99999 5 68237\n12309 2 33218\n```\n## **输出样例**\n```null\n00000 4 33218\n33218 3 12309\n12309 2 00100\n00100 1 99999\n99999 5 68237\n68237 6 -1\n```\n\n## 问题解决\n### 解题思想\n本题要处理的细节较多。首先，单链表可采用静态链表的存储结构（当然也可以选择用指针的链式结构），定义一个结构体数组，下标为当前结点地址，两个成员分别是结点数据和下一个结点的地址；然后，需要统计输入的有效结点个数cou_n，cou_n / k即为需要反转的组数（也为调用反转函数的次数）；\n以下几点容易忽略：\n* 统计输入的有效结点个数。若用n / k来表示需要反转的次数，则导致PATOJ的最后一个测试点不通过。\n* 输出格式的控制。除了最后的-1外，其它地址都是5位非负整数，不足5位的左侧要补0。\n* 反转时第一组结点需要特殊处理。第一组结点反转后的第一个结点即为整个链表的第一个结点，需要记录下来，以便输出。\n* 头插法反转防断链处理。采用头插法反转链表，需要设置一个指针指向待处理结点的下一个结点，否则会因断链而无法到达下一个结点。\n\n### 知识拓展\n我们知道在C语言中，要想通过函数来改变变量的值，只通过值传递参数的形式是不能实现的，我们要通过地址传递的方式，比如数组，指针。而在C++中，我们有更为简便的方式——引用，引用相当于给对象取一个别名，通过该别名，我们可以对该对象进行相关操作，并可对主调函数的相应实参进行修改，使用时，在形参名前面加一个&符号即可(例如本题的函数形参中的addre_start，它与实参addre_start[0]对应，改变addre_start的值相应的addre_start[0]的值也会改变)。关于引用的更多讲解，大家可暂时查看C++相关书籍等。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#define MAXN 100000\nusing namespace std;\nvoid Reverse_K(struct node Link_node[],int &addre_start,int k);\n//单链表结点\nstruct node\n{\n    int data;//结点数据\n    int next;//下一个结点地址\n}Link_node[MAXN];//下标为当前结点地址\nint main()\n{\n    int addre,n,k;//addre为第 1 个结点的地址\n    scanf(\"%d%d%d\",&addre,&n,&k);//第一行输入\n    int address;//暂存输入的地址\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\",&address);//当前结点地址\n        //当前结点数据及下一个结点地址\n        scanf(\"%d%d\",&Link_node[address].data,&Link_node[address].next);\n    }\n    int addre_start[2],addre_end;\n    addre_start[0] = addre;\n    int cou_n = 0;//统计有效的结点个数\n    while(addre != -1){\n        cou_n++;\n        addre = Link_node[addre].next;\n    }\n    int flag = 1;//标记第一次反转后的第一个结点(即为整个单链表的第一个结点)\n    for (int i = 0; i < cou_n / k; i++){//需要进行n / k次的反转\n        if(flag){//第一组k个结点特殊处理\n            addre_end = addre_start[0];\n            Reverse_K(Link_node,addre_start[0],k);\n            addre = addre_start[0];\n            flag = 0;\n        }\n        else{\n            addre_start[0] = Link_node[addre_end].next;\n            addre_start[1] = addre_start[0];//暂存当前待处理k个结点的第一个结点，反转后其将变为最后一个结点\n            Reverse_K(Link_node,addre_start[0],k);\n            Link_node[addre_end].next = addre_start[0];\n            addre_end = addre_start[1];\n        }\n    }\n    while(addre != -1){//注意输出格式控制\n        if(Link_node[addre].next != -1){\n            printf(\"%05d %d %05d\\n\",addre,Link_node[addre].data,Link_node[addre].next);\n        }\n        else{\n            printf(\"%05d %d %d\\n\",addre,Link_node[addre].data,Link_node[addre].next);\n        }\n        addre = Link_node[addre].next;\n    }\n    return 0;\n}\n//头插法实现链表反转，通过C++的引用&来返回值，addre_start传入为\n//当前待处理的一组k个结点中的第一个结点，返回为反转后的第一个结点\nvoid Reverse_K(struct node Link_node[],int &addre_start,int k)//注意是Link_node[]，而非Link_node\n{\n    int addre_s = addre_start;//暂存反转前的第一个结点地址\n    int p = Link_node[addre_start].next;//p指向下一个结点，防止断链\n    int q;//q指向当前待处理结点\n    for(int i = 1;i < k; i++){//k个结点要进行k-1次链的反指向\n        q = p;\n        p = Link_node[p].next;//p指向下一个结点，防止断链\n        Link_node[q].next = addre_start;//反转\n        addre_start = q;//当前的第一个结点的地址\n    }\n    Link_node[addre_s].next = p;//反转后第一个结点变成最后一个结点，让其指向下一组待反转的首结点\n}\n```\n>题目来源：PAT乙级1025\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"patb1025","published":1,"updated":"2019-08-23T04:38:56.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfed001cfk0r57aicjc7","content":"<h1 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a><strong>反转链表</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 <em>N</em> (≤$10^5$)、以及正整数 <em>K</em> (≤<em>N</em>)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>\n<p>接下来有 <em>N</em> 行，每行格式为：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Address Data Next</span><br></pre></td></tr></table></figure></div>\n<p>其中 <code>Address</code> 是结点地址，<code>Data</code> 是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00100 6 4</span><br><span class=\"line\">00000 4 99999</span><br><span class=\"line\">00100 1 12309</span><br><span class=\"line\">68237 6 -1</span><br><span class=\"line\">33218 3 00000</span><br><span class=\"line\">99999 5 68237</span><br><span class=\"line\">12309 2 33218</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000 4 33218</span><br><span class=\"line\">33218 3 12309</span><br><span class=\"line\">12309 2 00100</span><br><span class=\"line\">00100 1 99999</span><br><span class=\"line\">99999 5 68237</span><br><span class=\"line\">68237 6 -1</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题要处理的细节较多。首先，单链表可采用静态链表的存储结构（当然也可以选择用指针的链式结构），定义一个结构体数组，下标为当前结点地址，两个成员分别是结点数据和下一个结点的地址；然后，需要统计输入的有效结点个数cou_n，cou_n / k即为需要反转的组数（也为调用反转函数的次数）；<br>以下几点容易忽略：</p>\n<ul>\n<li>统计输入的有效结点个数。若用n / k来表示需要反转的次数，则导致PATOJ的最后一个测试点不通过。</li>\n<li>输出格式的控制。除了最后的-1外，其它地址都是5位非负整数，不足5位的左侧要补0。</li>\n<li>反转时第一组结点需要特殊处理。第一组结点反转后的第一个结点即为整个链表的第一个结点，需要记录下来，以便输出。</li>\n<li>头插法反转防断链处理。采用头插法反转链表，需要设置一个指针指向待处理结点的下一个结点，否则会因断链而无法到达下一个结点。</li>\n</ul>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>我们知道在C语言中，要想通过函数来改变变量的值，只通过值传递参数的形式是不能实现的，我们要通过地址传递的方式，比如数组，指针。而在C++中，我们有更为简便的方式——引用，引用相当于给对象取一个别名，通过该别名，我们可以对该对象进行相关操作，并可对主调函数的相应实参进行修改，使用时，在形参名前面加一个&amp;符号即可(例如本题的函数形参中的addre_start，它与实参addre_start[0]对应，改变addre_start的值相应的addre_start[0]的值也会改变)。关于引用的更多讲解，大家可暂时查看C++相关书籍等。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100000</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_K</span><span class=\"params\">(struct node Link_node[],<span class=\"keyword\">int</span> &amp;addre_start,<span class=\"keyword\">int</span> k)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//单链表结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;<span class=\"comment\">//结点数据</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> next;<span class=\"comment\">//下一个结点地址</span></span><br><span class=\"line\">&#125;Link_node[MAXN];<span class=\"comment\">//下标为当前结点地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> addre,n,k;<span class=\"comment\">//addre为第 1 个结点的地址</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;addre,&amp;n,&amp;k);<span class=\"comment\">//第一行输入</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> address;<span class=\"comment\">//暂存输入的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;address);<span class=\"comment\">//当前结点地址</span></span><br><span class=\"line\">        <span class=\"comment\">//当前结点数据及下一个结点地址</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;Link_node[address].data,&amp;Link_node[address].next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> addre_start[<span class=\"number\">2</span>],addre_end;</span><br><span class=\"line\">    addre_start[<span class=\"number\">0</span>] = addre;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cou_n = <span class=\"number\">0</span>;<span class=\"comment\">//统计有效的结点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(addre != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        cou_n++;</span><br><span class=\"line\">        addre = Link_node[addre].next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;<span class=\"comment\">//标记第一次反转后的第一个结点(即为整个单链表的第一个结点)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cou_n / k; i++)&#123;<span class=\"comment\">//需要进行n / k次的反转</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)&#123;<span class=\"comment\">//第一组k个结点特殊处理</span></span><br><span class=\"line\">            addre_end = addre_start[<span class=\"number\">0</span>];</span><br><span class=\"line\">            Reverse_K(Link_node,addre_start[<span class=\"number\">0</span>],k);</span><br><span class=\"line\">            addre = addre_start[<span class=\"number\">0</span>];</span><br><span class=\"line\">            flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            addre_start[<span class=\"number\">0</span>] = Link_node[addre_end].next;</span><br><span class=\"line\">            addre_start[<span class=\"number\">1</span>] = addre_start[<span class=\"number\">0</span>];<span class=\"comment\">//暂存当前待处理k个结点的第一个结点，反转后其将变为最后一个结点</span></span><br><span class=\"line\">            Reverse_K(Link_node,addre_start[<span class=\"number\">0</span>],k);</span><br><span class=\"line\">            Link_node[addre_end].next = addre_start[<span class=\"number\">0</span>];</span><br><span class=\"line\">            addre_end = addre_start[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(addre != <span class=\"number\">-1</span>)&#123;<span class=\"comment\">//注意输出格式控制</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Link_node[addre].next != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%05d %d %05d\\n\"</span>,addre,Link_node[addre].data,Link_node[addre].next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%05d %d %d\\n\"</span>,addre,Link_node[addre].data,Link_node[addre].next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addre = Link_node[addre].next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//头插法实现链表反转，通过C++的引用&amp;来返回值，addre_start传入为</span></span><br><span class=\"line\"><span class=\"comment\">//当前待处理的一组k个结点中的第一个结点，返回为反转后的第一个结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_K</span><span class=\"params\">(struct node Link_node[],<span class=\"keyword\">int</span> &amp;addre_start,<span class=\"keyword\">int</span> k)</span><span class=\"comment\">//注意是Link_node[]，而非Link_node</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> addre_s = addre_start;<span class=\"comment\">//暂存反转前的第一个结点地址</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = Link_node[addre_start].next;<span class=\"comment\">//p指向下一个结点，防止断链</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> q;<span class=\"comment\">//q指向当前待处理结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; k; i++)&#123;<span class=\"comment\">//k个结点要进行k-1次链的反指向</span></span><br><span class=\"line\">        q = p;</span><br><span class=\"line\">        p = Link_node[p].next;<span class=\"comment\">//p指向下一个结点，防止断链</span></span><br><span class=\"line\">        Link_node[q].next = addre_start;<span class=\"comment\">//反转</span></span><br><span class=\"line\">        addre_start = q;<span class=\"comment\">//当前的第一个结点的地址</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Link_node[addre_s].next = p;<span class=\"comment\">//反转后第一个结点变成最后一个结点，让其指向下一组待反转的首结点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1025<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a><strong>反转链表</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 <em>N</em> (≤$10^5$)、以及正整数 <em>K</em> (≤<em>N</em>)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>\n<p>接下来有 <em>N</em> 行，每行格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Address Data Next</span><br></pre></td></tr></table></figure>\n<p>其中 <code>Address</code> 是结点地址，<code>Data</code> 是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00100 6 4</span><br><span class=\"line\">00000 4 99999</span><br><span class=\"line\">00100 1 12309</span><br><span class=\"line\">68237 6 -1</span><br><span class=\"line\">33218 3 00000</span><br><span class=\"line\">99999 5 68237</span><br><span class=\"line\">12309 2 33218</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000 4 33218</span><br><span class=\"line\">33218 3 12309</span><br><span class=\"line\">12309 2 00100</span><br><span class=\"line\">00100 1 99999</span><br><span class=\"line\">99999 5 68237</span><br><span class=\"line\">68237 6 -1</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题要处理的细节较多。首先，单链表可采用静态链表的存储结构（当然也可以选择用指针的链式结构），定义一个结构体数组，下标为当前结点地址，两个成员分别是结点数据和下一个结点的地址；然后，需要统计输入的有效结点个数cou_n，cou_n / k即为需要反转的组数（也为调用反转函数的次数）；<br>以下几点容易忽略：</p>\n<ul>\n<li>统计输入的有效结点个数。若用n / k来表示需要反转的次数，则导致PATOJ的最后一个测试点不通过。</li>\n<li>输出格式的控制。除了最后的-1外，其它地址都是5位非负整数，不足5位的左侧要补0。</li>\n<li>反转时第一组结点需要特殊处理。第一组结点反转后的第一个结点即为整个链表的第一个结点，需要记录下来，以便输出。</li>\n<li>头插法反转防断链处理。采用头插法反转链表，需要设置一个指针指向待处理结点的下一个结点，否则会因断链而无法到达下一个结点。</li>\n</ul>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>我们知道在C语言中，要想通过函数来改变变量的值，只通过值传递参数的形式是不能实现的，我们要通过地址传递的方式，比如数组，指针。而在C++中，我们有更为简便的方式——引用，引用相当于给对象取一个别名，通过该别名，我们可以对该对象进行相关操作，并可对主调函数的相应实参进行修改，使用时，在形参名前面加一个&amp;符号即可(例如本题的函数形参中的addre_start，它与实参addre_start[0]对应，改变addre_start的值相应的addre_start[0]的值也会改变)。关于引用的更多讲解，大家可暂时查看C++相关书籍等。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100000</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_K</span><span class=\"params\">(struct node Link_node[],<span class=\"keyword\">int</span> &amp;addre_start,<span class=\"keyword\">int</span> k)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//单链表结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;<span class=\"comment\">//结点数据</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> next;<span class=\"comment\">//下一个结点地址</span></span><br><span class=\"line\">&#125;Link_node[MAXN];<span class=\"comment\">//下标为当前结点地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> addre,n,k;<span class=\"comment\">//addre为第 1 个结点的地址</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;addre,&amp;n,&amp;k);<span class=\"comment\">//第一行输入</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> address;<span class=\"comment\">//暂存输入的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;address);<span class=\"comment\">//当前结点地址</span></span><br><span class=\"line\">        <span class=\"comment\">//当前结点数据及下一个结点地址</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;Link_node[address].data,&amp;Link_node[address].next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> addre_start[<span class=\"number\">2</span>],addre_end;</span><br><span class=\"line\">    addre_start[<span class=\"number\">0</span>] = addre;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cou_n = <span class=\"number\">0</span>;<span class=\"comment\">//统计有效的结点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(addre != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        cou_n++;</span><br><span class=\"line\">        addre = Link_node[addre].next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;<span class=\"comment\">//标记第一次反转后的第一个结点(即为整个单链表的第一个结点)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cou_n / k; i++)&#123;<span class=\"comment\">//需要进行n / k次的反转</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)&#123;<span class=\"comment\">//第一组k个结点特殊处理</span></span><br><span class=\"line\">            addre_end = addre_start[<span class=\"number\">0</span>];</span><br><span class=\"line\">            Reverse_K(Link_node,addre_start[<span class=\"number\">0</span>],k);</span><br><span class=\"line\">            addre = addre_start[<span class=\"number\">0</span>];</span><br><span class=\"line\">            flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            addre_start[<span class=\"number\">0</span>] = Link_node[addre_end].next;</span><br><span class=\"line\">            addre_start[<span class=\"number\">1</span>] = addre_start[<span class=\"number\">0</span>];<span class=\"comment\">//暂存当前待处理k个结点的第一个结点，反转后其将变为最后一个结点</span></span><br><span class=\"line\">            Reverse_K(Link_node,addre_start[<span class=\"number\">0</span>],k);</span><br><span class=\"line\">            Link_node[addre_end].next = addre_start[<span class=\"number\">0</span>];</span><br><span class=\"line\">            addre_end = addre_start[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(addre != <span class=\"number\">-1</span>)&#123;<span class=\"comment\">//注意输出格式控制</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Link_node[addre].next != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%05d %d %05d\\n\"</span>,addre,Link_node[addre].data,Link_node[addre].next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%05d %d %d\\n\"</span>,addre,Link_node[addre].data,Link_node[addre].next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addre = Link_node[addre].next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//头插法实现链表反转，通过C++的引用&amp;来返回值，addre_start传入为</span></span><br><span class=\"line\"><span class=\"comment\">//当前待处理的一组k个结点中的第一个结点，返回为反转后的第一个结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_K</span><span class=\"params\">(struct node Link_node[],<span class=\"keyword\">int</span> &amp;addre_start,<span class=\"keyword\">int</span> k)</span><span class=\"comment\">//注意是Link_node[]，而非Link_node</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> addre_s = addre_start;<span class=\"comment\">//暂存反转前的第一个结点地址</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = Link_node[addre_start].next;<span class=\"comment\">//p指向下一个结点，防止断链</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> q;<span class=\"comment\">//q指向当前待处理结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; k; i++)&#123;<span class=\"comment\">//k个结点要进行k-1次链的反指向</span></span><br><span class=\"line\">        q = p;</span><br><span class=\"line\">        p = Link_node[p].next;<span class=\"comment\">//p指向下一个结点，防止断链</span></span><br><span class=\"line\">        Link_node[q].next = addre_start;<span class=\"comment\">//反转</span></span><br><span class=\"line\">        addre_start = q;<span class=\"comment\">//当前的第一个结点的地址</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Link_node[addre_s].next = p;<span class=\"comment\">//反转后第一个结点变成最后一个结点，让其指向下一组待反转的首结点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1025<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1024 || 科学计数法（详解，C/C++示例，测试点分析）","date":"2019-08-23T04:01:50.000Z","_content":"\n# **科学计数法**\n## **题目描述**\n科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式` [+-] [1-9].[0-9]+E[+-][0-9]+`，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。\n现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。\n\n## **输入格式**\n每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 *A*。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。\n## **输出格式**\n对每个测试用例，在一行中按普通数字表示法输出 *A*，并保证所有有效位都被保留，包括末尾的 0。\n## **输入样例1**\n```null\n+1.23400E-03\n```\n## **输出样例1**\n```null\n0.00123400\n```\n## **输入样例2**\n```null\n-1.2E+10\n```\n## **输出样例2**\n```null\n-12000000000\n```\n\n## 问题解决\n### 解题思想\n本题主要是根据输入来控制相应的输出，一些细节较多，容易犯低级错误。设置字符数组以接收输入的科学计数法格式的数字，输入的同时需要计算出指数的数值大小以备后面直接使用；之后，首先检查数字的符号，`+`不输出，`-`需要输出；接着，按指数的符号分以下两种情况处理：\n\n##### 指数符号为`-`\n\n若指数数值为0，则直接输出数字的有效数值部分即可（即`E`之前的数值部分）；否则，小数点需要向左进行相应的移动（小数点在第一位0之后），并补上相应个数的0（在小数点与原有效数值的第一位之间）。\n\n##### 指数符号为`+`\n\n若指数数值为0，则直接输出数字的有效数值部分即可（即`E`之前的数值部分）；否则，小数点需要向右进行相应的移动，若小数点未移动出有效数值部分，则在相应位置需要输出小数点，若小数点移动出了有效数值部分，则不需要输出小数点，并在右侧补上相应个数的0。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#define MAX 9999\nusing namespace std;\nint main()\n{\n    char sci_a[MAX];\n    int ind = 0,flag = 0,loc;//存指数数值（指数的绝对值不超过9999）\n                            //flag用以标记上一个输入字符是否为指数的符号\n                            //loc记录指数的符号\n    for(int i = 0;(sci_a[i] = getchar()) != '\\n'; i++){\n        if((sci_a[i - 1] == '+'||sci_a[i - 1] == '-')&&(i - 1) != 0){\n            flag = 1;//上一个输入字符为指数的符号则标记变为1\n            loc = sci_a[i - 1];//记录指数的符号\n        }\n        if(flag){//计算指数的数值\n            ind =ind * 10 + sci_a[i] - '0';\n        }\n    }\n    if(sci_a[0] == '-'){\n        printf(\"%c\",sci_a[0]);\n    }//数字的符号为-时需要输出，为+时不需输出\n    int i = 1;\n    if(loc == '-'){\n        int mar1 = 1;//标记指数是否为0，若是则直接输出E之前有效数字部分即可否则小数点需要向前移动\n        if(ind != 0){\n            mar1 = 0;\n            printf(\"0.\");\n            for(int j = 1; j < ind; j++){\n                printf(\"0\");\n            }\n        }\n        while(sci_a[i] != 'E'){\n            if(sci_a[i] != '.'||mar1){\n                printf(\"%c\",sci_a[i]);//注意：此处不要误写成%d\n            }\n            i++;\n        }\n    }\n    else{//指数的符号为+\n        int mar2 = 1;//标记小数点是否输出\n        printf(\"%c\",sci_a[i]);\n        i += 2;//移过数字的第一位和小数点\n        while(sci_a[i] != 'E'){\n            if(ind){\n                printf(\"%c\",sci_a[i]);\n                ind--;\n            }\n            else{\n                if(mar2){\n                    printf(\".\");\n                    mar2 = 0;\n                }\n                printf(\"%c\",sci_a[i]);\n            }\n            i++;//注意不要忽略\n        }\n        while(ind--){//有效数字全部输出后，右侧补0\n            printf(\"0\");\n        }\n    }\n    return 0;\n}\n```\n>题目来源：PAT乙级1024\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/patb1024.md","raw":"---\ntitle: PAT乙级1024 || 科学计数法（详解，C/C++示例，测试点分析）\ndate: 2019-08-23 12:01:50\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **科学计数法**\n## **题目描述**\n科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式` [+-] [1-9].[0-9]+E[+-][0-9]+`，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。\n现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。\n\n## **输入格式**\n每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 *A*。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。\n## **输出格式**\n对每个测试用例，在一行中按普通数字表示法输出 *A*，并保证所有有效位都被保留，包括末尾的 0。\n## **输入样例1**\n```null\n+1.23400E-03\n```\n## **输出样例1**\n```null\n0.00123400\n```\n## **输入样例2**\n```null\n-1.2E+10\n```\n## **输出样例2**\n```null\n-12000000000\n```\n\n## 问题解决\n### 解题思想\n本题主要是根据输入来控制相应的输出，一些细节较多，容易犯低级错误。设置字符数组以接收输入的科学计数法格式的数字，输入的同时需要计算出指数的数值大小以备后面直接使用；之后，首先检查数字的符号，`+`不输出，`-`需要输出；接着，按指数的符号分以下两种情况处理：\n\n##### 指数符号为`-`\n\n若指数数值为0，则直接输出数字的有效数值部分即可（即`E`之前的数值部分）；否则，小数点需要向左进行相应的移动（小数点在第一位0之后），并补上相应个数的0（在小数点与原有效数值的第一位之间）。\n\n##### 指数符号为`+`\n\n若指数数值为0，则直接输出数字的有效数值部分即可（即`E`之前的数值部分）；否则，小数点需要向右进行相应的移动，若小数点未移动出有效数值部分，则在相应位置需要输出小数点，若小数点移动出了有效数值部分，则不需要输出小数点，并在右侧补上相应个数的0。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#define MAX 9999\nusing namespace std;\nint main()\n{\n    char sci_a[MAX];\n    int ind = 0,flag = 0,loc;//存指数数值（指数的绝对值不超过9999）\n                            //flag用以标记上一个输入字符是否为指数的符号\n                            //loc记录指数的符号\n    for(int i = 0;(sci_a[i] = getchar()) != '\\n'; i++){\n        if((sci_a[i - 1] == '+'||sci_a[i - 1] == '-')&&(i - 1) != 0){\n            flag = 1;//上一个输入字符为指数的符号则标记变为1\n            loc = sci_a[i - 1];//记录指数的符号\n        }\n        if(flag){//计算指数的数值\n            ind =ind * 10 + sci_a[i] - '0';\n        }\n    }\n    if(sci_a[0] == '-'){\n        printf(\"%c\",sci_a[0]);\n    }//数字的符号为-时需要输出，为+时不需输出\n    int i = 1;\n    if(loc == '-'){\n        int mar1 = 1;//标记指数是否为0，若是则直接输出E之前有效数字部分即可否则小数点需要向前移动\n        if(ind != 0){\n            mar1 = 0;\n            printf(\"0.\");\n            for(int j = 1; j < ind; j++){\n                printf(\"0\");\n            }\n        }\n        while(sci_a[i] != 'E'){\n            if(sci_a[i] != '.'||mar1){\n                printf(\"%c\",sci_a[i]);//注意：此处不要误写成%d\n            }\n            i++;\n        }\n    }\n    else{//指数的符号为+\n        int mar2 = 1;//标记小数点是否输出\n        printf(\"%c\",sci_a[i]);\n        i += 2;//移过数字的第一位和小数点\n        while(sci_a[i] != 'E'){\n            if(ind){\n                printf(\"%c\",sci_a[i]);\n                ind--;\n            }\n            else{\n                if(mar2){\n                    printf(\".\");\n                    mar2 = 0;\n                }\n                printf(\"%c\",sci_a[i]);\n            }\n            i++;//注意不要忽略\n        }\n        while(ind--){//有效数字全部输出后，右侧补0\n            printf(\"0\");\n        }\n    }\n    return 0;\n}\n```\n>题目来源：PAT乙级1024\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"patb1024","published":1,"updated":"2019-08-23T04:31:12.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfef001efk0rsir04j15","content":"<h1 id=\"科学计数法\"><a href=\"#科学计数法\" class=\"headerlink\" title=\"科学计数法\"></a><strong>科学计数法</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式<code>[+-] [1-9].[0-9]+E[+-][0-9]+</code>，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。<br>现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 <em>A</em>。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每个测试用例，在一行中按普通数字表示法输出 <em>A</em>，并保证所有有效位都被保留，包括末尾的 0。</p>\n<h2 id=\"输入样例1\"><a href=\"#输入样例1\" class=\"headerlink\" title=\"输入样例1\"></a><strong>输入样例1</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+1.23400E-03</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例1\"><a href=\"#输出样例1\" class=\"headerlink\" title=\"输出样例1\"></a><strong>输出样例1</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0.00123400</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输入样例2\"><a href=\"#输入样例2\" class=\"headerlink\" title=\"输入样例2\"></a><strong>输入样例2</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-1.2E+10</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例2\"><a href=\"#输出样例2\" class=\"headerlink\" title=\"输出样例2\"></a><strong>输出样例2</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-12000000000</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题主要是根据输入来控制相应的输出，一些细节较多，容易犯低级错误。设置字符数组以接收输入的科学计数法格式的数字，输入的同时需要计算出指数的数值大小以备后面直接使用；之后，首先检查数字的符号，<code>+</code>不输出，<code>-</code>需要输出；接着，按指数的符号分以下两种情况处理：</p>\n<h5 id=\"指数符号为\"><a href=\"#指数符号为\" class=\"headerlink\" title=\"指数符号为-\"></a>指数符号为<code>-</code></h5><p>若指数数值为0，则直接输出数字的有效数值部分即可（即<code>E</code>之前的数值部分）；否则，小数点需要向左进行相应的移动（小数点在第一位0之后），并补上相应个数的0（在小数点与原有效数值的第一位之间）。</p>\n<h5 id=\"指数符号为-1\"><a href=\"#指数符号为-1\" class=\"headerlink\" title=\"指数符号为+\"></a>指数符号为<code>+</code></h5><p>若指数数值为0，则直接输出数字的有效数值部分即可（即<code>E</code>之前的数值部分）；否则，小数点需要向右进行相应的移动，若小数点未移动出有效数值部分，则在相应位置需要输出小数点，若小数点移动出了有效数值部分，则不需要输出小数点，并在右侧补上相应个数的0。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 9999</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> sci_a[MAX];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ind = <span class=\"number\">0</span>,flag = <span class=\"number\">0</span>,loc;<span class=\"comment\">//存指数数值（指数的绝对值不超过9999）</span></span><br><span class=\"line\">                            <span class=\"comment\">//flag用以标记上一个输入字符是否为指数的符号</span></span><br><span class=\"line\">                            <span class=\"comment\">//loc记录指数的符号</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;(sci_a[i] = getchar()) != <span class=\"string\">'\\n'</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((sci_a[i - <span class=\"number\">1</span>] == <span class=\"string\">'+'</span>||sci_a[i - <span class=\"number\">1</span>] == <span class=\"string\">'-'</span>)&amp;&amp;(i - <span class=\"number\">1</span>) != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;<span class=\"comment\">//上一个输入字符为指数的符号则标记变为1</span></span><br><span class=\"line\">            loc = sci_a[i - <span class=\"number\">1</span>];<span class=\"comment\">//记录指数的符号</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)&#123;<span class=\"comment\">//计算指数的数值</span></span><br><span class=\"line\">            ind =ind * <span class=\"number\">10</span> + sci_a[i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sci_a[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,sci_a[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;<span class=\"comment\">//数字的符号为-时需要输出，为+时不需输出</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(loc == <span class=\"string\">'-'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mar1 = <span class=\"number\">1</span>;<span class=\"comment\">//标记指数是否为0，若是则直接输出E之前有效数字部分即可否则小数点需要向前移动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ind != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            mar1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"0.\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; ind; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sci_a[i] != <span class=\"string\">'E'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sci_a[i] != <span class=\"string\">'.'</span>||mar1)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,sci_a[i]);<span class=\"comment\">//注意：此处不要误写成%d</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//指数的符号为+</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mar2 = <span class=\"number\">1</span>;<span class=\"comment\">//标记小数点是否输出</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,sci_a[i]);</span><br><span class=\"line\">        i += <span class=\"number\">2</span>;<span class=\"comment\">//移过数字的第一位和小数点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sci_a[i] != <span class=\"string\">'E'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ind)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,sci_a[i]);</span><br><span class=\"line\">                ind--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mar2)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">                    mar2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,sci_a[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;<span class=\"comment\">//注意不要忽略</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ind--)&#123;<span class=\"comment\">//有效数字全部输出后，右侧补0</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1024<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"科学计数法\"><a href=\"#科学计数法\" class=\"headerlink\" title=\"科学计数法\"></a><strong>科学计数法</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式<code>[+-] [1-9].[0-9]+E[+-][0-9]+</code>，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。<br>现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 <em>A</em>。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每个测试用例，在一行中按普通数字表示法输出 <em>A</em>，并保证所有有效位都被保留，包括末尾的 0。</p>\n<h2 id=\"输入样例1\"><a href=\"#输入样例1\" class=\"headerlink\" title=\"输入样例1\"></a><strong>输入样例1</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+1.23400E-03</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例1\"><a href=\"#输出样例1\" class=\"headerlink\" title=\"输出样例1\"></a><strong>输出样例1</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0.00123400</span><br></pre></td></tr></table></figure>\n<h2 id=\"输入样例2\"><a href=\"#输入样例2\" class=\"headerlink\" title=\"输入样例2\"></a><strong>输入样例2</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-1.2E+10</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例2\"><a href=\"#输出样例2\" class=\"headerlink\" title=\"输出样例2\"></a><strong>输出样例2</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-12000000000</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题主要是根据输入来控制相应的输出，一些细节较多，容易犯低级错误。设置字符数组以接收输入的科学计数法格式的数字，输入的同时需要计算出指数的数值大小以备后面直接使用；之后，首先检查数字的符号，<code>+</code>不输出，<code>-</code>需要输出；接着，按指数的符号分以下两种情况处理：</p>\n<h5 id=\"指数符号为\"><a href=\"#指数符号为\" class=\"headerlink\" title=\"指数符号为-\"></a>指数符号为<code>-</code></h5><p>若指数数值为0，则直接输出数字的有效数值部分即可（即<code>E</code>之前的数值部分）；否则，小数点需要向左进行相应的移动（小数点在第一位0之后），并补上相应个数的0（在小数点与原有效数值的第一位之间）。</p>\n<h5 id=\"指数符号为-1\"><a href=\"#指数符号为-1\" class=\"headerlink\" title=\"指数符号为+\"></a>指数符号为<code>+</code></h5><p>若指数数值为0，则直接输出数字的有效数值部分即可（即<code>E</code>之前的数值部分）；否则，小数点需要向右进行相应的移动，若小数点未移动出有效数值部分，则在相应位置需要输出小数点，若小数点移动出了有效数值部分，则不需要输出小数点，并在右侧补上相应个数的0。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 9999</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> sci_a[MAX];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ind = <span class=\"number\">0</span>,flag = <span class=\"number\">0</span>,loc;<span class=\"comment\">//存指数数值（指数的绝对值不超过9999）</span></span><br><span class=\"line\">                            <span class=\"comment\">//flag用以标记上一个输入字符是否为指数的符号</span></span><br><span class=\"line\">                            <span class=\"comment\">//loc记录指数的符号</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;(sci_a[i] = getchar()) != <span class=\"string\">'\\n'</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((sci_a[i - <span class=\"number\">1</span>] == <span class=\"string\">'+'</span>||sci_a[i - <span class=\"number\">1</span>] == <span class=\"string\">'-'</span>)&amp;&amp;(i - <span class=\"number\">1</span>) != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;<span class=\"comment\">//上一个输入字符为指数的符号则标记变为1</span></span><br><span class=\"line\">            loc = sci_a[i - <span class=\"number\">1</span>];<span class=\"comment\">//记录指数的符号</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)&#123;<span class=\"comment\">//计算指数的数值</span></span><br><span class=\"line\">            ind =ind * <span class=\"number\">10</span> + sci_a[i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sci_a[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,sci_a[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;<span class=\"comment\">//数字的符号为-时需要输出，为+时不需输出</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(loc == <span class=\"string\">'-'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mar1 = <span class=\"number\">1</span>;<span class=\"comment\">//标记指数是否为0，若是则直接输出E之前有效数字部分即可否则小数点需要向前移动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ind != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            mar1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"0.\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; ind; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sci_a[i] != <span class=\"string\">'E'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sci_a[i] != <span class=\"string\">'.'</span>||mar1)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,sci_a[i]);<span class=\"comment\">//注意：此处不要误写成%d</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//指数的符号为+</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mar2 = <span class=\"number\">1</span>;<span class=\"comment\">//标记小数点是否输出</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,sci_a[i]);</span><br><span class=\"line\">        i += <span class=\"number\">2</span>;<span class=\"comment\">//移过数字的第一位和小数点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sci_a[i] != <span class=\"string\">'E'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ind)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,sci_a[i]);</span><br><span class=\"line\">                ind--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mar2)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">                    mar2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,sci_a[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;<span class=\"comment\">//注意不要忽略</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ind--)&#123;<span class=\"comment\">//有效数字全部输出后，右侧补0</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1024<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1026 || 程序运行时间（详解，C/C++示例，测试点分析）","date":"2019-08-27T03:49:16.000Z","mathjax":true,"_content":"\n# **程序运行时间**\n## **题目描述**\n要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。\n这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。\n## **输入格式**\n输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 < C2，并且取值在 [0,$10^7$]。\n## **输出格式**\n在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。\n## **输入样例**\n```null\n123 4577973\n```\n## **输出样例**\n```null\n12:42:59\n```\n\n## 问题解决\n### 解题思想\n很简单的一道题，大家要学会四舍五入的技巧（比如把实数num四舍五入到整数）：\n```cpp\nint num_int = (int)(num + 0.5);\n```\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\nusing namespace std;\nint main()\n{\n    int c1,c2;\n    scanf(\"%d%d\",&c1,&c2);\n    int time_s = (int)((c2 - c1) * 1.0 / 100 + 0.5);//四舍五入转化为整数秒\n    int h,m,s;\n    h = time_s / 3600;//小时，一小时为3600秒\n    time_s %= 3600;\n    m = time_s / 60;//分钟\n    s = time_s % 60;//秒\n    printf(\"%02d:%02d:%02d\",h,m,s);\n    return 0;\n}\n```\n>题目来源：PAT乙级1026\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/patb1026.md","raw":"---\ntitle: PAT乙级1026 || 程序运行时间（详解，C/C++示例，测试点分析）\ndate: 2019-08-27 11:49:16\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **程序运行时间**\n## **题目描述**\n要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。\n这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。\n## **输入格式**\n输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 < C2，并且取值在 [0,$10^7$]。\n## **输出格式**\n在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。\n## **输入样例**\n```null\n123 4577973\n```\n## **输出样例**\n```null\n12:42:59\n```\n\n## 问题解决\n### 解题思想\n很简单的一道题，大家要学会四舍五入的技巧（比如把实数num四舍五入到整数）：\n```cpp\nint num_int = (int)(num + 0.5);\n```\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\nusing namespace std;\nint main()\n{\n    int c1,c2;\n    scanf(\"%d%d\",&c1,&c2);\n    int time_s = (int)((c2 - c1) * 1.0 / 100 + 0.5);//四舍五入转化为整数秒\n    int h,m,s;\n    h = time_s / 3600;//小时，一小时为3600秒\n    time_s %= 3600;\n    m = time_s / 60;//分钟\n    s = time_s % 60;//秒\n    printf(\"%02d:%02d:%02d\",h,m,s);\n    return 0;\n}\n```\n>题目来源：PAT乙级1026\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"patb1026","published":1,"updated":"2019-08-27T03:57:51.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfej001ifk0rvl542j0w","content":"<h1 id=\"程序运行时间\"><a href=\"#程序运行时间\" class=\"headerlink\" title=\"程序运行时间\"></a><strong>程序运行时间</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。<br>这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,$10^7$]。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">123 4577973</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:42:59</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>很简单的一道题，大家要学会四舍五入的技巧（比如把实数num四舍五入到整数）：<br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> num_int = (<span class=\"keyword\">int</span>)(num + <span class=\"number\">0.5</span>);</span><br></pre></td></tr></table></figure></div></p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c1,c2;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;c1,&amp;c2);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> time_s = (<span class=\"keyword\">int</span>)((c2 - c1) * <span class=\"number\">1.0</span> / <span class=\"number\">100</span> + <span class=\"number\">0.5</span>);<span class=\"comment\">//四舍五入转化为整数秒</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h,m,s;</span><br><span class=\"line\">    h = time_s / <span class=\"number\">3600</span>;<span class=\"comment\">//小时，一小时为3600秒</span></span><br><span class=\"line\">    time_s %= <span class=\"number\">3600</span>;</span><br><span class=\"line\">    m = time_s / <span class=\"number\">60</span>;<span class=\"comment\">//分钟</span></span><br><span class=\"line\">    s = time_s % <span class=\"number\">60</span>;<span class=\"comment\">//秒</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%02d:%02d:%02d\"</span>,h,m,s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1026<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"程序运行时间\"><a href=\"#程序运行时间\" class=\"headerlink\" title=\"程序运行时间\"></a><strong>程序运行时间</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。<br>这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,$10^7$]。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">123 4577973</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:42:59</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>很简单的一道题，大家要学会四舍五入的技巧（比如把实数num四舍五入到整数）：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> num_int = (<span class=\"keyword\">int</span>)(num + <span class=\"number\">0.5</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c1,c2;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;c1,&amp;c2);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> time_s = (<span class=\"keyword\">int</span>)((c2 - c1) * <span class=\"number\">1.0</span> / <span class=\"number\">100</span> + <span class=\"number\">0.5</span>);<span class=\"comment\">//四舍五入转化为整数秒</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h,m,s;</span><br><span class=\"line\">    h = time_s / <span class=\"number\">3600</span>;<span class=\"comment\">//小时，一小时为3600秒</span></span><br><span class=\"line\">    time_s %= <span class=\"number\">3600</span>;</span><br><span class=\"line\">    m = time_s / <span class=\"number\">60</span>;<span class=\"comment\">//分钟</span></span><br><span class=\"line\">    s = time_s % <span class=\"number\">60</span>;<span class=\"comment\">//秒</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%02d:%02d:%02d\"</span>,h,m,s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1026<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1027 || 打印沙漏（详解，C/C++示例，测试点分析）","date":"2019-09-06T04:08:19.000Z","_content":"\n# **打印沙漏**\n## **题目描述**\n本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印\n\n```null\n*****\n ***\n  *\n ***\n*****\n```\n\n所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。\n给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。\n\n## **输入格式**\n输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。\n## **输出格式**\n首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。\n## **输入样例**\n```null\n19 *\n```\n## **输出样例**\n```null\n*****\n ***\n  *\n ***\n*****\n2\n```\n\n## 问题解决\n### 解题思想\n本题为典型的图形输出问题，此类问题处理的核心是：找规律。由题给示例我们可以得到如下规律（滑动以查看完整内容）：\n```\n行数为1时，需1个符号，即：1\n行数为3时，需7个符号，即：1+2X3\n行数为5时，需17个符号，即：1+2X3+2X5\n......\n行数为i时，需要的符号数为：1+2X3+...+2Xi\n```\n由此，很容易得出本题的处理方案，如下：\n设need_num为打印沙漏需要的最多符号个数，level为能打印的沙漏的最大层数，它们都初始化为1，因为N是正整数，因此至少能打印出一层；注意在读入字符前要吸收掉空格；在代码的while()循环中，不断地累加层数level，进而累加需要的符号数need_num，退出循环时要把多累加一次扣除掉；然后，根据规律，先打印沙漏的上半部分及中心层，注意还要控制空格的输出，再打印沙漏的下半部分，核心部分就是找到各部分的相应行打印空格数和符号数与level，i的关系。\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\nusing namespace std;\nint main()\n{\n    int n,c,level = 1;//level为能打印的沙漏的最大层数，初始化为1\n    int need_num = 1;//need_num为打印沙漏需要的符号个数\n    scanf(\"%d\",&n);//输入字符个数\n    getchar();//吸收掉空格\n    c = getchar();//输入字符\n    while(n / need_num){//计算n个符号所能打印的“最大沙漏”（用掉的符号尽可能多，层数最大）\n        level += 2;\n        need_num += 2 * level;\n    }\n    need_num -= 2 * level;//退出循环时最多需要的符号个数多加了一次\n    level -= 2;//退出循环时层数多加了一次（注意与上一行的顺序，不可颠倒）\n    for(int i = level; i >= level / 2 + 1; i--){//先打印沙漏的上半部分及中心部分\n        for(int k = 0; k < level - i; k++){//打印空格\n            printf(\" \");\n        }\n        for(int j = 0; j < 2 * i - level; j++){//打印符号\n            printf(\"%c\",c);\n        }\n        printf(\"\\n\");\n    }\n    for(int i = level / 2; i >= 1; i--){//再打印沙漏的下半部分\n        for(int k = 0; k < i - 1; k++){//打印空格\n            printf(\" \");\n        }\n        for(int j = 0; j < level - 2 * (i - 1); j++){//打印符号\n            printf(\"%c\",c);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"%d\",n - need_num);//输出剩下没用掉的符号数\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1027\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/patb1027.md","raw":"---\ntitle: PAT乙级1027 || 打印沙漏（详解，C/C++示例，测试点分析）\ndate: 2019-09-06 12:08:19\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **打印沙漏**\n## **题目描述**\n本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印\n\n```null\n*****\n ***\n  *\n ***\n*****\n```\n\n所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。\n给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。\n\n## **输入格式**\n输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。\n## **输出格式**\n首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。\n## **输入样例**\n```null\n19 *\n```\n## **输出样例**\n```null\n*****\n ***\n  *\n ***\n*****\n2\n```\n\n## 问题解决\n### 解题思想\n本题为典型的图形输出问题，此类问题处理的核心是：找规律。由题给示例我们可以得到如下规律（滑动以查看完整内容）：\n```\n行数为1时，需1个符号，即：1\n行数为3时，需7个符号，即：1+2X3\n行数为5时，需17个符号，即：1+2X3+2X5\n......\n行数为i时，需要的符号数为：1+2X3+...+2Xi\n```\n由此，很容易得出本题的处理方案，如下：\n设need_num为打印沙漏需要的最多符号个数，level为能打印的沙漏的最大层数，它们都初始化为1，因为N是正整数，因此至少能打印出一层；注意在读入字符前要吸收掉空格；在代码的while()循环中，不断地累加层数level，进而累加需要的符号数need_num，退出循环时要把多累加一次扣除掉；然后，根据规律，先打印沙漏的上半部分及中心层，注意还要控制空格的输出，再打印沙漏的下半部分，核心部分就是找到各部分的相应行打印空格数和符号数与level，i的关系。\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\nusing namespace std;\nint main()\n{\n    int n,c,level = 1;//level为能打印的沙漏的最大层数，初始化为1\n    int need_num = 1;//need_num为打印沙漏需要的符号个数\n    scanf(\"%d\",&n);//输入字符个数\n    getchar();//吸收掉空格\n    c = getchar();//输入字符\n    while(n / need_num){//计算n个符号所能打印的“最大沙漏”（用掉的符号尽可能多，层数最大）\n        level += 2;\n        need_num += 2 * level;\n    }\n    need_num -= 2 * level;//退出循环时最多需要的符号个数多加了一次\n    level -= 2;//退出循环时层数多加了一次（注意与上一行的顺序，不可颠倒）\n    for(int i = level; i >= level / 2 + 1; i--){//先打印沙漏的上半部分及中心部分\n        for(int k = 0; k < level - i; k++){//打印空格\n            printf(\" \");\n        }\n        for(int j = 0; j < 2 * i - level; j++){//打印符号\n            printf(\"%c\",c);\n        }\n        printf(\"\\n\");\n    }\n    for(int i = level / 2; i >= 1; i--){//再打印沙漏的下半部分\n        for(int k = 0; k < i - 1; k++){//打印空格\n            printf(\" \");\n        }\n        for(int j = 0; j < level - 2 * (i - 1); j++){//打印符号\n            printf(\"%c\",c);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"%d\",n - need_num);//输出剩下没用掉的符号数\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1027\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"patb1027","published":1,"updated":"2019-09-06T04:57:31.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfen001lfk0rgbruzxyr","content":"<h1 id=\"打印沙漏\"><a href=\"#打印沙漏\" class=\"headerlink\" title=\"打印沙漏\"></a><strong>打印沙漏</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****</span><br><span class=\"line\"> ***</span><br><span class=\"line\">  *</span><br><span class=\"line\"> ***</span><br><span class=\"line\">*****</span><br></pre></td></tr></table></figure></div>\n<p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。<br>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">19 *</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****</span><br><span class=\"line\"> ***</span><br><span class=\"line\">  *</span><br><span class=\"line\"> ***</span><br><span class=\"line\">*****</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题为典型的图形输出问题，此类问题处理的核心是：找规律。由题给示例我们可以得到如下规律（滑动以查看完整内容）：<br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行数为<span class=\"number\">1</span>时，需<span class=\"number\">1</span>个符号，即：<span class=\"number\">1</span></span><br><span class=\"line\">行数为<span class=\"number\">3</span>时，需<span class=\"number\">7</span>个符号，即：<span class=\"number\">1</span>+<span class=\"number\">2</span>X3</span><br><span class=\"line\">行数为<span class=\"number\">5</span>时，需<span class=\"number\">17</span>个符号，即：<span class=\"number\">1</span>+<span class=\"number\">2</span>X3+<span class=\"number\">2</span>X5</span><br><span class=\"line\">......</span><br><span class=\"line\">行数为i时，需要的符号数为：<span class=\"number\">1</span>+<span class=\"number\">2</span>X3+...+<span class=\"number\">2</span>Xi</span><br></pre></td></tr></table></figure></div></p>\n<p>由此，很容易得出本题的处理方案，如下：<br>设need_num为打印沙漏需要的最多符号个数，level为能打印的沙漏的最大层数，它们都初始化为1，因为N是正整数，因此至少能打印出一层；注意在读入字符前要吸收掉空格；在代码的while()循环中，不断地累加层数level，进而累加需要的符号数need_num，退出循环时要把多累加一次扣除掉；然后，根据规律，先打印沙漏的上半部分及中心层，注意还要控制空格的输出，再打印沙漏的下半部分，核心部分就是找到各部分的相应行打印空格数和符号数与level，i的关系。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,c,level = <span class=\"number\">1</span>;<span class=\"comment\">//level为能打印的沙漏的最大层数，初始化为1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> need_num = <span class=\"number\">1</span>;<span class=\"comment\">//need_num为打印沙漏需要的符号个数</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);<span class=\"comment\">//输入字符个数</span></span><br><span class=\"line\">    getchar();<span class=\"comment\">//吸收掉空格</span></span><br><span class=\"line\">    c = getchar();<span class=\"comment\">//输入字符</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n / need_num)&#123;<span class=\"comment\">//计算n个符号所能打印的“最大沙漏”（用掉的符号尽可能多，层数最大）</span></span><br><span class=\"line\">        level += <span class=\"number\">2</span>;</span><br><span class=\"line\">        need_num += <span class=\"number\">2</span> * level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    need_num -= <span class=\"number\">2</span> * level;<span class=\"comment\">//退出循环时最多需要的符号个数多加了一次</span></span><br><span class=\"line\">    level -= <span class=\"number\">2</span>;<span class=\"comment\">//退出循环时层数多加了一次（注意与上一行的顺序，不可颠倒）</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = level; i &gt;= level / <span class=\"number\">2</span> + <span class=\"number\">1</span>; i--)&#123;<span class=\"comment\">//先打印沙漏的上半部分及中心部分</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; level - i; k++)&#123;<span class=\"comment\">//打印空格</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">2</span> * i - level; j++)&#123;<span class=\"comment\">//打印符号</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = level / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">1</span>; i--)&#123;<span class=\"comment\">//再打印沙漏的下半部分</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; i - <span class=\"number\">1</span>; k++)&#123;<span class=\"comment\">//打印空格</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; level - <span class=\"number\">2</span> * (i - <span class=\"number\">1</span>); j++)&#123;<span class=\"comment\">//打印符号</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,n - need_num);<span class=\"comment\">//输出剩下没用掉的符号数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1027<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"打印沙漏\"><a href=\"#打印沙漏\" class=\"headerlink\" title=\"打印沙漏\"></a><strong>打印沙漏</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****</span><br><span class=\"line\"> ***</span><br><span class=\"line\">  *</span><br><span class=\"line\"> ***</span><br><span class=\"line\">*****</span><br></pre></td></tr></table></figure>\n<p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。<br>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">19 *</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*****</span><br><span class=\"line\"> ***</span><br><span class=\"line\">  *</span><br><span class=\"line\"> ***</span><br><span class=\"line\">*****</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题为典型的图形输出问题，此类问题处理的核心是：找规律。由题给示例我们可以得到如下规律（滑动以查看完整内容）：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行数为<span class=\"number\">1</span>时，需<span class=\"number\">1</span>个符号，即：<span class=\"number\">1</span></span><br><span class=\"line\">行数为<span class=\"number\">3</span>时，需<span class=\"number\">7</span>个符号，即：<span class=\"number\">1</span>+<span class=\"number\">2</span>X3</span><br><span class=\"line\">行数为<span class=\"number\">5</span>时，需<span class=\"number\">17</span>个符号，即：<span class=\"number\">1</span>+<span class=\"number\">2</span>X3+<span class=\"number\">2</span>X5</span><br><span class=\"line\">......</span><br><span class=\"line\">行数为i时，需要的符号数为：<span class=\"number\">1</span>+<span class=\"number\">2</span>X3+...+<span class=\"number\">2</span>Xi</span><br></pre></td></tr></table></figure></p>\n<p>由此，很容易得出本题的处理方案，如下：<br>设need_num为打印沙漏需要的最多符号个数，level为能打印的沙漏的最大层数，它们都初始化为1，因为N是正整数，因此至少能打印出一层；注意在读入字符前要吸收掉空格；在代码的while()循环中，不断地累加层数level，进而累加需要的符号数need_num，退出循环时要把多累加一次扣除掉；然后，根据规律，先打印沙漏的上半部分及中心层，注意还要控制空格的输出，再打印沙漏的下半部分，核心部分就是找到各部分的相应行打印空格数和符号数与level，i的关系。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,c,level = <span class=\"number\">1</span>;<span class=\"comment\">//level为能打印的沙漏的最大层数，初始化为1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> need_num = <span class=\"number\">1</span>;<span class=\"comment\">//need_num为打印沙漏需要的符号个数</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);<span class=\"comment\">//输入字符个数</span></span><br><span class=\"line\">    getchar();<span class=\"comment\">//吸收掉空格</span></span><br><span class=\"line\">    c = getchar();<span class=\"comment\">//输入字符</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n / need_num)&#123;<span class=\"comment\">//计算n个符号所能打印的“最大沙漏”（用掉的符号尽可能多，层数最大）</span></span><br><span class=\"line\">        level += <span class=\"number\">2</span>;</span><br><span class=\"line\">        need_num += <span class=\"number\">2</span> * level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    need_num -= <span class=\"number\">2</span> * level;<span class=\"comment\">//退出循环时最多需要的符号个数多加了一次</span></span><br><span class=\"line\">    level -= <span class=\"number\">2</span>;<span class=\"comment\">//退出循环时层数多加了一次（注意与上一行的顺序，不可颠倒）</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = level; i &gt;= level / <span class=\"number\">2</span> + <span class=\"number\">1</span>; i--)&#123;<span class=\"comment\">//先打印沙漏的上半部分及中心部分</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; level - i; k++)&#123;<span class=\"comment\">//打印空格</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">2</span> * i - level; j++)&#123;<span class=\"comment\">//打印符号</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = level / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">1</span>; i--)&#123;<span class=\"comment\">//再打印沙漏的下半部分</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; i - <span class=\"number\">1</span>; k++)&#123;<span class=\"comment\">//打印空格</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; level - <span class=\"number\">2</span> * (i - <span class=\"number\">1</span>); j++)&#123;<span class=\"comment\">//打印符号</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,n - need_num);<span class=\"comment\">//输出剩下没用掉的符号数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1027<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1028 || 人口普查（详解，C/C++示例，测试点分析）","date":"2019-09-06T04:08:33.000Z","mathjax":true,"_content":"\n# **人口普查**\n## **题目描述**\n某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。\n这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。\n\n## **输入格式**\n输入在第一行给出正整数 *N*，取值在(0,$10^5$]；随后 *N* 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 `yyyy/mm/dd`（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。\n## **输出格式**\n在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。\n## **输入样例**\n```null\n5\nJohn 2001/05/12\nTom 1814/09/06\nAnn 2121/01/30\nJames 1814/09/05\nSteve 1967/11/20\n```\n## **输出样例**\n```null\n3 Tom John\n```\n\n## 问题解决\n### 解题思想\n分别设置最年长人和最年轻人的姓名、生日，最年长人的生日初始化为最晚的年月日，最年轻人的生日初始化为最早的年月日（想一下为什么要这样初始化？）；用scanf()函数读入每一个人的姓名及生日（注意：不能用gets()函数，思考一下为什么？它们遇到空格的处理？），此处，生日以字符串的形式读入，构造一个函数将字符串格式生日转换成数值形式，通过引用来返回数值型的year,month,day；接着，判断此时输入的生日是否合理（不是年龄超过200岁的情况或未出生的生日的情况），若不合理，用continue直接跳过本次循环，进入下一次输入，若合理，判断是否比目前最年长的人更年长或者比目前最年轻的人更年轻，并进行相应的更新。\n\n### **坑点提醒**\n\n本题容易忽略的一个点就是：对有效生日个数为0个的特殊情况的处理。若有效生日个数为0个则不存在最年长或最年轻的人，相应的，只需输出有效生日个数即可（0），不需要输出最年长或最年轻的人的姓名。这也是PAT在线评测系统倒数第二个测试点测试的内容，若此处处理不当则此测试点将不会通过。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nvoid Birth_Strtonum(int &year,int &month,int &day,char birthday[]);\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    char name[6],birthday[11];//读入姓名和生日\n    char oldest[6],youngest[6];//最年长人和最年轻人的姓名\n    int old_y = 2014,old_m = 9,old_d = 6;//最年长人的生日，初始化为最晚的年月日\n    int young_y = 1814,young_m = 9,young_d = 6;//最年轻人的生日，初始化为最早的年月日\n    int coun = 0;//有效生日的个数\n    for(int i = 0; i < n; i++){\n        getchar();//吸收掉缓冲区换行符\n        scanf(\"%s%s\",name,birthday);//读入名字,以字符串格式读入生日\n        int year,month,day;\n        year = month = day = 0;\n        Birth_Strtonum(year,month,day,birthday);\n        //下面条件是年龄超过200岁的情况\n        if(year < 1814||(year == 1814&&month <9)\n           ||(year == 1814&&month == 9&&day < 6)){\n            continue;\n        }\n        //下面条件是未出生的生日的情况\n        if(year > 2014||(year == 2014&&month >9)\n           ||(year == 2014&&month == 9&&day > 6)){\n            continue;\n        }\n        //更新最年长的人\n        if(year < old_y||(year == old_y&&month < old_m)\n           ||(year == old_y&&month == old_m&&day < old_d)){\n            old_y = year;\n            old_m = month;\n            old_d = day;\n            strcpy(oldest,name);\n        }\n        //更新最年轻的人\n        if(year > young_y||(year == young_y&&month > young_m)\n           ||(year == young_y&&month == young_m&&day > young_d)){\n            young_y = year;\n            young_m = month;\n            young_d = day;\n            strcpy(youngest,name);\n        }\n        coun++;//有效生日的个数\n    }\n    if(coun == 0){//若有效生日个数为0个则不存在最年长或最年轻的人\n        printf(\"%d\",coun);\n    }\n    else{\n        printf(\"%d %s %s\",coun,oldest,youngest);\n    }\n    return 0;\n}\n//字符串格式生日转换成数值形式，通过引用来返回数值型的year,month,day\nvoid Birth_Strtonum(int &year,int &month,int &day,char birthday[])\n{\n    int j = 0;\n    int k = 1000;\n    while(j < 4){//年份转换成数值，注意每一个字符都要转换成数字\n        year += (birthday[j] - '0') * k;\n        k /= 10;\n        j++;\n    }\n    j++;//跳过年与月的间隔符号'/'\n    month = (birthday[j] - '0') * 10 + (birthday[j + 1] - '0');//月份转换成数值\n    j += 3;//j跳到天的位置\n    day = (birthday[j] - '0') * 10 + (birthday[j + 1] - '0');//天数转换成数值\n}\n```\n>题目来源：PAT乙级1028\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/patb1028.md","raw":"---\ntitle: PAT乙级1028 || 人口普查（详解，C/C++示例，测试点分析）\ndate: 2019-09-06 12:08:33\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **人口普查**\n## **题目描述**\n某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。\n这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。\n\n## **输入格式**\n输入在第一行给出正整数 *N*，取值在(0,$10^5$]；随后 *N* 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 `yyyy/mm/dd`（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。\n## **输出格式**\n在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。\n## **输入样例**\n```null\n5\nJohn 2001/05/12\nTom 1814/09/06\nAnn 2121/01/30\nJames 1814/09/05\nSteve 1967/11/20\n```\n## **输出样例**\n```null\n3 Tom John\n```\n\n## 问题解决\n### 解题思想\n分别设置最年长人和最年轻人的姓名、生日，最年长人的生日初始化为最晚的年月日，最年轻人的生日初始化为最早的年月日（想一下为什么要这样初始化？）；用scanf()函数读入每一个人的姓名及生日（注意：不能用gets()函数，思考一下为什么？它们遇到空格的处理？），此处，生日以字符串的形式读入，构造一个函数将字符串格式生日转换成数值形式，通过引用来返回数值型的year,month,day；接着，判断此时输入的生日是否合理（不是年龄超过200岁的情况或未出生的生日的情况），若不合理，用continue直接跳过本次循环，进入下一次输入，若合理，判断是否比目前最年长的人更年长或者比目前最年轻的人更年轻，并进行相应的更新。\n\n### **坑点提醒**\n\n本题容易忽略的一个点就是：对有效生日个数为0个的特殊情况的处理。若有效生日个数为0个则不存在最年长或最年轻的人，相应的，只需输出有效生日个数即可（0），不需要输出最年长或最年轻的人的姓名。这也是PAT在线评测系统倒数第二个测试点测试的内容，若此处处理不当则此测试点将不会通过。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nvoid Birth_Strtonum(int &year,int &month,int &day,char birthday[]);\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    char name[6],birthday[11];//读入姓名和生日\n    char oldest[6],youngest[6];//最年长人和最年轻人的姓名\n    int old_y = 2014,old_m = 9,old_d = 6;//最年长人的生日，初始化为最晚的年月日\n    int young_y = 1814,young_m = 9,young_d = 6;//最年轻人的生日，初始化为最早的年月日\n    int coun = 0;//有效生日的个数\n    for(int i = 0; i < n; i++){\n        getchar();//吸收掉缓冲区换行符\n        scanf(\"%s%s\",name,birthday);//读入名字,以字符串格式读入生日\n        int year,month,day;\n        year = month = day = 0;\n        Birth_Strtonum(year,month,day,birthday);\n        //下面条件是年龄超过200岁的情况\n        if(year < 1814||(year == 1814&&month <9)\n           ||(year == 1814&&month == 9&&day < 6)){\n            continue;\n        }\n        //下面条件是未出生的生日的情况\n        if(year > 2014||(year == 2014&&month >9)\n           ||(year == 2014&&month == 9&&day > 6)){\n            continue;\n        }\n        //更新最年长的人\n        if(year < old_y||(year == old_y&&month < old_m)\n           ||(year == old_y&&month == old_m&&day < old_d)){\n            old_y = year;\n            old_m = month;\n            old_d = day;\n            strcpy(oldest,name);\n        }\n        //更新最年轻的人\n        if(year > young_y||(year == young_y&&month > young_m)\n           ||(year == young_y&&month == young_m&&day > young_d)){\n            young_y = year;\n            young_m = month;\n            young_d = day;\n            strcpy(youngest,name);\n        }\n        coun++;//有效生日的个数\n    }\n    if(coun == 0){//若有效生日个数为0个则不存在最年长或最年轻的人\n        printf(\"%d\",coun);\n    }\n    else{\n        printf(\"%d %s %s\",coun,oldest,youngest);\n    }\n    return 0;\n}\n//字符串格式生日转换成数值形式，通过引用来返回数值型的year,month,day\nvoid Birth_Strtonum(int &year,int &month,int &day,char birthday[])\n{\n    int j = 0;\n    int k = 1000;\n    while(j < 4){//年份转换成数值，注意每一个字符都要转换成数字\n        year += (birthday[j] - '0') * k;\n        k /= 10;\n        j++;\n    }\n    j++;//跳过年与月的间隔符号'/'\n    month = (birthday[j] - '0') * 10 + (birthday[j + 1] - '0');//月份转换成数值\n    j += 3;//j跳到天的位置\n    day = (birthday[j] - '0') * 10 + (birthday[j + 1] - '0');//天数转换成数值\n}\n```\n>题目来源：PAT乙级1028\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"patb1028","published":1,"updated":"2019-09-06T04:59:46.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfer001qfk0r07eh6mrw","content":"<h1 id=\"人口普查\"><a href=\"#人口普查\" class=\"headerlink\" title=\"人口普查\"></a><strong>人口普查</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。<br>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在第一行给出正整数 <em>N</em>，取值在(0,$10^5$]；随后 <em>N</em> 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 <code>yyyy/mm/dd</code>（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">John 2001/05/12</span><br><span class=\"line\">Tom 1814/09/06</span><br><span class=\"line\">Ann 2121/01/30</span><br><span class=\"line\">James 1814/09/05</span><br><span class=\"line\">Steve 1967/11/20</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 Tom John</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>分别设置最年长人和最年轻人的姓名、生日，最年长人的生日初始化为最晚的年月日，最年轻人的生日初始化为最早的年月日（想一下为什么要这样初始化？）；用scanf()函数读入每一个人的姓名及生日（注意：不能用gets()函数，思考一下为什么？它们遇到空格的处理？），此处，生日以字符串的形式读入，构造一个函数将字符串格式生日转换成数值形式，通过引用来返回数值型的year,month,day；接着，判断此时输入的生日是否合理（不是年龄超过200岁的情况或未出生的生日的情况），若不合理，用continue直接跳过本次循环，进入下一次输入，若合理，判断是否比目前最年长的人更年长或者比目前最年轻的人更年轻，并进行相应的更新。</p>\n<h3 id=\"坑点提醒\"><a href=\"#坑点提醒\" class=\"headerlink\" title=\"坑点提醒\"></a><strong>坑点提醒</strong></h3><p>本题容易忽略的一个点就是：对有效生日个数为0个的特殊情况的处理。若有效生日个数为0个则不存在最年长或最年轻的人，相应的，只需输出有效生日个数即可（0），不需要输出最年长或最年轻的人的姓名。这也是PAT在线评测系统倒数第二个测试点测试的内容，若此处处理不当则此测试点将不会通过。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Birth_Strtonum</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;year,<span class=\"keyword\">int</span> &amp;month,<span class=\"keyword\">int</span> &amp;day,<span class=\"keyword\">char</span> birthday[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">6</span>],birthday[<span class=\"number\">11</span>];<span class=\"comment\">//读入姓名和生日</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> oldest[<span class=\"number\">6</span>],youngest[<span class=\"number\">6</span>];<span class=\"comment\">//最年长人和最年轻人的姓名</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> old_y = <span class=\"number\">2014</span>,old_m = <span class=\"number\">9</span>,old_d = <span class=\"number\">6</span>;<span class=\"comment\">//最年长人的生日，初始化为最晚的年月日</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> young_y = <span class=\"number\">1814</span>,young_m = <span class=\"number\">9</span>,young_d = <span class=\"number\">6</span>;<span class=\"comment\">//最年轻人的生日，初始化为最早的年月日</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> coun = <span class=\"number\">0</span>;<span class=\"comment\">//有效生日的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        getchar();<span class=\"comment\">//吸收掉缓冲区换行符</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s\"</span>,name,birthday);<span class=\"comment\">//读入名字,以字符串格式读入生日</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> year,month,day;</span><br><span class=\"line\">        year = month = day = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Birth_Strtonum(year,month,day,birthday);</span><br><span class=\"line\">        <span class=\"comment\">//下面条件是年龄超过200岁的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(year &lt; <span class=\"number\">1814</span>||(year == <span class=\"number\">1814</span>&amp;&amp;month &lt;<span class=\"number\">9</span>)</span><br><span class=\"line\">           ||(year == <span class=\"number\">1814</span>&amp;&amp;month == <span class=\"number\">9</span>&amp;&amp;day &lt; <span class=\"number\">6</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//下面条件是未出生的生日的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(year &gt; <span class=\"number\">2014</span>||(year == <span class=\"number\">2014</span>&amp;&amp;month &gt;<span class=\"number\">9</span>)</span><br><span class=\"line\">           ||(year == <span class=\"number\">2014</span>&amp;&amp;month == <span class=\"number\">9</span>&amp;&amp;day &gt; <span class=\"number\">6</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新最年长的人</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(year &lt; old_y||(year == old_y&amp;&amp;month &lt; old_m)</span><br><span class=\"line\">           ||(year == old_y&amp;&amp;month == old_m&amp;&amp;day &lt; old_d))&#123;</span><br><span class=\"line\">            old_y = year;</span><br><span class=\"line\">            old_m = month;</span><br><span class=\"line\">            old_d = day;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(oldest,name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新最年轻的人</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(year &gt; young_y||(year == young_y&amp;&amp;month &gt; young_m)</span><br><span class=\"line\">           ||(year == young_y&amp;&amp;month == young_m&amp;&amp;day &gt; young_d))&#123;</span><br><span class=\"line\">            young_y = year;</span><br><span class=\"line\">            young_m = month;</span><br><span class=\"line\">            young_d = day;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(youngest,name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        coun++;<span class=\"comment\">//有效生日的个数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(coun == <span class=\"number\">0</span>)&#123;<span class=\"comment\">//若有效生日个数为0个则不存在最年长或最年轻的人</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,coun);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %s %s\"</span>,coun,oldest,youngest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//字符串格式生日转换成数值形式，通过引用来返回数值型的year,month,day</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Birth_Strtonum</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;year,<span class=\"keyword\">int</span> &amp;month,<span class=\"keyword\">int</span> &amp;day,<span class=\"keyword\">char</span> birthday[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &lt; <span class=\"number\">4</span>)&#123;<span class=\"comment\">//年份转换成数值，注意每一个字符都要转换成数字</span></span><br><span class=\"line\">        year += (birthday[j] - <span class=\"string\">'0'</span>) * k;</span><br><span class=\"line\">        k /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    j++;<span class=\"comment\">//跳过年与月的间隔符号'/'</span></span><br><span class=\"line\">    month = (birthday[j] - <span class=\"string\">'0'</span>) * <span class=\"number\">10</span> + (birthday[j + <span class=\"number\">1</span>] - <span class=\"string\">'0'</span>);<span class=\"comment\">//月份转换成数值</span></span><br><span class=\"line\">    j += <span class=\"number\">3</span>;<span class=\"comment\">//j跳到天的位置</span></span><br><span class=\"line\">    day = (birthday[j] - <span class=\"string\">'0'</span>) * <span class=\"number\">10</span> + (birthday[j + <span class=\"number\">1</span>] - <span class=\"string\">'0'</span>);<span class=\"comment\">//天数转换成数值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1028<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"人口普查\"><a href=\"#人口普查\" class=\"headerlink\" title=\"人口普查\"></a><strong>人口普查</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。<br>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在第一行给出正整数 <em>N</em>，取值在(0,$10^5$]；随后 <em>N</em> 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 <code>yyyy/mm/dd</code>（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">John 2001/05/12</span><br><span class=\"line\">Tom 1814/09/06</span><br><span class=\"line\">Ann 2121/01/30</span><br><span class=\"line\">James 1814/09/05</span><br><span class=\"line\">Steve 1967/11/20</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 Tom John</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>分别设置最年长人和最年轻人的姓名、生日，最年长人的生日初始化为最晚的年月日，最年轻人的生日初始化为最早的年月日（想一下为什么要这样初始化？）；用scanf()函数读入每一个人的姓名及生日（注意：不能用gets()函数，思考一下为什么？它们遇到空格的处理？），此处，生日以字符串的形式读入，构造一个函数将字符串格式生日转换成数值形式，通过引用来返回数值型的year,month,day；接着，判断此时输入的生日是否合理（不是年龄超过200岁的情况或未出生的生日的情况），若不合理，用continue直接跳过本次循环，进入下一次输入，若合理，判断是否比目前最年长的人更年长或者比目前最年轻的人更年轻，并进行相应的更新。</p>\n<h3 id=\"坑点提醒\"><a href=\"#坑点提醒\" class=\"headerlink\" title=\"坑点提醒\"></a><strong>坑点提醒</strong></h3><p>本题容易忽略的一个点就是：对有效生日个数为0个的特殊情况的处理。若有效生日个数为0个则不存在最年长或最年轻的人，相应的，只需输出有效生日个数即可（0），不需要输出最年长或最年轻的人的姓名。这也是PAT在线评测系统倒数第二个测试点测试的内容，若此处处理不当则此测试点将不会通过。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Birth_Strtonum</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;year,<span class=\"keyword\">int</span> &amp;month,<span class=\"keyword\">int</span> &amp;day,<span class=\"keyword\">char</span> birthday[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">6</span>],birthday[<span class=\"number\">11</span>];<span class=\"comment\">//读入姓名和生日</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> oldest[<span class=\"number\">6</span>],youngest[<span class=\"number\">6</span>];<span class=\"comment\">//最年长人和最年轻人的姓名</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> old_y = <span class=\"number\">2014</span>,old_m = <span class=\"number\">9</span>,old_d = <span class=\"number\">6</span>;<span class=\"comment\">//最年长人的生日，初始化为最晚的年月日</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> young_y = <span class=\"number\">1814</span>,young_m = <span class=\"number\">9</span>,young_d = <span class=\"number\">6</span>;<span class=\"comment\">//最年轻人的生日，初始化为最早的年月日</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> coun = <span class=\"number\">0</span>;<span class=\"comment\">//有效生日的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        getchar();<span class=\"comment\">//吸收掉缓冲区换行符</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s\"</span>,name,birthday);<span class=\"comment\">//读入名字,以字符串格式读入生日</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> year,month,day;</span><br><span class=\"line\">        year = month = day = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Birth_Strtonum(year,month,day,birthday);</span><br><span class=\"line\">        <span class=\"comment\">//下面条件是年龄超过200岁的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(year &lt; <span class=\"number\">1814</span>||(year == <span class=\"number\">1814</span>&amp;&amp;month &lt;<span class=\"number\">9</span>)</span><br><span class=\"line\">           ||(year == <span class=\"number\">1814</span>&amp;&amp;month == <span class=\"number\">9</span>&amp;&amp;day &lt; <span class=\"number\">6</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//下面条件是未出生的生日的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(year &gt; <span class=\"number\">2014</span>||(year == <span class=\"number\">2014</span>&amp;&amp;month &gt;<span class=\"number\">9</span>)</span><br><span class=\"line\">           ||(year == <span class=\"number\">2014</span>&amp;&amp;month == <span class=\"number\">9</span>&amp;&amp;day &gt; <span class=\"number\">6</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新最年长的人</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(year &lt; old_y||(year == old_y&amp;&amp;month &lt; old_m)</span><br><span class=\"line\">           ||(year == old_y&amp;&amp;month == old_m&amp;&amp;day &lt; old_d))&#123;</span><br><span class=\"line\">            old_y = year;</span><br><span class=\"line\">            old_m = month;</span><br><span class=\"line\">            old_d = day;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(oldest,name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新最年轻的人</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(year &gt; young_y||(year == young_y&amp;&amp;month &gt; young_m)</span><br><span class=\"line\">           ||(year == young_y&amp;&amp;month == young_m&amp;&amp;day &gt; young_d))&#123;</span><br><span class=\"line\">            young_y = year;</span><br><span class=\"line\">            young_m = month;</span><br><span class=\"line\">            young_d = day;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(youngest,name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        coun++;<span class=\"comment\">//有效生日的个数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(coun == <span class=\"number\">0</span>)&#123;<span class=\"comment\">//若有效生日个数为0个则不存在最年长或最年轻的人</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,coun);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %s %s\"</span>,coun,oldest,youngest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//字符串格式生日转换成数值形式，通过引用来返回数值型的year,month,day</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Birth_Strtonum</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;year,<span class=\"keyword\">int</span> &amp;month,<span class=\"keyword\">int</span> &amp;day,<span class=\"keyword\">char</span> birthday[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &lt; <span class=\"number\">4</span>)&#123;<span class=\"comment\">//年份转换成数值，注意每一个字符都要转换成数字</span></span><br><span class=\"line\">        year += (birthday[j] - <span class=\"string\">'0'</span>) * k;</span><br><span class=\"line\">        k /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    j++;<span class=\"comment\">//跳过年与月的间隔符号'/'</span></span><br><span class=\"line\">    month = (birthday[j] - <span class=\"string\">'0'</span>) * <span class=\"number\">10</span> + (birthday[j + <span class=\"number\">1</span>] - <span class=\"string\">'0'</span>);<span class=\"comment\">//月份转换成数值</span></span><br><span class=\"line\">    j += <span class=\"number\">3</span>;<span class=\"comment\">//j跳到天的位置</span></span><br><span class=\"line\">    day = (birthday[j] - <span class=\"string\">'0'</span>) * <span class=\"number\">10</span> + (birthday[j + <span class=\"number\">1</span>] - <span class=\"string\">'0'</span>);<span class=\"comment\">//天数转换成数值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1028<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1029 || 旧键盘（详解，C/C++示例，测试点分析）","date":"2019-09-06T04:09:39.000Z","_content":"\n# **旧键盘**\n## **题目描述**\n旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。\n\n## **输入格式**\n输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 `_`（代表空格）组成。题目保证 2 个字符串均非空。\n## **输出格式**\n按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。\n## **输入样例**\n```null\n7_This_is_a_test\n_hs_s_a_es\n```\n## **输出样例**\n```null\n7TI\n```\n\n## 问题解决\n### 解题思想\n本题设置了一个标记数组str_hash[]，将字符0-9散列到数组str_hash[]下标0-9，将字符A-Z或a-z散列到数组str_hash[]下标10-35，对于散列之后对应的下标ha，str_hash[ha]为0表示散列前对应的字符还未输出；str_hash[ha]为1表示散列前对应的字符已经输出，就不再重复输出；将下划线单独处理。注意下标的移动问题，若a[i] != b[j]，则a[i]一定是坏键，此时只需将i后移一位；若a[i] = b[j]，则a[i]不是坏键，此时i与j都需要后移一位。由于某一字母是坏键时（无论大写还是小写字母）只需输出大写字母，只需将小写字母转换成大写字母，然后再进行散列即可。\n\n### 易错提醒\n\n示例代码中，若将第13行的while循环判断条件改成：\n\n```cpp\nwhile(a[i] != '\\0'&&b[j] != '\\0')\n```\n\n将导致最后一个测试点不通过，因为实际输入的文字串结束而应该输入的文字串未结束时，应该输入的文字串后面可能还会有一些坏键，由于循环已经退出，它们将不能输出，从而导致错误。\n\n若将第37行的i后移去掉，改成如下形式代码（i后移放到每一判断条件内部）：\n\n```cpp\n#include <cstdio>\n#define MAXN 81\nusing namespace std;\nint main()\n{\n    char a[MAXN],b[MAXN];   //a[]为应该输入的文字，b[]为实际输入的文字\n    int str_hash[36] = {0};    //通过散列的方式标记某一坏掉的键是否已输出\n    int flag = 1;   //单独标记下划线是否已输出(若下划线为坏掉的键)\n    scanf(\"%s\",a);    //输入应该输入的文字\n    getchar();  //吸收掉换行\n    scanf(\"%s\",b);    //输入实际输入的文字\n    int i = 0,j = 0;\n    while(a[i] != '\\0'){  //注意此处的条件\n        if(a[i] != b[j]){\n            if(flag&&a[i] == '_'){  //'_'为坏键且还未输出\n                printf(\"_\");\n                flag = 0;   //标记'_'已输出\n                i++;    //应输入文字串的下标后移一位\n            }\n            else if((a[i] >= 'a'&&a[i] <= 'z')\n                    ||(a[i] >= 'A'&&a[i] <= 'Z')){  //小写或大写字母\n                if(a[i] >= 'a'&&a[i] <= 'z'){   //若为小写字母\n                    a[i] -= 32; //转换成大写字母\n                }\n                int ha = a[i] - 55; //散列，'A'散列对应下标10\n                if(str_hash[ha] == 0){  //之前未输出过\n                    printf(\"%c\",a[i]);\n                    str_hash[ha] = 1;   //输出后标记为1\n                }\n                i++;    //应输入文字串的下标后移一位\n            }\n            else if(a[i] >= '0'&&a[i] <= '9'){  //若为数字\n                int ha = a[i] - '0';\n                if(str_hash[ha] == 0){  //之前未输出过\n                    printf(\"%c\",a[i]);\n                    str_hash[ha] = 1;   //输出后标记为1\n                }\n                i++;    //应输入文字串的下标后移一位\n            }\n        }\n        else{   //两文字串对应位置字符相同时，则下标同时后移一位\n            i++;\n            j++;\n        }\n    }\n    return 0;\n}\n```\n\n将i++改至第18，30及38行的位置，将导致倒数第二个测试点超时，因为一旦坏键为`_`且已输出，再次遇到时将不能进入判断条件内部，从而导致i不能得到更新，陷入死循环。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#define MAXN 81\nusing namespace std;\nint main()\n{\n    char a[MAXN],b[MAXN];   //a[]为应该输入的文字，b[]为实际输入的文字\n    int str_hash[36] = {0};    //通过散列的方式标记某一坏掉的键是否已输出\n    int flag = 1;   //单独标记下划线是否已输出(若下划线为坏掉的键)\n    scanf(\"%s\",a);    //输入应该输入的文字\n    getchar();  //吸收掉换行\n    scanf(\"%s\",b);    //输入实际输入的文字\n    int i = 0,j = 0;\n    while(a[i] != '\\0'){  //注意此处的条件\n        if(a[i] != b[j]){\n            if(flag&&a[i] == '_'){  //'_'为坏键且还未输出\n                printf(\"_\");\n                flag = 0;   //标记'_'已输出\n            }\n            else if((a[i] >= 'a'&&a[i] <= 'z')\n                    ||(a[i] >= 'A'&&a[i] <= 'Z')){  //小写或大写字母\n                if(a[i] >= 'a'&&a[i] <= 'z'){   //若为小写字母\n                    a[i] -= 32; //转换成大写字母\n                }\n                int ha = a[i] - 55; //散列，'A'散列对应下标10\n                if(str_hash[ha] == 0){  //之前未输出过\n                    printf(\"%c\",a[i]);\n                    str_hash[ha] = 1;   //输出后标记为1\n                }\n            }\n            else if(a[i] >= '0'&&a[i] <= '9'){  //若为数字\n                int ha = a[i] - '0';\n                if(str_hash[ha] == 0){  //之前未输出过\n                    printf(\"%c\",a[i]);\n                    str_hash[ha] = 1;   //输出后标记为1\n                }\n            }\n            i++;    //应输入文字串的下标后移一位\n        }\n        else{   //两文字串对应位置字符相同时，则下标同时后移一位\n            i++;\n            j++;\n        }\n    }\n    return 0;\n}\n```\n>题目来源：PAT乙级1029\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/patb1029.md","raw":"---\ntitle: PAT乙级1029 || 旧键盘（详解，C/C++示例，测试点分析）\ndate: 2019-09-06 12:09:39\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **旧键盘**\n## **题目描述**\n旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。\n\n## **输入格式**\n输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 `_`（代表空格）组成。题目保证 2 个字符串均非空。\n## **输出格式**\n按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。\n## **输入样例**\n```null\n7_This_is_a_test\n_hs_s_a_es\n```\n## **输出样例**\n```null\n7TI\n```\n\n## 问题解决\n### 解题思想\n本题设置了一个标记数组str_hash[]，将字符0-9散列到数组str_hash[]下标0-9，将字符A-Z或a-z散列到数组str_hash[]下标10-35，对于散列之后对应的下标ha，str_hash[ha]为0表示散列前对应的字符还未输出；str_hash[ha]为1表示散列前对应的字符已经输出，就不再重复输出；将下划线单独处理。注意下标的移动问题，若a[i] != b[j]，则a[i]一定是坏键，此时只需将i后移一位；若a[i] = b[j]，则a[i]不是坏键，此时i与j都需要后移一位。由于某一字母是坏键时（无论大写还是小写字母）只需输出大写字母，只需将小写字母转换成大写字母，然后再进行散列即可。\n\n### 易错提醒\n\n示例代码中，若将第13行的while循环判断条件改成：\n\n```cpp\nwhile(a[i] != '\\0'&&b[j] != '\\0')\n```\n\n将导致最后一个测试点不通过，因为实际输入的文字串结束而应该输入的文字串未结束时，应该输入的文字串后面可能还会有一些坏键，由于循环已经退出，它们将不能输出，从而导致错误。\n\n若将第37行的i后移去掉，改成如下形式代码（i后移放到每一判断条件内部）：\n\n```cpp\n#include <cstdio>\n#define MAXN 81\nusing namespace std;\nint main()\n{\n    char a[MAXN],b[MAXN];   //a[]为应该输入的文字，b[]为实际输入的文字\n    int str_hash[36] = {0};    //通过散列的方式标记某一坏掉的键是否已输出\n    int flag = 1;   //单独标记下划线是否已输出(若下划线为坏掉的键)\n    scanf(\"%s\",a);    //输入应该输入的文字\n    getchar();  //吸收掉换行\n    scanf(\"%s\",b);    //输入实际输入的文字\n    int i = 0,j = 0;\n    while(a[i] != '\\0'){  //注意此处的条件\n        if(a[i] != b[j]){\n            if(flag&&a[i] == '_'){  //'_'为坏键且还未输出\n                printf(\"_\");\n                flag = 0;   //标记'_'已输出\n                i++;    //应输入文字串的下标后移一位\n            }\n            else if((a[i] >= 'a'&&a[i] <= 'z')\n                    ||(a[i] >= 'A'&&a[i] <= 'Z')){  //小写或大写字母\n                if(a[i] >= 'a'&&a[i] <= 'z'){   //若为小写字母\n                    a[i] -= 32; //转换成大写字母\n                }\n                int ha = a[i] - 55; //散列，'A'散列对应下标10\n                if(str_hash[ha] == 0){  //之前未输出过\n                    printf(\"%c\",a[i]);\n                    str_hash[ha] = 1;   //输出后标记为1\n                }\n                i++;    //应输入文字串的下标后移一位\n            }\n            else if(a[i] >= '0'&&a[i] <= '9'){  //若为数字\n                int ha = a[i] - '0';\n                if(str_hash[ha] == 0){  //之前未输出过\n                    printf(\"%c\",a[i]);\n                    str_hash[ha] = 1;   //输出后标记为1\n                }\n                i++;    //应输入文字串的下标后移一位\n            }\n        }\n        else{   //两文字串对应位置字符相同时，则下标同时后移一位\n            i++;\n            j++;\n        }\n    }\n    return 0;\n}\n```\n\n将i++改至第18，30及38行的位置，将导致倒数第二个测试点超时，因为一旦坏键为`_`且已输出，再次遇到时将不能进入判断条件内部，从而导致i不能得到更新，陷入死循环。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#define MAXN 81\nusing namespace std;\nint main()\n{\n    char a[MAXN],b[MAXN];   //a[]为应该输入的文字，b[]为实际输入的文字\n    int str_hash[36] = {0};    //通过散列的方式标记某一坏掉的键是否已输出\n    int flag = 1;   //单独标记下划线是否已输出(若下划线为坏掉的键)\n    scanf(\"%s\",a);    //输入应该输入的文字\n    getchar();  //吸收掉换行\n    scanf(\"%s\",b);    //输入实际输入的文字\n    int i = 0,j = 0;\n    while(a[i] != '\\0'){  //注意此处的条件\n        if(a[i] != b[j]){\n            if(flag&&a[i] == '_'){  //'_'为坏键且还未输出\n                printf(\"_\");\n                flag = 0;   //标记'_'已输出\n            }\n            else if((a[i] >= 'a'&&a[i] <= 'z')\n                    ||(a[i] >= 'A'&&a[i] <= 'Z')){  //小写或大写字母\n                if(a[i] >= 'a'&&a[i] <= 'z'){   //若为小写字母\n                    a[i] -= 32; //转换成大写字母\n                }\n                int ha = a[i] - 55; //散列，'A'散列对应下标10\n                if(str_hash[ha] == 0){  //之前未输出过\n                    printf(\"%c\",a[i]);\n                    str_hash[ha] = 1;   //输出后标记为1\n                }\n            }\n            else if(a[i] >= '0'&&a[i] <= '9'){  //若为数字\n                int ha = a[i] - '0';\n                if(str_hash[ha] == 0){  //之前未输出过\n                    printf(\"%c\",a[i]);\n                    str_hash[ha] = 1;   //输出后标记为1\n                }\n            }\n            i++;    //应输入文字串的下标后移一位\n        }\n        else{   //两文字串对应位置字符相同时，则下标同时后移一位\n            i++;\n            j++;\n        }\n    }\n    return 0;\n}\n```\n>题目来源：PAT乙级1029\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"patb1029","published":1,"updated":"2019-09-06T05:04:54.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfev001tfk0rz3db6ypm","content":"<h1 id=\"旧键盘\"><a href=\"#旧键盘\" class=\"headerlink\" title=\"旧键盘\"></a><strong>旧键盘</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 <code>_</code>（代表空格）组成。题目保证 2 个字符串均非空。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7_This_is_a_test</span><br><span class=\"line\">_hs_s_a_es</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7TI</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题设置了一个标记数组str_hash[]，将字符0-9散列到数组str_hash[]下标0-9，将字符A-Z或a-z散列到数组str_hash[]下标10-35，对于散列之后对应的下标ha，str_hash[ha]为0表示散列前对应的字符还未输出；str_hash[ha]为1表示散列前对应的字符已经输出，就不再重复输出；将下划线单独处理。注意下标的移动问题，若a[i] != b[j]，则a[i]一定是坏键，此时只需将i后移一位；若a[i] = b[j]，则a[i]不是坏键，此时i与j都需要后移一位。由于某一字母是坏键时（无论大写还是小写字母）只需输出大写字母，只需将小写字母转换成大写字母，然后再进行散列即可。</p>\n<h3 id=\"易错提醒\"><a href=\"#易错提醒\" class=\"headerlink\" title=\"易错提醒\"></a>易错提醒</h3><p>示例代码中，若将第13行的while循环判断条件改成：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(a[i] != <span class=\"string\">'\\0'</span>&amp;&amp;b[j] != <span class=\"string\">'\\0'</span>)</span><br></pre></td></tr></table></figure></div>\n<p>将导致最后一个测试点不通过，因为实际输入的文字串结束而应该输入的文字串未结束时，应该输入的文字串后面可能还会有一些坏键，由于循环已经退出，它们将不能输出，从而导致错误。</p>\n<p>若将第37行的i后移去掉，改成如下形式代码（i后移放到每一判断条件内部）：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 81</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a[MAXN],b[MAXN];   <span class=\"comment\">//a[]为应该输入的文字，b[]为实际输入的文字</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> str_hash[<span class=\"number\">36</span>] = &#123;<span class=\"number\">0</span>&#125;;    <span class=\"comment\">//通过散列的方式标记某一坏掉的键是否已输出</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;   <span class=\"comment\">//单独标记下划线是否已输出(若下划线为坏掉的键)</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,a);    <span class=\"comment\">//输入应该输入的文字</span></span><br><span class=\"line\">    getchar();  <span class=\"comment\">//吸收掉换行</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,b);    <span class=\"comment\">//输入实际输入的文字</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a[i] != <span class=\"string\">'\\0'</span>)&#123;  <span class=\"comment\">//注意此处的条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i] != b[j])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag&amp;&amp;a[i] == <span class=\"string\">'_'</span>)&#123;  <span class=\"comment\">//'_'为坏键且还未输出</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"_\"</span>);</span><br><span class=\"line\">                flag = <span class=\"number\">0</span>;   <span class=\"comment\">//标记'_'已输出</span></span><br><span class=\"line\">                i++;    <span class=\"comment\">//应输入文字串的下标后移一位</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((a[i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'z'</span>)</span><br><span class=\"line\">                    ||(a[i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'Z'</span>))&#123;  <span class=\"comment\">//小写或大写字母</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(a[i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'z'</span>)&#123;   <span class=\"comment\">//若为小写字母</span></span><br><span class=\"line\">                    a[i] -= <span class=\"number\">32</span>; <span class=\"comment\">//转换成大写字母</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ha = a[i] - <span class=\"number\">55</span>; <span class=\"comment\">//散列，'A'散列对应下标10</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str_hash[ha] == <span class=\"number\">0</span>)&#123;  <span class=\"comment\">//之前未输出过</span></span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,a[i]);</span><br><span class=\"line\">                    str_hash[ha] = <span class=\"number\">1</span>;   <span class=\"comment\">//输出后标记为1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;    <span class=\"comment\">//应输入文字串的下标后移一位</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] &gt;= <span class=\"string\">'0'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'9'</span>)&#123;  <span class=\"comment\">//若为数字</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> ha = a[i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str_hash[ha] == <span class=\"number\">0</span>)&#123;  <span class=\"comment\">//之前未输出过</span></span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,a[i]);</span><br><span class=\"line\">                    str_hash[ha] = <span class=\"number\">1</span>;   <span class=\"comment\">//输出后标记为1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;    <span class=\"comment\">//应输入文字串的下标后移一位</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//两文字串对应位置字符相同时，则下标同时后移一位</span></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>将i++改至第18，30及38行的位置，将导致倒数第二个测试点超时，因为一旦坏键为<code>_</code>且已输出，再次遇到时将不能进入判断条件内部，从而导致i不能得到更新，陷入死循环。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 81</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a[MAXN],b[MAXN];   <span class=\"comment\">//a[]为应该输入的文字，b[]为实际输入的文字</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> str_hash[<span class=\"number\">36</span>] = &#123;<span class=\"number\">0</span>&#125;;    <span class=\"comment\">//通过散列的方式标记某一坏掉的键是否已输出</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;   <span class=\"comment\">//单独标记下划线是否已输出(若下划线为坏掉的键)</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,a);    <span class=\"comment\">//输入应该输入的文字</span></span><br><span class=\"line\">    getchar();  <span class=\"comment\">//吸收掉换行</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,b);    <span class=\"comment\">//输入实际输入的文字</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a[i] != <span class=\"string\">'\\0'</span>)&#123;  <span class=\"comment\">//注意此处的条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i] != b[j])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag&amp;&amp;a[i] == <span class=\"string\">'_'</span>)&#123;  <span class=\"comment\">//'_'为坏键且还未输出</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"_\"</span>);</span><br><span class=\"line\">                flag = <span class=\"number\">0</span>;   <span class=\"comment\">//标记'_'已输出</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((a[i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'z'</span>)</span><br><span class=\"line\">                    ||(a[i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'Z'</span>))&#123;  <span class=\"comment\">//小写或大写字母</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(a[i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'z'</span>)&#123;   <span class=\"comment\">//若为小写字母</span></span><br><span class=\"line\">                    a[i] -= <span class=\"number\">32</span>; <span class=\"comment\">//转换成大写字母</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ha = a[i] - <span class=\"number\">55</span>; <span class=\"comment\">//散列，'A'散列对应下标10</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str_hash[ha] == <span class=\"number\">0</span>)&#123;  <span class=\"comment\">//之前未输出过</span></span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,a[i]);</span><br><span class=\"line\">                    str_hash[ha] = <span class=\"number\">1</span>;   <span class=\"comment\">//输出后标记为1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] &gt;= <span class=\"string\">'0'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'9'</span>)&#123;  <span class=\"comment\">//若为数字</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> ha = a[i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str_hash[ha] == <span class=\"number\">0</span>)&#123;  <span class=\"comment\">//之前未输出过</span></span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,a[i]);</span><br><span class=\"line\">                    str_hash[ha] = <span class=\"number\">1</span>;   <span class=\"comment\">//输出后标记为1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;    <span class=\"comment\">//应输入文字串的下标后移一位</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//两文字串对应位置字符相同时，则下标同时后移一位</span></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1029<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"旧键盘\"><a href=\"#旧键盘\" class=\"headerlink\" title=\"旧键盘\"></a><strong>旧键盘</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 <code>_</code>（代表空格）组成。题目保证 2 个字符串均非空。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7_This_is_a_test</span><br><span class=\"line\">_hs_s_a_es</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7TI</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题设置了一个标记数组str_hash[]，将字符0-9散列到数组str_hash[]下标0-9，将字符A-Z或a-z散列到数组str_hash[]下标10-35，对于散列之后对应的下标ha，str_hash[ha]为0表示散列前对应的字符还未输出；str_hash[ha]为1表示散列前对应的字符已经输出，就不再重复输出；将下划线单独处理。注意下标的移动问题，若a[i] != b[j]，则a[i]一定是坏键，此时只需将i后移一位；若a[i] = b[j]，则a[i]不是坏键，此时i与j都需要后移一位。由于某一字母是坏键时（无论大写还是小写字母）只需输出大写字母，只需将小写字母转换成大写字母，然后再进行散列即可。</p>\n<h3 id=\"易错提醒\"><a href=\"#易错提醒\" class=\"headerlink\" title=\"易错提醒\"></a>易错提醒</h3><p>示例代码中，若将第13行的while循环判断条件改成：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(a[i] != <span class=\"string\">'\\0'</span>&amp;&amp;b[j] != <span class=\"string\">'\\0'</span>)</span><br></pre></td></tr></table></figure>\n<p>将导致最后一个测试点不通过，因为实际输入的文字串结束而应该输入的文字串未结束时，应该输入的文字串后面可能还会有一些坏键，由于循环已经退出，它们将不能输出，从而导致错误。</p>\n<p>若将第37行的i后移去掉，改成如下形式代码（i后移放到每一判断条件内部）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 81</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a[MAXN],b[MAXN];   <span class=\"comment\">//a[]为应该输入的文字，b[]为实际输入的文字</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> str_hash[<span class=\"number\">36</span>] = &#123;<span class=\"number\">0</span>&#125;;    <span class=\"comment\">//通过散列的方式标记某一坏掉的键是否已输出</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;   <span class=\"comment\">//单独标记下划线是否已输出(若下划线为坏掉的键)</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,a);    <span class=\"comment\">//输入应该输入的文字</span></span><br><span class=\"line\">    getchar();  <span class=\"comment\">//吸收掉换行</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,b);    <span class=\"comment\">//输入实际输入的文字</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a[i] != <span class=\"string\">'\\0'</span>)&#123;  <span class=\"comment\">//注意此处的条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i] != b[j])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag&amp;&amp;a[i] == <span class=\"string\">'_'</span>)&#123;  <span class=\"comment\">//'_'为坏键且还未输出</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"_\"</span>);</span><br><span class=\"line\">                flag = <span class=\"number\">0</span>;   <span class=\"comment\">//标记'_'已输出</span></span><br><span class=\"line\">                i++;    <span class=\"comment\">//应输入文字串的下标后移一位</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((a[i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'z'</span>)</span><br><span class=\"line\">                    ||(a[i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'Z'</span>))&#123;  <span class=\"comment\">//小写或大写字母</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(a[i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'z'</span>)&#123;   <span class=\"comment\">//若为小写字母</span></span><br><span class=\"line\">                    a[i] -= <span class=\"number\">32</span>; <span class=\"comment\">//转换成大写字母</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ha = a[i] - <span class=\"number\">55</span>; <span class=\"comment\">//散列，'A'散列对应下标10</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str_hash[ha] == <span class=\"number\">0</span>)&#123;  <span class=\"comment\">//之前未输出过</span></span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,a[i]);</span><br><span class=\"line\">                    str_hash[ha] = <span class=\"number\">1</span>;   <span class=\"comment\">//输出后标记为1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;    <span class=\"comment\">//应输入文字串的下标后移一位</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] &gt;= <span class=\"string\">'0'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'9'</span>)&#123;  <span class=\"comment\">//若为数字</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> ha = a[i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str_hash[ha] == <span class=\"number\">0</span>)&#123;  <span class=\"comment\">//之前未输出过</span></span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,a[i]);</span><br><span class=\"line\">                    str_hash[ha] = <span class=\"number\">1</span>;   <span class=\"comment\">//输出后标记为1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;    <span class=\"comment\">//应输入文字串的下标后移一位</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//两文字串对应位置字符相同时，则下标同时后移一位</span></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将i++改至第18，30及38行的位置，将导致倒数第二个测试点超时，因为一旦坏键为<code>_</code>且已输出，再次遇到时将不能进入判断条件内部，从而导致i不能得到更新，陷入死循环。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 81</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a[MAXN],b[MAXN];   <span class=\"comment\">//a[]为应该输入的文字，b[]为实际输入的文字</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> str_hash[<span class=\"number\">36</span>] = &#123;<span class=\"number\">0</span>&#125;;    <span class=\"comment\">//通过散列的方式标记某一坏掉的键是否已输出</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;   <span class=\"comment\">//单独标记下划线是否已输出(若下划线为坏掉的键)</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,a);    <span class=\"comment\">//输入应该输入的文字</span></span><br><span class=\"line\">    getchar();  <span class=\"comment\">//吸收掉换行</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,b);    <span class=\"comment\">//输入实际输入的文字</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a[i] != <span class=\"string\">'\\0'</span>)&#123;  <span class=\"comment\">//注意此处的条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i] != b[j])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag&amp;&amp;a[i] == <span class=\"string\">'_'</span>)&#123;  <span class=\"comment\">//'_'为坏键且还未输出</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"_\"</span>);</span><br><span class=\"line\">                flag = <span class=\"number\">0</span>;   <span class=\"comment\">//标记'_'已输出</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((a[i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'z'</span>)</span><br><span class=\"line\">                    ||(a[i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'Z'</span>))&#123;  <span class=\"comment\">//小写或大写字母</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(a[i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'z'</span>)&#123;   <span class=\"comment\">//若为小写字母</span></span><br><span class=\"line\">                    a[i] -= <span class=\"number\">32</span>; <span class=\"comment\">//转换成大写字母</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ha = a[i] - <span class=\"number\">55</span>; <span class=\"comment\">//散列，'A'散列对应下标10</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str_hash[ha] == <span class=\"number\">0</span>)&#123;  <span class=\"comment\">//之前未输出过</span></span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,a[i]);</span><br><span class=\"line\">                    str_hash[ha] = <span class=\"number\">1</span>;   <span class=\"comment\">//输出后标记为1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] &gt;= <span class=\"string\">'0'</span>&amp;&amp;a[i] &lt;= <span class=\"string\">'9'</span>)&#123;  <span class=\"comment\">//若为数字</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> ha = a[i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str_hash[ha] == <span class=\"number\">0</span>)&#123;  <span class=\"comment\">//之前未输出过</span></span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,a[i]);</span><br><span class=\"line\">                    str_hash[ha] = <span class=\"number\">1</span>;   <span class=\"comment\">//输出后标记为1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;    <span class=\"comment\">//应输入文字串的下标后移一位</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//两文字串对应位置字符相同时，则下标同时后移一位</span></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1029<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1030 || 完美数列（详解，C/C++示例，测试点分析）","date":"2019-09-06T04:09:47.000Z","mathjax":true,"_content":"\n# **完美数列**\n## **题目描述**\n给定一个正整数数列，和正整数 *p*，设这个数列中的最大值是 *M*，最小值是 *m*，如果 M ≤ mp，则称这个数列是完美数列。\n现在给定参数 *p* 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。\n\n## **输入格式**\n输入第一行给出两个正整数 *N* 和 *p*，其中 *N*（≤$10^5$）是输入的正整数的个数，*p*（≤$10^9$）是给定的参数。第二行给出 *N* 个正整数，每个数不超过 $10^9$。\n## **输出格式**\n在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。\n## **输入样例**\n```null\n10 8\n2 3 20 4 5 1 6 7 8 9\n```\n## **输出样例**\n```null\n8\n```\n\n## 问题解决\n### 解题思想\n**方法一**：递归方法，测试点4会超时\n\n注意参数p和数组a[]要定义成long或long long型，否则会导致测试点5不通过，想一下为什么？输入后先对数组a[]进行升序排序，然后递归调用函数Max_Per_Array()：\n\n1. 终止条件：a[j] <= p x a[i]，满足则直接返回j-i+1；\n2. 递归条件：a[j] > p x a[i]，先后判断**最大值前移一位满足而最小值后移一位不满足**和**最大值前移一位不满足而最小值后移一位满足**这两个条件是否满足，若满足，则只需进行相应的单个调用即可，若都不满足，则依次进行两个调用，返回最大的即可。\n\n此法思路很简单，但是，运行效率不高，提交时测试点4会超时，因此有下面更高效的方法。\n**方法二**：优化双层循环方法\n先初始化完美数列最多元素个数，至少为1个；用双层循环，i从0开始依次递加作外层循环，a[i]为最小值，对于每一个i，j从i+max_coun开始，a[j]为最大值，判断是否满足完美数列的条件，若满足，则更新max_coun为当前完美数列的元素个数，即j-i+1，然后继续累加j继续判断直到跳出内层循环；若不满足，则直接跳出内存循环，因为若当前的j不满足，则后面的最大值更大，必不满足。\n此法效率较高，不会出现超时。\n\n### 代码示例（C/C++）\n\n**代码1**\n\n```cpp\n//递归方法，测试点4会超时\n#include <cstdio>\n#include <algorithm>\n#define MAXN 100001\nusing namespace std;\nint Max_Per_Array(long a[],int i,int j,long p);\nint main()\n{\n    int n;\n    long p;//定义为long型\n    scanf(\"%d%ld\",&n,&p);\n    long a[MAXN];//定义为long型\n    for(int i = 0; i < n; i++){\n        scanf(\"%ld\",&a[i]);\n    }\n    sort(a,a+n);//升序排序\n    int max_coun;\n    max_coun = Max_Per_Array(a,0,n-1,p);\n    printf(\"%d\",max_coun);\n    return 0;\n}\n//返回数组a[]从第i到第j个位置能构成完美数列的最大元素个数\nint Max_Per_Array(long a[],int i,int j,long p)\n{\n    if(a[j] <= p * a[i]){//满足完美数列\n        return j-i+1;\n    }\n    else{//不满足完美数列\n        if(a[j - 1] > p * a[i]&&a[j] <= p * a[i + 1]){//最大值前移一位满足而最小值后移一位不满足\n            return Max_Per_Array(a,++i,j,p);//直接让最小值后移一位\n        }\n        else if(a[j - 1] <= p * a[i]&&a[j] > p * a[i + 1]){//最大值前移一位不满足而最小值后移一位满足\n            return Max_Per_Array(a,i,--j,p);//直接让最大值前移一位\n        }\n        else{//最大值前移一位或最小值后移一位都不满足则分别前移和后移\n            int ch_min,ch_max;\n            ch_min = Max_Per_Array(a,++i,j,p);\n            ch_max = Max_Per_Array(a,i,--j,p);\n            return ch_min > ch_max ? ch_min : ch_max;//返回最大元素个数\n        }\n    }\n}\n```\n**代码2**\n```cpp\n//优化双层循环方法，全部通过测试点\n#include <cstdio>\n#include <algorithm>\n#define MAXN 100001\nusing namespace std;\nint main()\n{\n    int n;\n    long p;\n    scanf(\"%d%ld\",&n,&p);\n    long a[MAXN];\n    for(int i = 0; i < n; i++){\n        scanf(\"%ld\",&a[i]);\n    }\n    sort(a,a+n);//升序排序\n    int max_coun = 1;//完美数列最多元素个数，至少1个\n    for(int i = 0; i < n; i++){\n        for(int j = i + max_coun; j < n; j++){//最大值从最小值位置加上当前完美数列最多元素个数处开始即可\n            if(a[j] <= a[i] * p){//满足完美数列\n                max_coun = j - i + 1;//更新最多元素个数\n            }\n            else{//不满足直接跳出循环，j再往后，最大值会更大，更不会满足\n                break;\n            }\n        }\n    }\n    printf(\"%d\",max_coun);\n    return 0;\n}\n```\n>题目来源：PAT乙级1030\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/patb1030.md","raw":"---\ntitle: PAT乙级1030 || 完美数列（详解，C/C++示例，测试点分析）\ndate: 2019-09-06 12:09:47\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **完美数列**\n## **题目描述**\n给定一个正整数数列，和正整数 *p*，设这个数列中的最大值是 *M*，最小值是 *m*，如果 M ≤ mp，则称这个数列是完美数列。\n现在给定参数 *p* 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。\n\n## **输入格式**\n输入第一行给出两个正整数 *N* 和 *p*，其中 *N*（≤$10^5$）是输入的正整数的个数，*p*（≤$10^9$）是给定的参数。第二行给出 *N* 个正整数，每个数不超过 $10^9$。\n## **输出格式**\n在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。\n## **输入样例**\n```null\n10 8\n2 3 20 4 5 1 6 7 8 9\n```\n## **输出样例**\n```null\n8\n```\n\n## 问题解决\n### 解题思想\n**方法一**：递归方法，测试点4会超时\n\n注意参数p和数组a[]要定义成long或long long型，否则会导致测试点5不通过，想一下为什么？输入后先对数组a[]进行升序排序，然后递归调用函数Max_Per_Array()：\n\n1. 终止条件：a[j] <= p x a[i]，满足则直接返回j-i+1；\n2. 递归条件：a[j] > p x a[i]，先后判断**最大值前移一位满足而最小值后移一位不满足**和**最大值前移一位不满足而最小值后移一位满足**这两个条件是否满足，若满足，则只需进行相应的单个调用即可，若都不满足，则依次进行两个调用，返回最大的即可。\n\n此法思路很简单，但是，运行效率不高，提交时测试点4会超时，因此有下面更高效的方法。\n**方法二**：优化双层循环方法\n先初始化完美数列最多元素个数，至少为1个；用双层循环，i从0开始依次递加作外层循环，a[i]为最小值，对于每一个i，j从i+max_coun开始，a[j]为最大值，判断是否满足完美数列的条件，若满足，则更新max_coun为当前完美数列的元素个数，即j-i+1，然后继续累加j继续判断直到跳出内层循环；若不满足，则直接跳出内存循环，因为若当前的j不满足，则后面的最大值更大，必不满足。\n此法效率较高，不会出现超时。\n\n### 代码示例（C/C++）\n\n**代码1**\n\n```cpp\n//递归方法，测试点4会超时\n#include <cstdio>\n#include <algorithm>\n#define MAXN 100001\nusing namespace std;\nint Max_Per_Array(long a[],int i,int j,long p);\nint main()\n{\n    int n;\n    long p;//定义为long型\n    scanf(\"%d%ld\",&n,&p);\n    long a[MAXN];//定义为long型\n    for(int i = 0; i < n; i++){\n        scanf(\"%ld\",&a[i]);\n    }\n    sort(a,a+n);//升序排序\n    int max_coun;\n    max_coun = Max_Per_Array(a,0,n-1,p);\n    printf(\"%d\",max_coun);\n    return 0;\n}\n//返回数组a[]从第i到第j个位置能构成完美数列的最大元素个数\nint Max_Per_Array(long a[],int i,int j,long p)\n{\n    if(a[j] <= p * a[i]){//满足完美数列\n        return j-i+1;\n    }\n    else{//不满足完美数列\n        if(a[j - 1] > p * a[i]&&a[j] <= p * a[i + 1]){//最大值前移一位满足而最小值后移一位不满足\n            return Max_Per_Array(a,++i,j,p);//直接让最小值后移一位\n        }\n        else if(a[j - 1] <= p * a[i]&&a[j] > p * a[i + 1]){//最大值前移一位不满足而最小值后移一位满足\n            return Max_Per_Array(a,i,--j,p);//直接让最大值前移一位\n        }\n        else{//最大值前移一位或最小值后移一位都不满足则分别前移和后移\n            int ch_min,ch_max;\n            ch_min = Max_Per_Array(a,++i,j,p);\n            ch_max = Max_Per_Array(a,i,--j,p);\n            return ch_min > ch_max ? ch_min : ch_max;//返回最大元素个数\n        }\n    }\n}\n```\n**代码2**\n```cpp\n//优化双层循环方法，全部通过测试点\n#include <cstdio>\n#include <algorithm>\n#define MAXN 100001\nusing namespace std;\nint main()\n{\n    int n;\n    long p;\n    scanf(\"%d%ld\",&n,&p);\n    long a[MAXN];\n    for(int i = 0; i < n; i++){\n        scanf(\"%ld\",&a[i]);\n    }\n    sort(a,a+n);//升序排序\n    int max_coun = 1;//完美数列最多元素个数，至少1个\n    for(int i = 0; i < n; i++){\n        for(int j = i + max_coun; j < n; j++){//最大值从最小值位置加上当前完美数列最多元素个数处开始即可\n            if(a[j] <= a[i] * p){//满足完美数列\n                max_coun = j - i + 1;//更新最多元素个数\n            }\n            else{//不满足直接跳出循环，j再往后，最大值会更大，更不会满足\n                break;\n            }\n        }\n    }\n    printf(\"%d\",max_coun);\n    return 0;\n}\n```\n>题目来源：PAT乙级1030\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"patb1030","published":1,"updated":"2019-09-06T05:09:35.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfey001wfk0r6rl0vlu7","content":"<h1 id=\"完美数列\"><a href=\"#完美数列\" class=\"headerlink\" title=\"完美数列\"></a><strong>完美数列</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一个正整数数列，和正整数 <em>p</em>，设这个数列中的最大值是 <em>M</em>，最小值是 <em>m</em>，如果 M ≤ mp，则称这个数列是完美数列。<br>现在给定参数 <em>p</em> 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入第一行给出两个正整数 <em>N</em> 和 <em>p</em>，其中 <em>N</em>（≤$10^5$）是输入的正整数的个数，<em>p</em>（≤$10^9$）是给定的参数。第二行给出 <em>N</em> 个正整数，每个数不超过 $10^9$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 8</span><br><span class=\"line\">2 3 20 4 5 1 6 7 8 9</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p><strong>方法一</strong>：递归方法，测试点4会超时</p>\n<p>注意参数p和数组a[]要定义成long或long long型，否则会导致测试点5不通过，想一下为什么？输入后先对数组a[]进行升序排序，然后递归调用函数Max_Per_Array()：</p>\n<ol>\n<li>终止条件：a[j] &lt;= p x a[i]，满足则直接返回j-i+1；</li>\n<li>递归条件：a[j] &gt; p x a[i]，先后判断<strong>最大值前移一位满足而最小值后移一位不满足</strong>和<strong>最大值前移一位不满足而最小值后移一位满足</strong>这两个条件是否满足，若满足，则只需进行相应的单个调用即可，若都不满足，则依次进行两个调用，返回最大的即可。</li>\n</ol>\n<p>此法思路很简单，但是，运行效率不高，提交时测试点4会超时，因此有下面更高效的方法。<br><strong>方法二</strong>：优化双层循环方法<br>先初始化完美数列最多元素个数，至少为1个；用双层循环，i从0开始依次递加作外层循环，a[i]为最小值，对于每一个i，j从i+max_coun开始，a[j]为最大值，判断是否满足完美数列的条件，若满足，则更新max_coun为当前完美数列的元素个数，即j-i+1，然后继续累加j继续判断直到跳出内层循环；若不满足，则直接跳出内存循环，因为若当前的j不满足，则后面的最大值更大，必不满足。<br>此法效率较高，不会出现超时。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><p><strong>代码1</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//递归方法，测试点4会超时</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max_Per_Array</span><span class=\"params\">(<span class=\"keyword\">long</span> a[],<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j,<span class=\"keyword\">long</span> p)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> p;<span class=\"comment\">//定义为long型</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%ld\"</span>,&amp;n,&amp;p);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> a[MAXN];<span class=\"comment\">//定义为long型</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%ld\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a,a+n);<span class=\"comment\">//升序排序</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_coun;</span><br><span class=\"line\">    max_coun = Max_Per_Array(a,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,p);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,max_coun);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//返回数组a[]从第i到第j个位置能构成完美数列的最大元素个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max_Per_Array</span><span class=\"params\">(<span class=\"keyword\">long</span> a[],<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j,<span class=\"keyword\">long</span> p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a[j] &lt;= p * a[i])&#123;<span class=\"comment\">//满足完美数列</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> j-i+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//不满足完美数列</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[j - <span class=\"number\">1</span>] &gt; p * a[i]&amp;&amp;a[j] &lt;= p * a[i + <span class=\"number\">1</span>])&#123;<span class=\"comment\">//最大值前移一位满足而最小值后移一位不满足</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Max_Per_Array(a,++i,j,p);<span class=\"comment\">//直接让最小值后移一位</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[j - <span class=\"number\">1</span>] &lt;= p * a[i]&amp;&amp;a[j] &gt; p * a[i + <span class=\"number\">1</span>])&#123;<span class=\"comment\">//最大值前移一位不满足而最小值后移一位满足</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Max_Per_Array(a,i,--j,p);<span class=\"comment\">//直接让最大值前移一位</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//最大值前移一位或最小值后移一位都不满足则分别前移和后移</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> ch_min,ch_max;</span><br><span class=\"line\">            ch_min = Max_Per_Array(a,++i,j,p);</span><br><span class=\"line\">            ch_max = Max_Per_Array(a,i,--j,p);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ch_min &gt; ch_max ? ch_min : ch_max;<span class=\"comment\">//返回最大元素个数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p><strong>代码2</strong><br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//优化双层循环方法，全部通过测试点</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> p;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%ld\"</span>,&amp;n,&amp;p);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> a[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%ld\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a,a+n);<span class=\"comment\">//升序排序</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_coun = <span class=\"number\">1</span>;<span class=\"comment\">//完美数列最多元素个数，至少1个</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + max_coun; j &lt; n; j++)&#123;<span class=\"comment\">//最大值从最小值位置加上当前完美数列最多元素个数处开始即可</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[j] &lt;= a[i] * p)&#123;<span class=\"comment\">//满足完美数列</span></span><br><span class=\"line\">                max_coun = j - i + <span class=\"number\">1</span>;<span class=\"comment\">//更新最多元素个数</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//不满足直接跳出循环，j再往后，最大值会更大，更不会满足</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,max_coun);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></p>\n<blockquote>\n<p>题目来源：PAT乙级1030<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"完美数列\"><a href=\"#完美数列\" class=\"headerlink\" title=\"完美数列\"></a><strong>完美数列</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一个正整数数列，和正整数 <em>p</em>，设这个数列中的最大值是 <em>M</em>，最小值是 <em>m</em>，如果 M ≤ mp，则称这个数列是完美数列。<br>现在给定参数 <em>p</em> 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入第一行给出两个正整数 <em>N</em> 和 <em>p</em>，其中 <em>N</em>（≤$10^5$）是输入的正整数的个数，<em>p</em>（≤$10^9$）是给定的参数。第二行给出 <em>N</em> 个正整数，每个数不超过 $10^9$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 8</span><br><span class=\"line\">2 3 20 4 5 1 6 7 8 9</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p><strong>方法一</strong>：递归方法，测试点4会超时</p>\n<p>注意参数p和数组a[]要定义成long或long long型，否则会导致测试点5不通过，想一下为什么？输入后先对数组a[]进行升序排序，然后递归调用函数Max_Per_Array()：</p>\n<ol>\n<li>终止条件：a[j] &lt;= p x a[i]，满足则直接返回j-i+1；</li>\n<li>递归条件：a[j] &gt; p x a[i]，先后判断<strong>最大值前移一位满足而最小值后移一位不满足</strong>和<strong>最大值前移一位不满足而最小值后移一位满足</strong>这两个条件是否满足，若满足，则只需进行相应的单个调用即可，若都不满足，则依次进行两个调用，返回最大的即可。</li>\n</ol>\n<p>此法思路很简单，但是，运行效率不高，提交时测试点4会超时，因此有下面更高效的方法。<br><strong>方法二</strong>：优化双层循环方法<br>先初始化完美数列最多元素个数，至少为1个；用双层循环，i从0开始依次递加作外层循环，a[i]为最小值，对于每一个i，j从i+max_coun开始，a[j]为最大值，判断是否满足完美数列的条件，若满足，则更新max_coun为当前完美数列的元素个数，即j-i+1，然后继续累加j继续判断直到跳出内层循环；若不满足，则直接跳出内存循环，因为若当前的j不满足，则后面的最大值更大，必不满足。<br>此法效率较高，不会出现超时。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><p><strong>代码1</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//递归方法，测试点4会超时</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max_Per_Array</span><span class=\"params\">(<span class=\"keyword\">long</span> a[],<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j,<span class=\"keyword\">long</span> p)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> p;<span class=\"comment\">//定义为long型</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%ld\"</span>,&amp;n,&amp;p);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> a[MAXN];<span class=\"comment\">//定义为long型</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%ld\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a,a+n);<span class=\"comment\">//升序排序</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_coun;</span><br><span class=\"line\">    max_coun = Max_Per_Array(a,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,p);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,max_coun);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//返回数组a[]从第i到第j个位置能构成完美数列的最大元素个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max_Per_Array</span><span class=\"params\">(<span class=\"keyword\">long</span> a[],<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j,<span class=\"keyword\">long</span> p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a[j] &lt;= p * a[i])&#123;<span class=\"comment\">//满足完美数列</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> j-i+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//不满足完美数列</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[j - <span class=\"number\">1</span>] &gt; p * a[i]&amp;&amp;a[j] &lt;= p * a[i + <span class=\"number\">1</span>])&#123;<span class=\"comment\">//最大值前移一位满足而最小值后移一位不满足</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Max_Per_Array(a,++i,j,p);<span class=\"comment\">//直接让最小值后移一位</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[j - <span class=\"number\">1</span>] &lt;= p * a[i]&amp;&amp;a[j] &gt; p * a[i + <span class=\"number\">1</span>])&#123;<span class=\"comment\">//最大值前移一位不满足而最小值后移一位满足</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Max_Per_Array(a,i,--j,p);<span class=\"comment\">//直接让最大值前移一位</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//最大值前移一位或最小值后移一位都不满足则分别前移和后移</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> ch_min,ch_max;</span><br><span class=\"line\">            ch_min = Max_Per_Array(a,++i,j,p);</span><br><span class=\"line\">            ch_max = Max_Per_Array(a,i,--j,p);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ch_min &gt; ch_max ? ch_min : ch_max;<span class=\"comment\">//返回最大元素个数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>代码2</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//优化双层循环方法，全部通过测试点</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> p;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%ld\"</span>,&amp;n,&amp;p);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> a[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%ld\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a,a+n);<span class=\"comment\">//升序排序</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_coun = <span class=\"number\">1</span>;<span class=\"comment\">//完美数列最多元素个数，至少1个</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + max_coun; j &lt; n; j++)&#123;<span class=\"comment\">//最大值从最小值位置加上当前完美数列最多元素个数处开始即可</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[j] &lt;= a[i] * p)&#123;<span class=\"comment\">//满足完美数列</span></span><br><span class=\"line\">                max_coun = j - i + <span class=\"number\">1</span>;<span class=\"comment\">//更新最多元素个数</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//不满足直接跳出循环，j再往后，最大值会更大，更不会满足</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,max_coun);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>题目来源：PAT乙级1030<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1011 || A+B 和 C（详解，C/C++示例，测试点分析）","date":"2019-08-16T02:19:21.000Z","mathjax":true,"_content":"\n\n# **A+B 和 C** \n\n## **题目描述**\n给定区间$ [−2^{31},2^{31}]$ 内的 3 个整数 *A*、*B* 和 *C*，请判断 *A*+*B* 是否大于 *C*。\n## **输入格式**\n输入第 1 行给出正整数 *T* (≤10)，是测试用例的个数。随后给出 *T* 组测试用例，每组占一行，顺序给出 *A*、*B* 和 *C*。整数间以空格分隔。\n## **输出格式**\n对每组测试用例，在一行中输出 `Case #X: true` 如果 *A*+*B*>*C*，否则输出 `Case #X: false`，其中 `X` 是测试用例的编号（从 1 开始）。\n\n## **输入样例**\n```null\n4\n1 2 3\n2 3 4\n2147483647 0 2147483646\n0 -2147483648 -2147483647\n```\n## **输出样例**\n```null\nCase #1: false\nCase #2: true\nCase #3: true\nCase #4: false\n```\n\n## 问题解决\n### 解题思想\n本题主要考察整型`int`和`long long`的取值范围，题中给定区间$ [−2^{31},2^{31}]$ ，而`int`型取整范围为$[−2^{31},2^{31}-1]$，因此不能用`int`，用`int`评测系统会报错，要用long long型。\n**注**：绝对值在$10^9$以内的整数都可以定义出`int`型，$10^9$以上的整数定义成`long long`型。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    long long a,b,c;\n    int t,i = 1;\n    scanf(\"%d\",&t);\n    while(t--){\n        //注意long long型的格式控制符为%lld\n        scanf(\"%lld%lld%lld\",&a,&b,&c);\n        if(a + b > c){\n            printf(\"Case #%d: true\\n\",i);\n        }\n        else{\n            printf(\"Case #%d: false\\n\",i);\n        }\n        i++;\n    }\n    return 0;\n}\n```\n\n> 题目来源：PAT乙级1011\n> 作者：HOU, Qiming\n> 单位：浙江大学","source":"_posts/pat乙级1011.md","raw":"---\ntitle: PAT乙级1011 || A+B 和 C（详解，C/C++示例，测试点分析）\ndate: 2019-08-16 10:19:21\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n\n# **A+B 和 C** \n\n## **题目描述**\n给定区间$ [−2^{31},2^{31}]$ 内的 3 个整数 *A*、*B* 和 *C*，请判断 *A*+*B* 是否大于 *C*。\n## **输入格式**\n输入第 1 行给出正整数 *T* (≤10)，是测试用例的个数。随后给出 *T* 组测试用例，每组占一行，顺序给出 *A*、*B* 和 *C*。整数间以空格分隔。\n## **输出格式**\n对每组测试用例，在一行中输出 `Case #X: true` 如果 *A*+*B*>*C*，否则输出 `Case #X: false`，其中 `X` 是测试用例的编号（从 1 开始）。\n\n## **输入样例**\n```null\n4\n1 2 3\n2 3 4\n2147483647 0 2147483646\n0 -2147483648 -2147483647\n```\n## **输出样例**\n```null\nCase #1: false\nCase #2: true\nCase #3: true\nCase #4: false\n```\n\n## 问题解决\n### 解题思想\n本题主要考察整型`int`和`long long`的取值范围，题中给定区间$ [−2^{31},2^{31}]$ ，而`int`型取整范围为$[−2^{31},2^{31}-1]$，因此不能用`int`，用`int`评测系统会报错，要用long long型。\n**注**：绝对值在$10^9$以内的整数都可以定义出`int`型，$10^9$以上的整数定义成`long long`型。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    long long a,b,c;\n    int t,i = 1;\n    scanf(\"%d\",&t);\n    while(t--){\n        //注意long long型的格式控制符为%lld\n        scanf(\"%lld%lld%lld\",&a,&b,&c);\n        if(a + b > c){\n            printf(\"Case #%d: true\\n\",i);\n        }\n        else{\n            printf(\"Case #%d: false\\n\",i);\n        }\n        i++;\n    }\n    return 0;\n}\n```\n\n> 题目来源：PAT乙级1011\n> 作者：HOU, Qiming\n> 单位：浙江大学","slug":"pat乙级1011","published":1,"updated":"2019-08-16T02:33:42.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwff1001yfk0r82mr5u0u","content":"<h1 id=\"A-B-和-C\"><a href=\"#A-B-和-C\" class=\"headerlink\" title=\"A+B 和 C\"></a><strong>A+B 和 C</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定区间$ [−2^{31},2^{31}]$ 内的 3 个整数 <em>A</em>、<em>B</em> 和 <em>C</em>，请判断 <em>A</em>+<em>B</em> 是否大于 <em>C</em>。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入第 1 行给出正整数 <em>T</em> (≤10)，是测试用例的个数。随后给出 <em>T</em> 组测试用例，每组占一行，顺序给出 <em>A</em>、<em>B</em> 和 <em>C</em>。整数间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每组测试用例，在一行中输出 <code>Case #X: true</code> 如果 <em>A</em>+<em>B</em>&gt;<em>C</em>，否则输出 <code>Case #X: false</code>，其中 <code>X</code> 是测试用例的编号（从 1 开始）。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">1 2 3</span><br><span class=\"line\">2 3 4</span><br><span class=\"line\">2147483647 0 2147483646</span><br><span class=\"line\">0 -2147483648 -2147483647</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Case #1: false</span><br><span class=\"line\">Case #2: true</span><br><span class=\"line\">Case #3: true</span><br><span class=\"line\">Case #4: false</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题主要考察整型<code>int</code>和<code>long long</code>的取值范围，题中给定区间$ [−2^{31},2^{31}]$ ，而<code>int</code>型取整范围为$[−2^{31},2^{31}-1]$，因此不能用<code>int</code>，用<code>int</code>评测系统会报错，要用long long型。<br><strong>注</strong>：绝对值在$10^9$以内的整数都可以定义出<code>int</code>型，$10^9$以上的整数定义成<code>long long</code>型。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t,i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意long long型的格式控制符为%lld</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld%lld%lld\"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a + b &gt; c)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d: true\\n\"</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d: false\\n\"</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1011<br>作者：HOU, Qiming<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"A-B-和-C\"><a href=\"#A-B-和-C\" class=\"headerlink\" title=\"A+B 和 C\"></a><strong>A+B 和 C</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定区间$ [−2^{31},2^{31}]$ 内的 3 个整数 <em>A</em>、<em>B</em> 和 <em>C</em>，请判断 <em>A</em>+<em>B</em> 是否大于 <em>C</em>。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入第 1 行给出正整数 <em>T</em> (≤10)，是测试用例的个数。随后给出 <em>T</em> 组测试用例，每组占一行，顺序给出 <em>A</em>、<em>B</em> 和 <em>C</em>。整数间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每组测试用例，在一行中输出 <code>Case #X: true</code> 如果 <em>A</em>+<em>B</em>&gt;<em>C</em>，否则输出 <code>Case #X: false</code>，其中 <code>X</code> 是测试用例的编号（从 1 开始）。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">1 2 3</span><br><span class=\"line\">2 3 4</span><br><span class=\"line\">2147483647 0 2147483646</span><br><span class=\"line\">0 -2147483648 -2147483647</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Case #1: false</span><br><span class=\"line\">Case #2: true</span><br><span class=\"line\">Case #3: true</span><br><span class=\"line\">Case #4: false</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题主要考察整型<code>int</code>和<code>long long</code>的取值范围，题中给定区间$ [−2^{31},2^{31}]$ ，而<code>int</code>型取整范围为$[−2^{31},2^{31}-1]$，因此不能用<code>int</code>，用<code>int</code>评测系统会报错，要用long long型。<br><strong>注</strong>：绝对值在$10^9$以内的整数都可以定义出<code>int</code>型，$10^9$以上的整数定义成<code>long long</code>型。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t,i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意long long型的格式控制符为%lld</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld%lld%lld\"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a + b &gt; c)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d: true\\n\"</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case #%d: false\\n\"</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1011<br>作者：HOU, Qiming<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1012 || 数字分类（详解，C/C++示例，测试点分析）","date":"2019-08-16T02:19:45.000Z","_content":"\n# **数字分类**\n\n## **题目描述**\n给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：\n\n- *A*1 = 能被 5 整除的数字中所有偶数的和；\n- *A*2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 *n*1−*n*2+*n*3−*n*4⋯；\n- *A*3 = 被 5 除后余 2 的数字的个数；\n- *A*4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；\n- *A*5 = 被 5 除后余 4 的数字中最大数字。\n\n## **输入格式**\n每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N*，随后给出 *N* 个不超过 1000 的待分类的正整数。数字间以空格分隔。\n## **输出格式**\n对给定的 *N* 个正整数，按题目要求计算 *A*1~*A*5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。\n\n若其中某一类数字不存在，则在相应位置输出 `N`。\n\n## **输入样例**\n```null\n13 1 2 3 4 5 6 7 8 9 10 20 16 18\n```\n## **输出样例**\n```null\n30 11 2 9.7 9\n```\n\n## 问题解决\n### 解题思想\n定义数组A[5]和flag[5]，用A[0]~A[4]存下各类要求的计算结果，用flag[0]~flag[4]来标记某类数字是否存在。在一次对数组a[MAXN]的遍历中对5种情况分别进行统计，最后按格式要求输出即可。注意，除A[3]外，其它4种情况输出格式相同，可统一处理，A[3]要特殊处理。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#define MAXN 1001\n\nint main()\n{\n    int n,i,j = 1,count = 0,a[MAXN];\n    //A[0]~A[4]存下各类要求的计算结果\n    int A[5] = {0};\n    //用flag[0]~flag[4]来标记某类数字是否存在\n    int flag[5] = {0};\n    scanf(\"%d\",&n);\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&a[i]);\n    }\n    for(i = 0; i < n; i++){\n        if((a[i] % 5 == 0)&&(a[i] % 2 == 0)){\n            A[0] += a[i];\n            flag[0] = 1;\n        }\n        else if(a[i] % 5 == 1){\n            //用j辅助进行交错求和\n            A[1] += (j * a[i]);\n            j = -j;\n            flag[1] = 1;\n        }\n        else if(a[i] % 5 == 2){\n            A[2]++;\n            flag[2] = 1;\n        }\n        else if(a[i] % 5 == 3){\n            A[3] += a[i];\n            count++;\n            flag[3] = 1;\n        }\n        else if(a[i] % 5 == 4){\n            if(flag[4] == 0){\n                A[4] = a[i];\n            }\n            else{\n                if(A[4] < a[i]){\n                    A[4] = a[i];\n                }\n            }\n            flag[4] = 1;\n        }\n    }\n    for(i = 0; i < 5; i++){\n        //除A[3]部分要求用浮点形式输出，其它均为整型格式\n        if((flag[i] == 1)&&(i != 3)){\n            printf(\"%d\",A[i]);\n        }\n        else if(flag[i] == 0){//不存在时输出N\n            printf(\"N\");\n        }\n        if((i == 3)&&(flag[i] == 1)){\n            printf(\"%.1f\",(double)(1.0 * A[3] / count));\n        }\n        if(i != 4){\n            printf(\" \");\n        }\n    }\n    return 0;\n}\n```\n> 题目来源：PAT乙级1012\n> 作者：CHEN, Yue\n> 单位：浙江大学","source":"_posts/pat乙级1012.md","raw":"---\ntitle: PAT乙级1012 || 数字分类（详解，C/C++示例，测试点分析）\ndate: 2019-08-16 10:19:45\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **数字分类**\n\n## **题目描述**\n给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：\n\n- *A*1 = 能被 5 整除的数字中所有偶数的和；\n- *A*2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 *n*1−*n*2+*n*3−*n*4⋯；\n- *A*3 = 被 5 除后余 2 的数字的个数；\n- *A*4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；\n- *A*5 = 被 5 除后余 4 的数字中最大数字。\n\n## **输入格式**\n每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N*，随后给出 *N* 个不超过 1000 的待分类的正整数。数字间以空格分隔。\n## **输出格式**\n对给定的 *N* 个正整数，按题目要求计算 *A*1~*A*5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。\n\n若其中某一类数字不存在，则在相应位置输出 `N`。\n\n## **输入样例**\n```null\n13 1 2 3 4 5 6 7 8 9 10 20 16 18\n```\n## **输出样例**\n```null\n30 11 2 9.7 9\n```\n\n## 问题解决\n### 解题思想\n定义数组A[5]和flag[5]，用A[0]~A[4]存下各类要求的计算结果，用flag[0]~flag[4]来标记某类数字是否存在。在一次对数组a[MAXN]的遍历中对5种情况分别进行统计，最后按格式要求输出即可。注意，除A[3]外，其它4种情况输出格式相同，可统一处理，A[3]要特殊处理。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#define MAXN 1001\n\nint main()\n{\n    int n,i,j = 1,count = 0,a[MAXN];\n    //A[0]~A[4]存下各类要求的计算结果\n    int A[5] = {0};\n    //用flag[0]~flag[4]来标记某类数字是否存在\n    int flag[5] = {0};\n    scanf(\"%d\",&n);\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&a[i]);\n    }\n    for(i = 0; i < n; i++){\n        if((a[i] % 5 == 0)&&(a[i] % 2 == 0)){\n            A[0] += a[i];\n            flag[0] = 1;\n        }\n        else if(a[i] % 5 == 1){\n            //用j辅助进行交错求和\n            A[1] += (j * a[i]);\n            j = -j;\n            flag[1] = 1;\n        }\n        else if(a[i] % 5 == 2){\n            A[2]++;\n            flag[2] = 1;\n        }\n        else if(a[i] % 5 == 3){\n            A[3] += a[i];\n            count++;\n            flag[3] = 1;\n        }\n        else if(a[i] % 5 == 4){\n            if(flag[4] == 0){\n                A[4] = a[i];\n            }\n            else{\n                if(A[4] < a[i]){\n                    A[4] = a[i];\n                }\n            }\n            flag[4] = 1;\n        }\n    }\n    for(i = 0; i < 5; i++){\n        //除A[3]部分要求用浮点形式输出，其它均为整型格式\n        if((flag[i] == 1)&&(i != 3)){\n            printf(\"%d\",A[i]);\n        }\n        else if(flag[i] == 0){//不存在时输出N\n            printf(\"N\");\n        }\n        if((i == 3)&&(flag[i] == 1)){\n            printf(\"%.1f\",(double)(1.0 * A[3] / count));\n        }\n        if(i != 4){\n            printf(\" \");\n        }\n    }\n    return 0;\n}\n```\n> 题目来源：PAT乙级1012\n> 作者：CHEN, Yue\n> 单位：浙江大学","slug":"pat乙级1012","published":1,"updated":"2019-08-16T02:34:06.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwff40021fk0riqxa6hc7","content":"<h1 id=\"数字分类\"><a href=\"#数字分类\" class=\"headerlink\" title=\"数字分类\"></a><strong>数字分类</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：</p>\n<ul>\n<li><em>A</em>1 = 能被 5 整除的数字中所有偶数的和；</li>\n<li><em>A</em>2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 <em>n</em>1−<em>n</em>2+<em>n</em>3−<em>n</em>4⋯；</li>\n<li><em>A</em>3 = 被 5 除后余 2 的数字的个数；</li>\n<li><em>A</em>4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；</li>\n<li><em>A</em>5 = 被 5 除后余 4 的数字中最大数字。</li>\n</ul>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 <em>N</em>，随后给出 <em>N</em> 个不超过 1000 的待分类的正整数。数字间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对给定的 <em>N</em> 个正整数，按题目要求计算 <em>A</em>1~<em>A</em>5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p>\n<p>若其中某一类数字不存在，则在相应位置输出 <code>N</code>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13 1 2 3 4 5 6 7 8 9 10 20 16 18</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30 11 2 9.7 9</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>定义数组A[5]和flag[5]，用A[0]~A[4]存下各类要求的计算结果，用flag[0]~flag[4]来标记某类数字是否存在。在一次对数组a[MAXN]的遍历中对5种情况分别进行统计，最后按格式要求输出即可。注意，除A[3]外，其它4种情况输出格式相同，可统一处理，A[3]要特殊处理。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,j = <span class=\"number\">1</span>,count = <span class=\"number\">0</span>,a[MAXN];</span><br><span class=\"line\">    <span class=\"comment\">//A[0]~A[4]存下各类要求的计算结果</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> A[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//用flag[0]~flag[4]来标记某类数字是否存在</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((a[i] % <span class=\"number\">5</span> == <span class=\"number\">0</span>)&amp;&amp;(a[i] % <span class=\"number\">2</span> == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            A[<span class=\"number\">0</span>] += a[i];</span><br><span class=\"line\">            flag[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] % <span class=\"number\">5</span> == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//用j辅助进行交错求和</span></span><br><span class=\"line\">            A[<span class=\"number\">1</span>] += (j * a[i]);</span><br><span class=\"line\">            j = -j;</span><br><span class=\"line\">            flag[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] % <span class=\"number\">5</span> == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            A[<span class=\"number\">2</span>]++;</span><br><span class=\"line\">            flag[<span class=\"number\">2</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] % <span class=\"number\">5</span> == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">            A[<span class=\"number\">3</span>] += a[i];</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            flag[<span class=\"number\">3</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] % <span class=\"number\">5</span> == <span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag[<span class=\"number\">4</span>] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                A[<span class=\"number\">4</span>] = a[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(A[<span class=\"number\">4</span>] &lt; a[i])&#123;</span><br><span class=\"line\">                    A[<span class=\"number\">4</span>] = a[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            flag[<span class=\"number\">4</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//除A[3]部分要求用浮点形式输出，其它均为整型格式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((flag[i] == <span class=\"number\">1</span>)&amp;&amp;(i != <span class=\"number\">3</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,A[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flag[i] == <span class=\"number\">0</span>)&#123;<span class=\"comment\">//不存在时输出N</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"N\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((i == <span class=\"number\">3</span>)&amp;&amp;(flag[i] == <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.1f\"</span>,(<span class=\"keyword\">double</span>)(<span class=\"number\">1.0</span> * A[<span class=\"number\">3</span>] / count));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i != <span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1012<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数字分类\"><a href=\"#数字分类\" class=\"headerlink\" title=\"数字分类\"></a><strong>数字分类</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：</p>\n<ul>\n<li><em>A</em>1 = 能被 5 整除的数字中所有偶数的和；</li>\n<li><em>A</em>2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 <em>n</em>1−<em>n</em>2+<em>n</em>3−<em>n</em>4⋯；</li>\n<li><em>A</em>3 = 被 5 除后余 2 的数字的个数；</li>\n<li><em>A</em>4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；</li>\n<li><em>A</em>5 = 被 5 除后余 4 的数字中最大数字。</li>\n</ul>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 <em>N</em>，随后给出 <em>N</em> 个不超过 1000 的待分类的正整数。数字间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对给定的 <em>N</em> 个正整数，按题目要求计算 <em>A</em>1~<em>A</em>5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p>\n<p>若其中某一类数字不存在，则在相应位置输出 <code>N</code>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13 1 2 3 4 5 6 7 8 9 10 20 16 18</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30 11 2 9.7 9</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>定义数组A[5]和flag[5]，用A[0]~A[4]存下各类要求的计算结果，用flag[0]~flag[4]来标记某类数字是否存在。在一次对数组a[MAXN]的遍历中对5种情况分别进行统计，最后按格式要求输出即可。注意，除A[3]外，其它4种情况输出格式相同，可统一处理，A[3]要特殊处理。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,j = <span class=\"number\">1</span>,count = <span class=\"number\">0</span>,a[MAXN];</span><br><span class=\"line\">    <span class=\"comment\">//A[0]~A[4]存下各类要求的计算结果</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> A[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//用flag[0]~flag[4]来标记某类数字是否存在</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((a[i] % <span class=\"number\">5</span> == <span class=\"number\">0</span>)&amp;&amp;(a[i] % <span class=\"number\">2</span> == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            A[<span class=\"number\">0</span>] += a[i];</span><br><span class=\"line\">            flag[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] % <span class=\"number\">5</span> == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//用j辅助进行交错求和</span></span><br><span class=\"line\">            A[<span class=\"number\">1</span>] += (j * a[i]);</span><br><span class=\"line\">            j = -j;</span><br><span class=\"line\">            flag[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] % <span class=\"number\">5</span> == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            A[<span class=\"number\">2</span>]++;</span><br><span class=\"line\">            flag[<span class=\"number\">2</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] % <span class=\"number\">5</span> == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">            A[<span class=\"number\">3</span>] += a[i];</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            flag[<span class=\"number\">3</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i] % <span class=\"number\">5</span> == <span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag[<span class=\"number\">4</span>] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                A[<span class=\"number\">4</span>] = a[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(A[<span class=\"number\">4</span>] &lt; a[i])&#123;</span><br><span class=\"line\">                    A[<span class=\"number\">4</span>] = a[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            flag[<span class=\"number\">4</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//除A[3]部分要求用浮点形式输出，其它均为整型格式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((flag[i] == <span class=\"number\">1</span>)&amp;&amp;(i != <span class=\"number\">3</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,A[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flag[i] == <span class=\"number\">0</span>)&#123;<span class=\"comment\">//不存在时输出N</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"N\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((i == <span class=\"number\">3</span>)&amp;&amp;(flag[i] == <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.1f\"</span>,(<span class=\"keyword\">double</span>)(<span class=\"number\">1.0</span> * A[<span class=\"number\">3</span>] / count));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i != <span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1012<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1013 || 数素数（详解，C/C++示例，测试点分析）","date":"2019-08-16T02:19:53.000Z","mathjax":true,"_content":"\n# **数素数**\n## **题目描述**\n令 P(i) 表示第 *i* 个素数。现任给两个正整数 *M*≤*N*≤$10^4$，请输出 P(M)到 P(N)的所有素数。\n## **输入格式**\n输入在一行中给出 *M* 和 *N*，其间以空格分隔。\n## **输出格式**\n输出从P(M)到P(N)的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。\n## **输入样例**\n```null\n5 27\n```\n## **输出样例**\n```null\n11 13 17 19 23 29 31 37 41 43\n47 53 59 61 67 71 73 79 83 89\n97 101 103\n```\n\n## 问题解决\n### 解题思想\n此题的关键在于输出格式的控制。单独设置一个变量j记录刚输出的素数是已输出素数的第几个，当j是10的倍数时（即j可以被10整除）输出换行。设置一个变量s来控制同一行各数之间的空格问题，这一方式在之前的题目中很常见，对于本题，注意每次换行时s应重置一下。还有一点要提醒大家，我一开始在main()函数中的for循环外添加了一行\n\n```c\nprintf(\"\\n\");\n```\n\n导致代码评测时有一个测试点没有通过，删去后全部通过。本人分析应为：若最后一行若恰好输出10个整数会导致重复换行问题，如果大家有确定的原因，欢迎大家留言指正，谢谢！\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <math.h>\nint IsPrime(int t);\n\nint main()\n{\n    int m,n,i,count = 0,j = 0,s = 0;\n    //count记录当前为第几个素数\n    //j记录已经输出的素数的个数\n    //s控制输出格式，每次换行时s都要更新为0\n    scanf(\"%d%d\",&m,&n);\n    for(i = 2; count <= n; i++){\n        if(IsPrime(i)){\n            count++;\n            if((count >= m)&&(count <= n)){\n                if(s == 0){\n                    printf(\"%d\",i);\n                    s = 1;\n                }\n                else{\n                    printf(\" %d\",i);\n                }\n                j++;\n                if(j % 10 == 0){\n                    printf(\"\\n\");\n                    s = 0;//s重新更新为0\n                }\n            }\n        }\n    }\n    return 0;\n}\n//判断t是否为素数，是素数则返回1，否则返回0\nint IsPrime(int t)\n{\n    int i,flag = 0;\n    for(i = 2; i <= sqrt(t); i++){\n        if(t % i == 0){\n            flag = 1;\n            break;\n        }\n    }\n    if(flag == 0){\n        return 1;\n    }\n    else{\n        return 0;\n    }\n}\n```\n>题目来源：PAT乙级1013\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat乙级1013.md","raw":"---\ntitle: PAT乙级1013 || 数素数（详解，C/C++示例，测试点分析）\ndate: 2019-08-16 10:19:53\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **数素数**\n## **题目描述**\n令 P(i) 表示第 *i* 个素数。现任给两个正整数 *M*≤*N*≤$10^4$，请输出 P(M)到 P(N)的所有素数。\n## **输入格式**\n输入在一行中给出 *M* 和 *N*，其间以空格分隔。\n## **输出格式**\n输出从P(M)到P(N)的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。\n## **输入样例**\n```null\n5 27\n```\n## **输出样例**\n```null\n11 13 17 19 23 29 31 37 41 43\n47 53 59 61 67 71 73 79 83 89\n97 101 103\n```\n\n## 问题解决\n### 解题思想\n此题的关键在于输出格式的控制。单独设置一个变量j记录刚输出的素数是已输出素数的第几个，当j是10的倍数时（即j可以被10整除）输出换行。设置一个变量s来控制同一行各数之间的空格问题，这一方式在之前的题目中很常见，对于本题，注意每次换行时s应重置一下。还有一点要提醒大家，我一开始在main()函数中的for循环外添加了一行\n\n```c\nprintf(\"\\n\");\n```\n\n导致代码评测时有一个测试点没有通过，删去后全部通过。本人分析应为：若最后一行若恰好输出10个整数会导致重复换行问题，如果大家有确定的原因，欢迎大家留言指正，谢谢！\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <math.h>\nint IsPrime(int t);\n\nint main()\n{\n    int m,n,i,count = 0,j = 0,s = 0;\n    //count记录当前为第几个素数\n    //j记录已经输出的素数的个数\n    //s控制输出格式，每次换行时s都要更新为0\n    scanf(\"%d%d\",&m,&n);\n    for(i = 2; count <= n; i++){\n        if(IsPrime(i)){\n            count++;\n            if((count >= m)&&(count <= n)){\n                if(s == 0){\n                    printf(\"%d\",i);\n                    s = 1;\n                }\n                else{\n                    printf(\" %d\",i);\n                }\n                j++;\n                if(j % 10 == 0){\n                    printf(\"\\n\");\n                    s = 0;//s重新更新为0\n                }\n            }\n        }\n    }\n    return 0;\n}\n//判断t是否为素数，是素数则返回1，否则返回0\nint IsPrime(int t)\n{\n    int i,flag = 0;\n    for(i = 2; i <= sqrt(t); i++){\n        if(t % i == 0){\n            flag = 1;\n            break;\n        }\n    }\n    if(flag == 0){\n        return 1;\n    }\n    else{\n        return 0;\n    }\n}\n```\n>题目来源：PAT乙级1013\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat乙级1013","published":1,"updated":"2019-08-16T02:37:11.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwffe0024fk0rih19i3xq","content":"<h1 id=\"数素数\"><a href=\"#数素数\" class=\"headerlink\" title=\"数素数\"></a><strong>数素数</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>令 P(i) 表示第 <em>i</em> 个素数。现任给两个正整数 <em>M</em>≤<em>N</em>≤$10^4$，请输出 P(M)到 P(N)的所有素数。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行中给出 <em>M</em> 和 <em>N</em>，其间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>输出从P(M)到P(N)的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 27</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11 13 17 19 23 29 31 37 41 43</span><br><span class=\"line\">47 53 59 61 67 71 73 79 83 89</span><br><span class=\"line\">97 101 103</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题的关键在于输出格式的控制。单独设置一个变量j记录刚输出的素数是已输出素数的第几个，当j是10的倍数时（即j可以被10整除）输出换行。设置一个变量s来控制同一行各数之间的空格问题，这一方式在之前的题目中很常见，对于本题，注意每次换行时s应重置一下。还有一点要提醒大家，我一开始在main()函数中的for循环外添加了一行</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br></pre></td></tr></table></figure></div>\n<p>导致代码评测时有一个测试点没有通过，删去后全部通过。本人分析应为：若最后一行若恰好输出10个整数会导致重复换行问题，如果大家有确定的原因，欢迎大家留言指正，谢谢！</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">IsPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m,n,i,count = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>,s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//count记录当前为第几个素数</span></span><br><span class=\"line\">    <span class=\"comment\">//j记录已经输出的素数的个数</span></span><br><span class=\"line\">    <span class=\"comment\">//s控制输出格式，每次换行时s都要更新为0</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;m,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">2</span>; count &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(IsPrime(i))&#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((count &gt;= m)&amp;&amp;(count &lt;= n))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i);</span><br><span class=\"line\">                    s = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j % <span class=\"number\">10</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">                    s = <span class=\"number\">0</span>;<span class=\"comment\">//s重新更新为0</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//判断t是否为素数，是素数则返回1，否则返回0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">IsPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">2</span>; i &lt;= <span class=\"built_in\">sqrt</span>(t); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1013<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数素数\"><a href=\"#数素数\" class=\"headerlink\" title=\"数素数\"></a><strong>数素数</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>令 P(i) 表示第 <em>i</em> 个素数。现任给两个正整数 <em>M</em>≤<em>N</em>≤$10^4$，请输出 P(M)到 P(N)的所有素数。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行中给出 <em>M</em> 和 <em>N</em>，其间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>输出从P(M)到P(N)的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 27</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11 13 17 19 23 29 31 37 41 43</span><br><span class=\"line\">47 53 59 61 67 71 73 79 83 89</span><br><span class=\"line\">97 101 103</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题的关键在于输出格式的控制。单独设置一个变量j记录刚输出的素数是已输出素数的第几个，当j是10的倍数时（即j可以被10整除）输出换行。设置一个变量s来控制同一行各数之间的空格问题，这一方式在之前的题目中很常见，对于本题，注意每次换行时s应重置一下。还有一点要提醒大家，我一开始在main()函数中的for循环外添加了一行</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br></pre></td></tr></table></figure>\n<p>导致代码评测时有一个测试点没有通过，删去后全部通过。本人分析应为：若最后一行若恰好输出10个整数会导致重复换行问题，如果大家有确定的原因，欢迎大家留言指正，谢谢！</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">IsPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m,n,i,count = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>,s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//count记录当前为第几个素数</span></span><br><span class=\"line\">    <span class=\"comment\">//j记录已经输出的素数的个数</span></span><br><span class=\"line\">    <span class=\"comment\">//s控制输出格式，每次换行时s都要更新为0</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;m,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">2</span>; count &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(IsPrime(i))&#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((count &gt;= m)&amp;&amp;(count &lt;= n))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i);</span><br><span class=\"line\">                    s = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j % <span class=\"number\">10</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">                    s = <span class=\"number\">0</span>;<span class=\"comment\">//s重新更新为0</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//判断t是否为素数，是素数则返回1，否则返回0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">IsPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">2</span>; i &lt;= <span class=\"built_in\">sqrt</span>(t); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t % i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1013<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1014 || 福尔摩斯的约会（详解，C/C++示例，测试点分析）","date":"2019-08-16T02:19:58.000Z","mathjax":true,"_content":"\n# **福尔摩斯的约会**\n## 题目描述\n大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。\n## 输入格式\n输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。\n## 输出格式\n在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。\n## 输入样例\n```null\n3485djDkxh4hhGE \n2984akDfkkkkggEdsb \ns&hgsfdk \nd&Hyscvnm\n```\n## 输出样例\n```null\nTHU 14:04\n```\n\n## 问题解决：\n### 解题思想及误点剖析\n此题难点在于理解题意，有三个重要问题需要我们明确：\n\n* **第 1 对相同的大写英文字母**，注意是大写英文字母\n* **第 2 对相同的字符**，注意由后面的叙述可知，第二对相同的字符应是在第一对相同的大写英文字母基础上的第二对，而且必须是数字字符或大写的英文字母\n* **第 1 对相同的英文字母**，注意此处要求是英文字母，大写小写均可，但是，相等时必须对应为大写或小写（比如`a`与`a`相等，`A`与`A`相等，但`a`与`A`不相等）\n\n以上3个重要问题在实现与时间对应时应当注意以下几点：\n1. **第 1 对相同的大写英文字母**的字母表顺序i对应星期i（比如A的字母表顺序为1，其对应星期一），我们知道一周也就7天，因此**第 1 对相同的大写英文字母**的字母范围必须是`A~G`，注意如果在代码的if条件中，寻找**第 1 对相同的大写英文字母**的条件是`str[0][i] >= 'A'&&str[0][i] <= 'G'`则导致评测不通过（某个测试点答案错误）\n2. **第 2 对相同的字符**与小时的对应为：一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示。注意判断大写字母时，范围一定为`A~N`\n3. **第 1 对相同的英文字母**，范围是`A~Z`或`a~z`\n4. 还要特别注意在输出小时和分钟时，小于10的数字前要补0。这里，我用的是格式控制符`%02d`，`%02d`中`2`的含义为：输出宽度为2，`0`的含义为：宽度不足2时用0填充\n\n**注**：如果大家是在牛客网的评测系统提交代码，则条件没有那么多限制，大写字母的范围都用`A~Z`也不会出错。\n  我在书写代码时产生了如下错误，包括一些低级错误。比如while循环内少了i++，输出格式控制等错误。最后，请大家看一下下面的这个程序，`代码1`在PAT评测系统评测时有一个测试点不通过，`代码2`是通过的(`代码1`与`代码2`的差别已在代码中标出)。请大家思考一下是为什么？\n\n`代码1`\n```c\n#include <stdio.h>\n#define MAXN 61\n//定义一个存放星期字符的字符数组，以便按序号输出星期\nchar week[7][4] = {\"MON\",\"TUE\",\"WED\",\"THU\",\"FRI\",\"SAT\",\"SUN\"};\nint main()\n{\n    char str[4][MAXN],first_capital;\n    int i,num,hour,flag = 0;//flag标记第一个相同大写字母是否已找到\n    //输入4个字符串\n    for(i = 0; i < 4; i++){\n        gets(str[i]);\n    }\n    i = 0;\n    //顺次查找前两个字符串中第一个相同的大写字母\n    while(str[0][i] != '\\0'&&str[1][i] != '\\0'){\n        if(str[0][i] == str[1][i]){\n            //还未找到第一个相同大写英文字母\n            if((str[0][i] >= 'A')&&(str[0][i] <= 'G')&&(!flag)){\n                first_capital = str[0][i];\n                flag = 1;\n            }\n            //已经找到第一个相同大写英文字母\n            else if(flag){\n                if(str[0][i] >= '0'&&str[0][i] <= '9'){\n                    hour = str[0][i] - '0';\n                }\n                else if(str[0][i] >= 'A'&&str[0][i] <= 'N'){\n                    hour = str[0][i] - 'A' + 10;\n                }\n                break;//此处与代码2有差别\n            }\n        }\n        i++;\n    }\n    num = first_capital - 'A';\n    printf(\"%s\",week[num]);\n    i = 0;//注意i要更新为0\n    //分钟确定，用相同英文字母的下标确定，\n    //注意一定是英文字母（大写相等或小写相等均可）\n    while(str[2][i] != '\\0'&&str[3][i] != '\\0'){\n        if(str[2][i] == str[3][i]){\n            if((str[2][i] >= 'A'&&str[2][i] <= 'Z')\n               ||(str[2][i] >= 'a'&&str[2][i] <= 'z')){\n                break;\n            }\n        }\n        i++;\n    }\n    printf(\" %02d:%02d\",hour,i);\n    return 0;\n}\n\n```\n### 代码示例（C语言）\n\n`代码2`\n\n```c\n#include <stdio.h>\n#define MAXN 61\n//定义一个存放星期字符的字符数组，以便按序号输出星期\nchar week[7][4] = {\"MON\",\"TUE\",\"WED\",\"THU\",\"FRI\",\"SAT\",\"SUN\"};\nint main()\n{\n    char str[4][MAXN],first_capital;\n    int i,num,hour,flag = 0;//flag标记第一个相同大写字母是否已找到\n    //输入4个字符串\n    for(i = 0; i < 4; i++){\n        gets(str[i]);\n    }\n    i = 0;\n    //顺次查找前两个字符串中第一个相同的大写字母\n    while(str[0][i] != '\\0'&&str[1][i] != '\\0'){\n        if(str[0][i] == str[1][i]){\n            //还未找到第一个相同大写英文字母\n            if((str[0][i] >= 'A')&&(str[0][i] <= 'G')&&(!flag)){\n                first_capital = str[0][i];\n                flag = 1;\n            }\n            //已经找到第一个相同大写英文字母\n            else if(flag){\n                if(str[0][i] >= '0'&&str[0][i] <= '9'){\n                    hour = str[0][i] - '0';\n                    break;//此处与代码1有差别\n                }\n                else if(str[0][i] >= 'A'&&str[0][i] <= 'N'){\n                    hour = str[0][i] - 'A' + 10;\n                    break;//此处与代码1有差别\n                }\n            }\n        }\n        i++;\n    }\n    num = first_capital - 'A';\n    printf(\"%s\",week[num]);\n    i = 0;//注意i要更新为0\n    //分钟确定，用相同英文字母的下标确定，\n    //注意一定是英文字母（大写相等或小写相等均可）\n    while(str[2][i] != '\\0'&&str[3][i] != '\\0'){\n        if(str[2][i] == str[3][i]){\n            if((str[2][i] >= 'A'&&str[2][i] <= 'Z')\n               ||(str[2][i] >= 'a'&&str[2][i] <= 'z')){\n                break;\n            }\n        }\n        i++;\n    }\n    printf(\" %02d:%02d\",hour,i);\n    return 0;\n}\n```\n>题目来源：PAT乙级1014\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat乙级1014.md","raw":"---\ntitle: PAT乙级1014 || 福尔摩斯的约会（详解，C/C++示例，测试点分析）\ndate: 2019-08-16 10:19:58\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **福尔摩斯的约会**\n## 题目描述\n大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。\n## 输入格式\n输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。\n## 输出格式\n在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。\n## 输入样例\n```null\n3485djDkxh4hhGE \n2984akDfkkkkggEdsb \ns&hgsfdk \nd&Hyscvnm\n```\n## 输出样例\n```null\nTHU 14:04\n```\n\n## 问题解决：\n### 解题思想及误点剖析\n此题难点在于理解题意，有三个重要问题需要我们明确：\n\n* **第 1 对相同的大写英文字母**，注意是大写英文字母\n* **第 2 对相同的字符**，注意由后面的叙述可知，第二对相同的字符应是在第一对相同的大写英文字母基础上的第二对，而且必须是数字字符或大写的英文字母\n* **第 1 对相同的英文字母**，注意此处要求是英文字母，大写小写均可，但是，相等时必须对应为大写或小写（比如`a`与`a`相等，`A`与`A`相等，但`a`与`A`不相等）\n\n以上3个重要问题在实现与时间对应时应当注意以下几点：\n1. **第 1 对相同的大写英文字母**的字母表顺序i对应星期i（比如A的字母表顺序为1，其对应星期一），我们知道一周也就7天，因此**第 1 对相同的大写英文字母**的字母范围必须是`A~G`，注意如果在代码的if条件中，寻找**第 1 对相同的大写英文字母**的条件是`str[0][i] >= 'A'&&str[0][i] <= 'G'`则导致评测不通过（某个测试点答案错误）\n2. **第 2 对相同的字符**与小时的对应为：一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示。注意判断大写字母时，范围一定为`A~N`\n3. **第 1 对相同的英文字母**，范围是`A~Z`或`a~z`\n4. 还要特别注意在输出小时和分钟时，小于10的数字前要补0。这里，我用的是格式控制符`%02d`，`%02d`中`2`的含义为：输出宽度为2，`0`的含义为：宽度不足2时用0填充\n\n**注**：如果大家是在牛客网的评测系统提交代码，则条件没有那么多限制，大写字母的范围都用`A~Z`也不会出错。\n  我在书写代码时产生了如下错误，包括一些低级错误。比如while循环内少了i++，输出格式控制等错误。最后，请大家看一下下面的这个程序，`代码1`在PAT评测系统评测时有一个测试点不通过，`代码2`是通过的(`代码1`与`代码2`的差别已在代码中标出)。请大家思考一下是为什么？\n\n`代码1`\n```c\n#include <stdio.h>\n#define MAXN 61\n//定义一个存放星期字符的字符数组，以便按序号输出星期\nchar week[7][4] = {\"MON\",\"TUE\",\"WED\",\"THU\",\"FRI\",\"SAT\",\"SUN\"};\nint main()\n{\n    char str[4][MAXN],first_capital;\n    int i,num,hour,flag = 0;//flag标记第一个相同大写字母是否已找到\n    //输入4个字符串\n    for(i = 0; i < 4; i++){\n        gets(str[i]);\n    }\n    i = 0;\n    //顺次查找前两个字符串中第一个相同的大写字母\n    while(str[0][i] != '\\0'&&str[1][i] != '\\0'){\n        if(str[0][i] == str[1][i]){\n            //还未找到第一个相同大写英文字母\n            if((str[0][i] >= 'A')&&(str[0][i] <= 'G')&&(!flag)){\n                first_capital = str[0][i];\n                flag = 1;\n            }\n            //已经找到第一个相同大写英文字母\n            else if(flag){\n                if(str[0][i] >= '0'&&str[0][i] <= '9'){\n                    hour = str[0][i] - '0';\n                }\n                else if(str[0][i] >= 'A'&&str[0][i] <= 'N'){\n                    hour = str[0][i] - 'A' + 10;\n                }\n                break;//此处与代码2有差别\n            }\n        }\n        i++;\n    }\n    num = first_capital - 'A';\n    printf(\"%s\",week[num]);\n    i = 0;//注意i要更新为0\n    //分钟确定，用相同英文字母的下标确定，\n    //注意一定是英文字母（大写相等或小写相等均可）\n    while(str[2][i] != '\\0'&&str[3][i] != '\\0'){\n        if(str[2][i] == str[3][i]){\n            if((str[2][i] >= 'A'&&str[2][i] <= 'Z')\n               ||(str[2][i] >= 'a'&&str[2][i] <= 'z')){\n                break;\n            }\n        }\n        i++;\n    }\n    printf(\" %02d:%02d\",hour,i);\n    return 0;\n}\n\n```\n### 代码示例（C语言）\n\n`代码2`\n\n```c\n#include <stdio.h>\n#define MAXN 61\n//定义一个存放星期字符的字符数组，以便按序号输出星期\nchar week[7][4] = {\"MON\",\"TUE\",\"WED\",\"THU\",\"FRI\",\"SAT\",\"SUN\"};\nint main()\n{\n    char str[4][MAXN],first_capital;\n    int i,num,hour,flag = 0;//flag标记第一个相同大写字母是否已找到\n    //输入4个字符串\n    for(i = 0; i < 4; i++){\n        gets(str[i]);\n    }\n    i = 0;\n    //顺次查找前两个字符串中第一个相同的大写字母\n    while(str[0][i] != '\\0'&&str[1][i] != '\\0'){\n        if(str[0][i] == str[1][i]){\n            //还未找到第一个相同大写英文字母\n            if((str[0][i] >= 'A')&&(str[0][i] <= 'G')&&(!flag)){\n                first_capital = str[0][i];\n                flag = 1;\n            }\n            //已经找到第一个相同大写英文字母\n            else if(flag){\n                if(str[0][i] >= '0'&&str[0][i] <= '9'){\n                    hour = str[0][i] - '0';\n                    break;//此处与代码1有差别\n                }\n                else if(str[0][i] >= 'A'&&str[0][i] <= 'N'){\n                    hour = str[0][i] - 'A' + 10;\n                    break;//此处与代码1有差别\n                }\n            }\n        }\n        i++;\n    }\n    num = first_capital - 'A';\n    printf(\"%s\",week[num]);\n    i = 0;//注意i要更新为0\n    //分钟确定，用相同英文字母的下标确定，\n    //注意一定是英文字母（大写相等或小写相等均可）\n    while(str[2][i] != '\\0'&&str[3][i] != '\\0'){\n        if(str[2][i] == str[3][i]){\n            if((str[2][i] >= 'A'&&str[2][i] <= 'Z')\n               ||(str[2][i] >= 'a'&&str[2][i] <= 'z')){\n                break;\n            }\n        }\n        i++;\n    }\n    printf(\" %02d:%02d\",hour,i);\n    return 0;\n}\n```\n>题目来源：PAT乙级1014\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat乙级1014","published":1,"updated":"2019-08-16T02:47:28.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwffg0027fk0rf41qv0pp","content":"<h1 id=\"福尔摩斯的约会\"><a href=\"#福尔摩斯的约会\" class=\"headerlink\" title=\"福尔摩斯的约会\"></a><strong>福尔摩斯的约会</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3485djDkxh4hhGE </span><br><span class=\"line\">2984akDfkkkkggEdsb </span><br><span class=\"line\">s&amp;hgsfdk </span><br><span class=\"line\">d&amp;Hyscvnm</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THU 14:04</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决：\"><a href=\"#问题解决：\" class=\"headerlink\" title=\"问题解决：\"></a>问题解决：</h2><h3 id=\"解题思想及误点剖析\"><a href=\"#解题思想及误点剖析\" class=\"headerlink\" title=\"解题思想及误点剖析\"></a>解题思想及误点剖析</h3><p>此题难点在于理解题意，有三个重要问题需要我们明确：</p>\n<ul>\n<li><strong>第 1 对相同的大写英文字母</strong>，注意是大写英文字母</li>\n<li><strong>第 2 对相同的字符</strong>，注意由后面的叙述可知，第二对相同的字符应是在第一对相同的大写英文字母基础上的第二对，而且必须是数字字符或大写的英文字母</li>\n<li><strong>第 1 对相同的英文字母</strong>，注意此处要求是英文字母，大写小写均可，但是，相等时必须对应为大写或小写（比如<code>a</code>与<code>a</code>相等，<code>A</code>与<code>A</code>相等，但<code>a</code>与<code>A</code>不相等）</li>\n</ul>\n<p>以上3个重要问题在实现与时间对应时应当注意以下几点：</p>\n<ol>\n<li><strong>第 1 对相同的大写英文字母</strong>的字母表顺序i对应星期i（比如A的字母表顺序为1，其对应星期一），我们知道一周也就7天，因此<strong>第 1 对相同的大写英文字母</strong>的字母范围必须是<code>A~G</code>，注意如果在代码的if条件中，寻找<strong>第 1 对相同的大写英文字母</strong>的条件是<code>str[0][i] &gt;= &#39;A&#39;&amp;&amp;str[0][i] &lt;= &#39;G&#39;</code>则导致评测不通过（某个测试点答案错误）</li>\n<li><strong>第 2 对相同的字符</strong>与小时的对应为：一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示。注意判断大写字母时，范围一定为<code>A~N</code></li>\n<li><strong>第 1 对相同的英文字母</strong>，范围是<code>A~Z</code>或<code>a~z</code></li>\n<li>还要特别注意在输出小时和分钟时，小于10的数字前要补0。这里，我用的是格式控制符<code>%02d</code>，<code>%02d</code>中<code>2</code>的含义为：输出宽度为2，<code>0</code>的含义为：宽度不足2时用0填充</li>\n</ol>\n<p><strong>注</strong>：如果大家是在牛客网的评测系统提交代码，则条件没有那么多限制，大写字母的范围都用<code>A~Z</code>也不会出错。<br>  我在书写代码时产生了如下错误，包括一些低级错误。比如while循环内少了i++，输出格式控制等错误。最后，请大家看一下下面的这个程序，<code>代码1</code>在PAT评测系统评测时有一个测试点不通过，<code>代码2</code>是通过的(<code>代码1</code>与<code>代码2</code>的差别已在代码中标出)。请大家思考一下是为什么？</p>\n<p><code>代码1</code><br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 61</span></span><br><span class=\"line\"><span class=\"comment\">//定义一个存放星期字符的字符数组，以便按序号输出星期</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> week[<span class=\"number\">7</span>][<span class=\"number\">4</span>] = &#123;<span class=\"string\">\"MON\"</span>,<span class=\"string\">\"TUE\"</span>,<span class=\"string\">\"WED\"</span>,<span class=\"string\">\"THU\"</span>,<span class=\"string\">\"FRI\"</span>,<span class=\"string\">\"SAT\"</span>,<span class=\"string\">\"SUN\"</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">4</span>][MAXN],first_capital;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,num,hour,flag = <span class=\"number\">0</span>;<span class=\"comment\">//flag标记第一个相同大写字母是否已找到</span></span><br><span class=\"line\">    <span class=\"comment\">//输入4个字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        gets(str[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//顺次查找前两个字符串中第一个相同的大写字母</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[<span class=\"number\">0</span>][i] != <span class=\"string\">'\\0'</span>&amp;&amp;str[<span class=\"number\">1</span>][i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] == str[<span class=\"number\">1</span>][i])&#123;</span><br><span class=\"line\">            <span class=\"comment\">//还未找到第一个相同大写英文字母</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>((str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'A'</span>)&amp;&amp;(str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'G'</span>)&amp;&amp;(!flag))&#123;</span><br><span class=\"line\">                first_capital = str[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//已经找到第一个相同大写英文字母</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'0'</span>&amp;&amp;str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'9'</span>)&#123;</span><br><span class=\"line\">                    hour = str[<span class=\"number\">0</span>][i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'N'</span>)&#123;</span><br><span class=\"line\">                    hour = str[<span class=\"number\">0</span>][i] - <span class=\"string\">'A'</span> + <span class=\"number\">10</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;<span class=\"comment\">//此处与代码2有差别</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    num = first_capital - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,week[num]);</span><br><span class=\"line\">    i = <span class=\"number\">0</span>;<span class=\"comment\">//注意i要更新为0</span></span><br><span class=\"line\">    <span class=\"comment\">//分钟确定，用相同英文字母的下标确定，</span></span><br><span class=\"line\">    <span class=\"comment\">//注意一定是英文字母（大写相等或小写相等均可）</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[<span class=\"number\">2</span>][i] != <span class=\"string\">'\\0'</span>&amp;&amp;str[<span class=\"number\">3</span>][i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[<span class=\"number\">2</span>][i] == str[<span class=\"number\">3</span>][i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((str[<span class=\"number\">2</span>][i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;str[<span class=\"number\">2</span>][i] &lt;= <span class=\"string\">'Z'</span>)</span><br><span class=\"line\">               ||(str[<span class=\"number\">2</span>][i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;str[<span class=\"number\">2</span>][i] &lt;= <span class=\"string\">'z'</span>))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %02d:%02d\"</span>,hour,i);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></p>\n<h3 id=\"代码示例（C语言）\"><a href=\"#代码示例（C语言）\" class=\"headerlink\" title=\"代码示例（C语言）\"></a>代码示例（C语言）</h3><p><code>代码2</code></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 61</span></span><br><span class=\"line\"><span class=\"comment\">//定义一个存放星期字符的字符数组，以便按序号输出星期</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> week[<span class=\"number\">7</span>][<span class=\"number\">4</span>] = &#123;<span class=\"string\">\"MON\"</span>,<span class=\"string\">\"TUE\"</span>,<span class=\"string\">\"WED\"</span>,<span class=\"string\">\"THU\"</span>,<span class=\"string\">\"FRI\"</span>,<span class=\"string\">\"SAT\"</span>,<span class=\"string\">\"SUN\"</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">4</span>][MAXN],first_capital;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,num,hour,flag = <span class=\"number\">0</span>;<span class=\"comment\">//flag标记第一个相同大写字母是否已找到</span></span><br><span class=\"line\">    <span class=\"comment\">//输入4个字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        gets(str[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//顺次查找前两个字符串中第一个相同的大写字母</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[<span class=\"number\">0</span>][i] != <span class=\"string\">'\\0'</span>&amp;&amp;str[<span class=\"number\">1</span>][i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] == str[<span class=\"number\">1</span>][i])&#123;</span><br><span class=\"line\">            <span class=\"comment\">//还未找到第一个相同大写英文字母</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>((str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'A'</span>)&amp;&amp;(str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'G'</span>)&amp;&amp;(!flag))&#123;</span><br><span class=\"line\">                first_capital = str[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//已经找到第一个相同大写英文字母</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'0'</span>&amp;&amp;str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'9'</span>)&#123;</span><br><span class=\"line\">                    hour = str[<span class=\"number\">0</span>][i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;<span class=\"comment\">//此处与代码1有差别</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'N'</span>)&#123;</span><br><span class=\"line\">                    hour = str[<span class=\"number\">0</span>][i] - <span class=\"string\">'A'</span> + <span class=\"number\">10</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;<span class=\"comment\">//此处与代码1有差别</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    num = first_capital - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,week[num]);</span><br><span class=\"line\">    i = <span class=\"number\">0</span>;<span class=\"comment\">//注意i要更新为0</span></span><br><span class=\"line\">    <span class=\"comment\">//分钟确定，用相同英文字母的下标确定，</span></span><br><span class=\"line\">    <span class=\"comment\">//注意一定是英文字母（大写相等或小写相等均可）</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[<span class=\"number\">2</span>][i] != <span class=\"string\">'\\0'</span>&amp;&amp;str[<span class=\"number\">3</span>][i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[<span class=\"number\">2</span>][i] == str[<span class=\"number\">3</span>][i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((str[<span class=\"number\">2</span>][i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;str[<span class=\"number\">2</span>][i] &lt;= <span class=\"string\">'Z'</span>)</span><br><span class=\"line\">               ||(str[<span class=\"number\">2</span>][i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;str[<span class=\"number\">2</span>][i] &lt;= <span class=\"string\">'z'</span>))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %02d:%02d\"</span>,hour,i);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1014<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"福尔摩斯的约会\"><a href=\"#福尔摩斯的约会\" class=\"headerlink\" title=\"福尔摩斯的约会\"></a><strong>福尔摩斯的约会</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3485djDkxh4hhGE </span><br><span class=\"line\">2984akDfkkkkggEdsb </span><br><span class=\"line\">s&amp;hgsfdk </span><br><span class=\"line\">d&amp;Hyscvnm</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THU 14:04</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决：\"><a href=\"#问题解决：\" class=\"headerlink\" title=\"问题解决：\"></a>问题解决：</h2><h3 id=\"解题思想及误点剖析\"><a href=\"#解题思想及误点剖析\" class=\"headerlink\" title=\"解题思想及误点剖析\"></a>解题思想及误点剖析</h3><p>此题难点在于理解题意，有三个重要问题需要我们明确：</p>\n<ul>\n<li><strong>第 1 对相同的大写英文字母</strong>，注意是大写英文字母</li>\n<li><strong>第 2 对相同的字符</strong>，注意由后面的叙述可知，第二对相同的字符应是在第一对相同的大写英文字母基础上的第二对，而且必须是数字字符或大写的英文字母</li>\n<li><strong>第 1 对相同的英文字母</strong>，注意此处要求是英文字母，大写小写均可，但是，相等时必须对应为大写或小写（比如<code>a</code>与<code>a</code>相等，<code>A</code>与<code>A</code>相等，但<code>a</code>与<code>A</code>不相等）</li>\n</ul>\n<p>以上3个重要问题在实现与时间对应时应当注意以下几点：</p>\n<ol>\n<li><strong>第 1 对相同的大写英文字母</strong>的字母表顺序i对应星期i（比如A的字母表顺序为1，其对应星期一），我们知道一周也就7天，因此<strong>第 1 对相同的大写英文字母</strong>的字母范围必须是<code>A~G</code>，注意如果在代码的if条件中，寻找<strong>第 1 对相同的大写英文字母</strong>的条件是<code>str[0][i] &gt;= &#39;A&#39;&amp;&amp;str[0][i] &lt;= &#39;G&#39;</code>则导致评测不通过（某个测试点答案错误）</li>\n<li><strong>第 2 对相同的字符</strong>与小时的对应为：一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示。注意判断大写字母时，范围一定为<code>A~N</code></li>\n<li><strong>第 1 对相同的英文字母</strong>，范围是<code>A~Z</code>或<code>a~z</code></li>\n<li>还要特别注意在输出小时和分钟时，小于10的数字前要补0。这里，我用的是格式控制符<code>%02d</code>，<code>%02d</code>中<code>2</code>的含义为：输出宽度为2，<code>0</code>的含义为：宽度不足2时用0填充</li>\n</ol>\n<p><strong>注</strong>：如果大家是在牛客网的评测系统提交代码，则条件没有那么多限制，大写字母的范围都用<code>A~Z</code>也不会出错。<br>  我在书写代码时产生了如下错误，包括一些低级错误。比如while循环内少了i++，输出格式控制等错误。最后，请大家看一下下面的这个程序，<code>代码1</code>在PAT评测系统评测时有一个测试点不通过，<code>代码2</code>是通过的(<code>代码1</code>与<code>代码2</code>的差别已在代码中标出)。请大家思考一下是为什么？</p>\n<p><code>代码1</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 61</span></span><br><span class=\"line\"><span class=\"comment\">//定义一个存放星期字符的字符数组，以便按序号输出星期</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> week[<span class=\"number\">7</span>][<span class=\"number\">4</span>] = &#123;<span class=\"string\">\"MON\"</span>,<span class=\"string\">\"TUE\"</span>,<span class=\"string\">\"WED\"</span>,<span class=\"string\">\"THU\"</span>,<span class=\"string\">\"FRI\"</span>,<span class=\"string\">\"SAT\"</span>,<span class=\"string\">\"SUN\"</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">4</span>][MAXN],first_capital;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,num,hour,flag = <span class=\"number\">0</span>;<span class=\"comment\">//flag标记第一个相同大写字母是否已找到</span></span><br><span class=\"line\">    <span class=\"comment\">//输入4个字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        gets(str[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//顺次查找前两个字符串中第一个相同的大写字母</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[<span class=\"number\">0</span>][i] != <span class=\"string\">'\\0'</span>&amp;&amp;str[<span class=\"number\">1</span>][i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] == str[<span class=\"number\">1</span>][i])&#123;</span><br><span class=\"line\">            <span class=\"comment\">//还未找到第一个相同大写英文字母</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>((str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'A'</span>)&amp;&amp;(str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'G'</span>)&amp;&amp;(!flag))&#123;</span><br><span class=\"line\">                first_capital = str[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//已经找到第一个相同大写英文字母</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'0'</span>&amp;&amp;str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'9'</span>)&#123;</span><br><span class=\"line\">                    hour = str[<span class=\"number\">0</span>][i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'N'</span>)&#123;</span><br><span class=\"line\">                    hour = str[<span class=\"number\">0</span>][i] - <span class=\"string\">'A'</span> + <span class=\"number\">10</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;<span class=\"comment\">//此处与代码2有差别</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    num = first_capital - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,week[num]);</span><br><span class=\"line\">    i = <span class=\"number\">0</span>;<span class=\"comment\">//注意i要更新为0</span></span><br><span class=\"line\">    <span class=\"comment\">//分钟确定，用相同英文字母的下标确定，</span></span><br><span class=\"line\">    <span class=\"comment\">//注意一定是英文字母（大写相等或小写相等均可）</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[<span class=\"number\">2</span>][i] != <span class=\"string\">'\\0'</span>&amp;&amp;str[<span class=\"number\">3</span>][i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[<span class=\"number\">2</span>][i] == str[<span class=\"number\">3</span>][i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((str[<span class=\"number\">2</span>][i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;str[<span class=\"number\">2</span>][i] &lt;= <span class=\"string\">'Z'</span>)</span><br><span class=\"line\">               ||(str[<span class=\"number\">2</span>][i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;str[<span class=\"number\">2</span>][i] &lt;= <span class=\"string\">'z'</span>))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %02d:%02d\"</span>,hour,i);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"代码示例（C语言）\"><a href=\"#代码示例（C语言）\" class=\"headerlink\" title=\"代码示例（C语言）\"></a>代码示例（C语言）</h3><p><code>代码2</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 61</span></span><br><span class=\"line\"><span class=\"comment\">//定义一个存放星期字符的字符数组，以便按序号输出星期</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> week[<span class=\"number\">7</span>][<span class=\"number\">4</span>] = &#123;<span class=\"string\">\"MON\"</span>,<span class=\"string\">\"TUE\"</span>,<span class=\"string\">\"WED\"</span>,<span class=\"string\">\"THU\"</span>,<span class=\"string\">\"FRI\"</span>,<span class=\"string\">\"SAT\"</span>,<span class=\"string\">\"SUN\"</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">4</span>][MAXN],first_capital;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,num,hour,flag = <span class=\"number\">0</span>;<span class=\"comment\">//flag标记第一个相同大写字母是否已找到</span></span><br><span class=\"line\">    <span class=\"comment\">//输入4个字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        gets(str[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//顺次查找前两个字符串中第一个相同的大写字母</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[<span class=\"number\">0</span>][i] != <span class=\"string\">'\\0'</span>&amp;&amp;str[<span class=\"number\">1</span>][i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] == str[<span class=\"number\">1</span>][i])&#123;</span><br><span class=\"line\">            <span class=\"comment\">//还未找到第一个相同大写英文字母</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>((str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'A'</span>)&amp;&amp;(str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'G'</span>)&amp;&amp;(!flag))&#123;</span><br><span class=\"line\">                first_capital = str[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//已经找到第一个相同大写英文字母</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'0'</span>&amp;&amp;str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'9'</span>)&#123;</span><br><span class=\"line\">                    hour = str[<span class=\"number\">0</span>][i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;<span class=\"comment\">//此处与代码1有差别</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>][i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;str[<span class=\"number\">0</span>][i] &lt;= <span class=\"string\">'N'</span>)&#123;</span><br><span class=\"line\">                    hour = str[<span class=\"number\">0</span>][i] - <span class=\"string\">'A'</span> + <span class=\"number\">10</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;<span class=\"comment\">//此处与代码1有差别</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    num = first_capital - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,week[num]);</span><br><span class=\"line\">    i = <span class=\"number\">0</span>;<span class=\"comment\">//注意i要更新为0</span></span><br><span class=\"line\">    <span class=\"comment\">//分钟确定，用相同英文字母的下标确定，</span></span><br><span class=\"line\">    <span class=\"comment\">//注意一定是英文字母（大写相等或小写相等均可）</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[<span class=\"number\">2</span>][i] != <span class=\"string\">'\\0'</span>&amp;&amp;str[<span class=\"number\">3</span>][i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[<span class=\"number\">2</span>][i] == str[<span class=\"number\">3</span>][i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((str[<span class=\"number\">2</span>][i] &gt;= <span class=\"string\">'A'</span>&amp;&amp;str[<span class=\"number\">2</span>][i] &lt;= <span class=\"string\">'Z'</span>)</span><br><span class=\"line\">               ||(str[<span class=\"number\">2</span>][i] &gt;= <span class=\"string\">'a'</span>&amp;&amp;str[<span class=\"number\">2</span>][i] &lt;= <span class=\"string\">'z'</span>))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %02d:%02d\"</span>,hour,i);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1014<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1015 || 德才论（详解，C/C++示例，测试点分析）","date":"2019-08-16T02:20:04.000Z","mathjax":true,"_content":"\n# **德才论**\n## 题目描述\n宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”\n现给出一批考生的德才分数，请根据司马光的理论给出录取排名。\n## 输入格式\n输入第一行给出 3 个正整数，分别为：N（≤$10^5$），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。\n随后 N 行，每行给出一位考生的信息，包括：`准考证号 德分 才分`，其中`准考证号`为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。\n\n## 输出格式\n输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。\n## 输入样例\n```null\n14 60 80\n10000001 64 90\n10000002 90 60\n10000011 85 80\n10000003 85 80\n10000004 80 85\n10000005 82 77\n10000006 83 76\n10000007 90 78\n10000008 75 79\n10000009 59 90\n10000010 88 45\n10000012 80 100\n10000013 90 99\n10000014 66 60\n```\n## 输出样例\n```null\n12\n10000013 90 99\n10000012 80 100\n10000003 85 80\n10000011 85 80\n10000004 80 85\n10000007 90 78\n10000006 83 76\n10000005 82 77\n10000002 90 60\n10000014 66 60\n10000008 75 79\n10000001 64 90\n```\n\n## 问题解决\n### 解题思想\n\n本题是典型的排序问题，这里我们使用C++标准模版库(STL)里面的sort()函数。具体过程如下：\n\n定义student结构体类型，成员包括：准考证号、德分、才分以及考生类别。考生类别用于区分5类不同的考生，简化排序过程。在输入过程中根据每位考生的分数来确定考生的类别。输入并分类完毕，接下来就要用到强大的sort()函数了。首先，sort()函数的格式为：\n\n```null\nsort(第一个元素的地址，最后一个元素的下一个地址[，比较函数])；\n```\n\n其中，[]内为可选项，它是用来规定排序的规则的，默认是简单的升序排序。如果要实现稍复杂的排序，就需要我们自行构建比较函数内部的规则了（比如此题构建的cmp()函数）。\n\n下面详解一下cmp()函数的构造细节：\n\n1. 先按考生类别由低到高排序\n2. 同一类别考生，按德才总分由高到低排序\n3. 同类考生，德才总分相同时按德分降序排序\n4. 同类考生，德分才分均相同时按准考证号的升序排序\n\n构造完cmp()后，一句代码即可完成本题排序，简单粗暴有效！\n```cpp\nsort(stu,stu + n,cmp);//注意sort()函数的第二个参数为最后一个元素的下一个位置\n```\n### 知识拓展\n\n毫无疑问，在上机考试中最适合使用的语言就是C语言和C++了，虽然java和python用的人更多，但是它们的执行效率相对于C/C++而言要慢很多，经常会造成超时。因此，我所做的示例代码一般都是C/C++来写的，前面的几道题为了让大家适应，我选择了用全C语言的方式，但是C语言虽然有很多优点，但是它是有一些不太顺手的规则的，C++是向下兼容C的，而且C++中有一些比较好用的特性可以使我们的编程更便捷，因此，接下来题目的示例代码中，我将逐步加入C++的一些元素。请注意，以后的代码在编辑器中一定要保存为`.cpp`文件，这是C++文件的扩展名，这是为了利用C++的一些好的特性。\nC++标准中头文件书写格式一般为`cstdio`，它等价于C语言的`stdio.h`的写法。推荐以后用C++的书写形式，即\n\n```cpp\n#include <cstdio>\n```\n你可能会觉得C语言的标准格式输入输出函数scanf和printf太麻烦，因为它还要指定输入输出格式，而C++的cin和cout相比而言就显得非常简单。但是，我还是建议大家用scanf和printf来进行输入输出，因为，cin和cout要比scanf和printf消耗更多的时间，很容易在输入输出中产生超时。\n\nC++的main()函数位置上面一般会有一句\n\n```cpp\nusing namespace std;\n```\n\n所谓namespace，即为名字空间，标准C++中引入名字空间的概念，把标准库里面的一些东西封装到std名字空间中。使用using编译命令导入所有的名称。使用C++的一些标准模版库时，一般需要添加此句。初学者，每一个C++程序最好都这样做。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define MAXN 100001\nusing namespace std;\nstruct student\n{\n    int id;//准考证号\n    int mor_score;//德分\n    int abi_score;//才分\n    int category;//类别\n}stu[MAXN];\n//排序规则函数cmp\nbool cmp(student a, student b)\n{\n    if(a.category != b.category){//先按考生类别由低到高排序\n        return a.category < b.category;\n    }\n    //同一类别考生，按德才总分由高到低排序\n    else if((a.mor_score + a.abi_score) != (b.mor_score + b.abi_score)){\n        return (a.mor_score + a.abi_score) > (b.mor_score + b.abi_score);\n    }\n    //同类考生，德才总分相同时按德分降序排序\n    else if(a.mor_score != b.mor_score){\n        return a.mor_score > b.mor_score;\n    }\n    //同类考生，德分才分均相同时按准考证号的升序输出\n    else{\n        return a.id < b.id;\n    }\n}\nint main()\n{\n    int n,l,h,i,cou = 0;//cou统计未达标考生人数\n    scanf(\"%d%d%d\",&n,&l,&h);\n    for(i = 0; i < n; i++){\n        scanf(\"%d%d%d\",&stu[i].id,&stu[i].mor_score,&stu[i].abi_score);\n        if(stu[i].mor_score >= h&&stu[i].abi_score >= h){\n            stu[i].category = 1;//第一类考生，即“德才全尽”\n        }\n        else if(stu[i].mor_score >= h&&stu[i].abi_score >= l){\n            stu[i].category = 2;//第二类考生，即“德胜才”\n        }\n        else if(stu[i].mor_score >= l&&stu[i].abi_score >= l\n                &&stu[i].mor_score >= stu[i].abi_score){\n            stu[i].category = 3;//第三类考生，即“才德兼亡”但尚有“德胜才”\n        }else if(stu[i].mor_score >= l&&stu[i].abi_score >= l){\n            stu[i].category = 4;//第四类考生，即其他达到最低线 L 的考生\n        }\n        else{\n            stu[i].category = 5;//第五类考生，未达最低线，不参与排名\n            cou++;\n        }\n    }\n    sort(stu,stu + n,cmp);//注意sort()函数的第二个参数为最后一个元素的下一个位置\n    printf(\"%d\\n\",n-cou);//输出达标考生人数\n    for(i = 0; i < n-cou; i++){\n        printf(\"%d %d %d\\n\",stu[i].id,stu[i].mor_score,stu[i].abi_score);\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1015\n>作者：CHEN, Li\n>单位：浙江大学","source":"_posts/pat乙级1015.md","raw":"---\ntitle: PAT乙级1015 || 德才论（详解，C/C++示例，测试点分析）\ndate: 2019-08-16 10:20:04\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **德才论**\n## 题目描述\n宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”\n现给出一批考生的德才分数，请根据司马光的理论给出录取排名。\n## 输入格式\n输入第一行给出 3 个正整数，分别为：N（≤$10^5$），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。\n随后 N 行，每行给出一位考生的信息，包括：`准考证号 德分 才分`，其中`准考证号`为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。\n\n## 输出格式\n输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。\n## 输入样例\n```null\n14 60 80\n10000001 64 90\n10000002 90 60\n10000011 85 80\n10000003 85 80\n10000004 80 85\n10000005 82 77\n10000006 83 76\n10000007 90 78\n10000008 75 79\n10000009 59 90\n10000010 88 45\n10000012 80 100\n10000013 90 99\n10000014 66 60\n```\n## 输出样例\n```null\n12\n10000013 90 99\n10000012 80 100\n10000003 85 80\n10000011 85 80\n10000004 80 85\n10000007 90 78\n10000006 83 76\n10000005 82 77\n10000002 90 60\n10000014 66 60\n10000008 75 79\n10000001 64 90\n```\n\n## 问题解决\n### 解题思想\n\n本题是典型的排序问题，这里我们使用C++标准模版库(STL)里面的sort()函数。具体过程如下：\n\n定义student结构体类型，成员包括：准考证号、德分、才分以及考生类别。考生类别用于区分5类不同的考生，简化排序过程。在输入过程中根据每位考生的分数来确定考生的类别。输入并分类完毕，接下来就要用到强大的sort()函数了。首先，sort()函数的格式为：\n\n```null\nsort(第一个元素的地址，最后一个元素的下一个地址[，比较函数])；\n```\n\n其中，[]内为可选项，它是用来规定排序的规则的，默认是简单的升序排序。如果要实现稍复杂的排序，就需要我们自行构建比较函数内部的规则了（比如此题构建的cmp()函数）。\n\n下面详解一下cmp()函数的构造细节：\n\n1. 先按考生类别由低到高排序\n2. 同一类别考生，按德才总分由高到低排序\n3. 同类考生，德才总分相同时按德分降序排序\n4. 同类考生，德分才分均相同时按准考证号的升序排序\n\n构造完cmp()后，一句代码即可完成本题排序，简单粗暴有效！\n```cpp\nsort(stu,stu + n,cmp);//注意sort()函数的第二个参数为最后一个元素的下一个位置\n```\n### 知识拓展\n\n毫无疑问，在上机考试中最适合使用的语言就是C语言和C++了，虽然java和python用的人更多，但是它们的执行效率相对于C/C++而言要慢很多，经常会造成超时。因此，我所做的示例代码一般都是C/C++来写的，前面的几道题为了让大家适应，我选择了用全C语言的方式，但是C语言虽然有很多优点，但是它是有一些不太顺手的规则的，C++是向下兼容C的，而且C++中有一些比较好用的特性可以使我们的编程更便捷，因此，接下来题目的示例代码中，我将逐步加入C++的一些元素。请注意，以后的代码在编辑器中一定要保存为`.cpp`文件，这是C++文件的扩展名，这是为了利用C++的一些好的特性。\nC++标准中头文件书写格式一般为`cstdio`，它等价于C语言的`stdio.h`的写法。推荐以后用C++的书写形式，即\n\n```cpp\n#include <cstdio>\n```\n你可能会觉得C语言的标准格式输入输出函数scanf和printf太麻烦，因为它还要指定输入输出格式，而C++的cin和cout相比而言就显得非常简单。但是，我还是建议大家用scanf和printf来进行输入输出，因为，cin和cout要比scanf和printf消耗更多的时间，很容易在输入输出中产生超时。\n\nC++的main()函数位置上面一般会有一句\n\n```cpp\nusing namespace std;\n```\n\n所谓namespace，即为名字空间，标准C++中引入名字空间的概念，把标准库里面的一些东西封装到std名字空间中。使用using编译命令导入所有的名称。使用C++的一些标准模版库时，一般需要添加此句。初学者，每一个C++程序最好都这样做。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define MAXN 100001\nusing namespace std;\nstruct student\n{\n    int id;//准考证号\n    int mor_score;//德分\n    int abi_score;//才分\n    int category;//类别\n}stu[MAXN];\n//排序规则函数cmp\nbool cmp(student a, student b)\n{\n    if(a.category != b.category){//先按考生类别由低到高排序\n        return a.category < b.category;\n    }\n    //同一类别考生，按德才总分由高到低排序\n    else if((a.mor_score + a.abi_score) != (b.mor_score + b.abi_score)){\n        return (a.mor_score + a.abi_score) > (b.mor_score + b.abi_score);\n    }\n    //同类考生，德才总分相同时按德分降序排序\n    else if(a.mor_score != b.mor_score){\n        return a.mor_score > b.mor_score;\n    }\n    //同类考生，德分才分均相同时按准考证号的升序输出\n    else{\n        return a.id < b.id;\n    }\n}\nint main()\n{\n    int n,l,h,i,cou = 0;//cou统计未达标考生人数\n    scanf(\"%d%d%d\",&n,&l,&h);\n    for(i = 0; i < n; i++){\n        scanf(\"%d%d%d\",&stu[i].id,&stu[i].mor_score,&stu[i].abi_score);\n        if(stu[i].mor_score >= h&&stu[i].abi_score >= h){\n            stu[i].category = 1;//第一类考生，即“德才全尽”\n        }\n        else if(stu[i].mor_score >= h&&stu[i].abi_score >= l){\n            stu[i].category = 2;//第二类考生，即“德胜才”\n        }\n        else if(stu[i].mor_score >= l&&stu[i].abi_score >= l\n                &&stu[i].mor_score >= stu[i].abi_score){\n            stu[i].category = 3;//第三类考生，即“才德兼亡”但尚有“德胜才”\n        }else if(stu[i].mor_score >= l&&stu[i].abi_score >= l){\n            stu[i].category = 4;//第四类考生，即其他达到最低线 L 的考生\n        }\n        else{\n            stu[i].category = 5;//第五类考生，未达最低线，不参与排名\n            cou++;\n        }\n    }\n    sort(stu,stu + n,cmp);//注意sort()函数的第二个参数为最后一个元素的下一个位置\n    printf(\"%d\\n\",n-cou);//输出达标考生人数\n    for(i = 0; i < n-cou; i++){\n        printf(\"%d %d %d\\n\",stu[i].id,stu[i].mor_score,stu[i].abi_score);\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1015\n>作者：CHEN, Li\n>单位：浙江大学","slug":"pat乙级1015","published":1,"updated":"2019-08-17T15:06:23.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwffj002bfk0r1lytof08","content":"<h1 id=\"德才论\"><a href=\"#德才论\" class=\"headerlink\" title=\"德才论\"></a><strong>德才论</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”<br>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>输入第一行给出 3 个正整数，分别为：N（≤$10^5$），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。<br>随后 N 行，每行给出一位考生的信息，包括：<code>准考证号 德分 才分</code>，其中<code>准考证号</code>为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14 60 80</span><br><span class=\"line\">10000001 64 90</span><br><span class=\"line\">10000002 90 60</span><br><span class=\"line\">10000011 85 80</span><br><span class=\"line\">10000003 85 80</span><br><span class=\"line\">10000004 80 85</span><br><span class=\"line\">10000005 82 77</span><br><span class=\"line\">10000006 83 76</span><br><span class=\"line\">10000007 90 78</span><br><span class=\"line\">10000008 75 79</span><br><span class=\"line\">10000009 59 90</span><br><span class=\"line\">10000010 88 45</span><br><span class=\"line\">10000012 80 100</span><br><span class=\"line\">10000013 90 99</span><br><span class=\"line\">10000014 66 60</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12</span><br><span class=\"line\">10000013 90 99</span><br><span class=\"line\">10000012 80 100</span><br><span class=\"line\">10000003 85 80</span><br><span class=\"line\">10000011 85 80</span><br><span class=\"line\">10000004 80 85</span><br><span class=\"line\">10000007 90 78</span><br><span class=\"line\">10000006 83 76</span><br><span class=\"line\">10000005 82 77</span><br><span class=\"line\">10000002 90 60</span><br><span class=\"line\">10000014 66 60</span><br><span class=\"line\">10000008 75 79</span><br><span class=\"line\">10000001 64 90</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题是典型的排序问题，这里我们使用C++标准模版库(STL)里面的sort()函数。具体过程如下：</p>\n<p>定义student结构体类型，成员包括：准考证号、德分、才分以及考生类别。考生类别用于区分5类不同的考生，简化排序过程。在输入过程中根据每位考生的分数来确定考生的类别。输入并分类完毕，接下来就要用到强大的sort()函数了。首先，sort()函数的格式为：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort(第一个元素的地址，最后一个元素的下一个地址[，比较函数])；</span><br></pre></td></tr></table></figure></div>\n<p>其中，[]内为可选项，它是用来规定排序的规则的，默认是简单的升序排序。如果要实现稍复杂的排序，就需要我们自行构建比较函数内部的规则了（比如此题构建的cmp()函数）。</p>\n<p>下面详解一下cmp()函数的构造细节：</p>\n<ol>\n<li>先按考生类别由低到高排序</li>\n<li>同一类别考生，按德才总分由高到低排序</li>\n<li>同类考生，德才总分相同时按德分降序排序</li>\n<li>同类考生，德分才分均相同时按准考证号的升序排序</li>\n</ol>\n<p>构造完cmp()后，一句代码即可完成本题排序，简单粗暴有效！<br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort(stu,stu + n,cmp);<span class=\"comment\">//注意sort()函数的第二个参数为最后一个元素的下一个位置</span></span><br></pre></td></tr></table></figure></div></p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>毫无疑问，在上机考试中最适合使用的语言就是C语言和C++了，虽然java和python用的人更多，但是它们的执行效率相对于C/C++而言要慢很多，经常会造成超时。因此，我所做的示例代码一般都是C/C++来写的，前面的几道题为了让大家适应，我选择了用全C语言的方式，但是C语言虽然有很多优点，但是它是有一些不太顺手的规则的，C++是向下兼容C的，而且C++中有一些比较好用的特性可以使我们的编程更便捷，因此，接下来题目的示例代码中，我将逐步加入C++的一些元素。请注意，以后的代码在编辑器中一定要保存为<code>.cpp</code>文件，这是C++文件的扩展名，这是为了利用C++的一些好的特性。<br>C++标准中头文件书写格式一般为<code>cstdio</code>，它等价于C语言的<code>stdio.h</code>的写法。推荐以后用C++的书写形式，即</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure></div>\n<p>你可能会觉得C语言的标准格式输入输出函数scanf和printf太麻烦，因为它还要指定输入输出格式，而C++的cin和cout相比而言就显得非常简单。但是，我还是建议大家用scanf和printf来进行输入输出，因为，cin和cout要比scanf和printf消耗更多的时间，很容易在输入输出中产生超时。</p>\n<p>C++的main()函数位置上面一般会有一句</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br></pre></td></tr></table></figure></div>\n<p>所谓namespace，即为名字空间，标准C++中引入名字空间的概念，把标准库里面的一些东西封装到std名字空间中。使用using编译命令导入所有的名称。使用C++的一些标准模版库时，一般需要添加此句。初学者，每一个C++程序最好都这样做。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">student</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;<span class=\"comment\">//准考证号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mor_score;<span class=\"comment\">//德分</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> abi_score;<span class=\"comment\">//才分</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> category;<span class=\"comment\">//类别</span></span><br><span class=\"line\">&#125;stu[MAXN];</span><br><span class=\"line\"><span class=\"comment\">//排序规则函数cmp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(student a, student b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.category != b.category)&#123;<span class=\"comment\">//先按考生类别由低到高排序</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.category &lt; b.category;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//同一类别考生，按德才总分由高到低排序</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((a.mor_score + a.abi_score) != (b.mor_score + b.abi_score))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (a.mor_score + a.abi_score) &gt; (b.mor_score + b.abi_score);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//同类考生，德才总分相同时按德分降序排序</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a.mor_score != b.mor_score)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.mor_score &gt; b.mor_score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//同类考生，德分才分均相同时按准考证号的升序输出</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.id &lt; b.id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,l,h,i,cou = <span class=\"number\">0</span>;<span class=\"comment\">//cou统计未达标考生人数</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;n,&amp;l,&amp;h);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;stu[i].id,&amp;stu[i].mor_score,&amp;stu[i].abi_score);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(stu[i].mor_score &gt;= h&amp;&amp;stu[i].abi_score &gt;= h)&#123;</span><br><span class=\"line\">            stu[i].category = <span class=\"number\">1</span>;<span class=\"comment\">//第一类考生，即“德才全尽”</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(stu[i].mor_score &gt;= h&amp;&amp;stu[i].abi_score &gt;= l)&#123;</span><br><span class=\"line\">            stu[i].category = <span class=\"number\">2</span>;<span class=\"comment\">//第二类考生，即“德胜才”</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(stu[i].mor_score &gt;= l&amp;&amp;stu[i].abi_score &gt;= l</span><br><span class=\"line\">                &amp;&amp;stu[i].mor_score &gt;= stu[i].abi_score)&#123;</span><br><span class=\"line\">            stu[i].category = <span class=\"number\">3</span>;<span class=\"comment\">//第三类考生，即“才德兼亡”但尚有“德胜才”</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(stu[i].mor_score &gt;= l&amp;&amp;stu[i].abi_score &gt;= l)&#123;</span><br><span class=\"line\">            stu[i].category = <span class=\"number\">4</span>;<span class=\"comment\">//第四类考生，即其他达到最低线 L 的考生</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            stu[i].category = <span class=\"number\">5</span>;<span class=\"comment\">//第五类考生，未达最低线，不参与排名</span></span><br><span class=\"line\">            cou++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(stu,stu + n,cmp);<span class=\"comment\">//注意sort()函数的第二个参数为最后一个元素的下一个位置</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,n-cou);<span class=\"comment\">//输出达标考生人数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n-cou; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d %d\\n\"</span>,stu[i].id,stu[i].mor_score,stu[i].abi_score);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1015<br>作者：CHEN, Li<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"德才论\"><a href=\"#德才论\" class=\"headerlink\" title=\"德才论\"></a><strong>德才论</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”<br>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>输入第一行给出 3 个正整数，分别为：N（≤$10^5$），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。<br>随后 N 行，每行给出一位考生的信息，包括：<code>准考证号 德分 才分</code>，其中<code>准考证号</code>为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14 60 80</span><br><span class=\"line\">10000001 64 90</span><br><span class=\"line\">10000002 90 60</span><br><span class=\"line\">10000011 85 80</span><br><span class=\"line\">10000003 85 80</span><br><span class=\"line\">10000004 80 85</span><br><span class=\"line\">10000005 82 77</span><br><span class=\"line\">10000006 83 76</span><br><span class=\"line\">10000007 90 78</span><br><span class=\"line\">10000008 75 79</span><br><span class=\"line\">10000009 59 90</span><br><span class=\"line\">10000010 88 45</span><br><span class=\"line\">10000012 80 100</span><br><span class=\"line\">10000013 90 99</span><br><span class=\"line\">10000014 66 60</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12</span><br><span class=\"line\">10000013 90 99</span><br><span class=\"line\">10000012 80 100</span><br><span class=\"line\">10000003 85 80</span><br><span class=\"line\">10000011 85 80</span><br><span class=\"line\">10000004 80 85</span><br><span class=\"line\">10000007 90 78</span><br><span class=\"line\">10000006 83 76</span><br><span class=\"line\">10000005 82 77</span><br><span class=\"line\">10000002 90 60</span><br><span class=\"line\">10000014 66 60</span><br><span class=\"line\">10000008 75 79</span><br><span class=\"line\">10000001 64 90</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题是典型的排序问题，这里我们使用C++标准模版库(STL)里面的sort()函数。具体过程如下：</p>\n<p>定义student结构体类型，成员包括：准考证号、德分、才分以及考生类别。考生类别用于区分5类不同的考生，简化排序过程。在输入过程中根据每位考生的分数来确定考生的类别。输入并分类完毕，接下来就要用到强大的sort()函数了。首先，sort()函数的格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort(第一个元素的地址，最后一个元素的下一个地址[，比较函数])；</span><br></pre></td></tr></table></figure>\n<p>其中，[]内为可选项，它是用来规定排序的规则的，默认是简单的升序排序。如果要实现稍复杂的排序，就需要我们自行构建比较函数内部的规则了（比如此题构建的cmp()函数）。</p>\n<p>下面详解一下cmp()函数的构造细节：</p>\n<ol>\n<li>先按考生类别由低到高排序</li>\n<li>同一类别考生，按德才总分由高到低排序</li>\n<li>同类考生，德才总分相同时按德分降序排序</li>\n<li>同类考生，德分才分均相同时按准考证号的升序排序</li>\n</ol>\n<p>构造完cmp()后，一句代码即可完成本题排序，简单粗暴有效！<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort(stu,stu + n,cmp);<span class=\"comment\">//注意sort()函数的第二个参数为最后一个元素的下一个位置</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>毫无疑问，在上机考试中最适合使用的语言就是C语言和C++了，虽然java和python用的人更多，但是它们的执行效率相对于C/C++而言要慢很多，经常会造成超时。因此，我所做的示例代码一般都是C/C++来写的，前面的几道题为了让大家适应，我选择了用全C语言的方式，但是C语言虽然有很多优点，但是它是有一些不太顺手的规则的，C++是向下兼容C的，而且C++中有一些比较好用的特性可以使我们的编程更便捷，因此，接下来题目的示例代码中，我将逐步加入C++的一些元素。请注意，以后的代码在编辑器中一定要保存为<code>.cpp</code>文件，这是C++文件的扩展名，这是为了利用C++的一些好的特性。<br>C++标准中头文件书写格式一般为<code>cstdio</code>，它等价于C语言的<code>stdio.h</code>的写法。推荐以后用C++的书写形式，即</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>你可能会觉得C语言的标准格式输入输出函数scanf和printf太麻烦，因为它还要指定输入输出格式，而C++的cin和cout相比而言就显得非常简单。但是，我还是建议大家用scanf和printf来进行输入输出，因为，cin和cout要比scanf和printf消耗更多的时间，很容易在输入输出中产生超时。</p>\n<p>C++的main()函数位置上面一般会有一句</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br></pre></td></tr></table></figure>\n<p>所谓namespace，即为名字空间，标准C++中引入名字空间的概念，把标准库里面的一些东西封装到std名字空间中。使用using编译命令导入所有的名称。使用C++的一些标准模版库时，一般需要添加此句。初学者，每一个C++程序最好都这样做。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">student</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;<span class=\"comment\">//准考证号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mor_score;<span class=\"comment\">//德分</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> abi_score;<span class=\"comment\">//才分</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> category;<span class=\"comment\">//类别</span></span><br><span class=\"line\">&#125;stu[MAXN];</span><br><span class=\"line\"><span class=\"comment\">//排序规则函数cmp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(student a, student b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.category != b.category)&#123;<span class=\"comment\">//先按考生类别由低到高排序</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.category &lt; b.category;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//同一类别考生，按德才总分由高到低排序</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((a.mor_score + a.abi_score) != (b.mor_score + b.abi_score))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (a.mor_score + a.abi_score) &gt; (b.mor_score + b.abi_score);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//同类考生，德才总分相同时按德分降序排序</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a.mor_score != b.mor_score)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.mor_score &gt; b.mor_score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//同类考生，德分才分均相同时按准考证号的升序输出</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.id &lt; b.id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,l,h,i,cou = <span class=\"number\">0</span>;<span class=\"comment\">//cou统计未达标考生人数</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;n,&amp;l,&amp;h);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;stu[i].id,&amp;stu[i].mor_score,&amp;stu[i].abi_score);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(stu[i].mor_score &gt;= h&amp;&amp;stu[i].abi_score &gt;= h)&#123;</span><br><span class=\"line\">            stu[i].category = <span class=\"number\">1</span>;<span class=\"comment\">//第一类考生，即“德才全尽”</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(stu[i].mor_score &gt;= h&amp;&amp;stu[i].abi_score &gt;= l)&#123;</span><br><span class=\"line\">            stu[i].category = <span class=\"number\">2</span>;<span class=\"comment\">//第二类考生，即“德胜才”</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(stu[i].mor_score &gt;= l&amp;&amp;stu[i].abi_score &gt;= l</span><br><span class=\"line\">                &amp;&amp;stu[i].mor_score &gt;= stu[i].abi_score)&#123;</span><br><span class=\"line\">            stu[i].category = <span class=\"number\">3</span>;<span class=\"comment\">//第三类考生，即“才德兼亡”但尚有“德胜才”</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(stu[i].mor_score &gt;= l&amp;&amp;stu[i].abi_score &gt;= l)&#123;</span><br><span class=\"line\">            stu[i].category = <span class=\"number\">4</span>;<span class=\"comment\">//第四类考生，即其他达到最低线 L 的考生</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            stu[i].category = <span class=\"number\">5</span>;<span class=\"comment\">//第五类考生，未达最低线，不参与排名</span></span><br><span class=\"line\">            cou++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(stu,stu + n,cmp);<span class=\"comment\">//注意sort()函数的第二个参数为最后一个元素的下一个位置</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,n-cou);<span class=\"comment\">//输出达标考生人数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n-cou; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d %d\\n\"</span>,stu[i].id,stu[i].mor_score,stu[i].abi_score);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1015<br>作者：CHEN, Li<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1016 || 部分A+B（详解，C/C++示例，测试点分析）","date":"2019-08-18T05:04:01.000Z","mathjax":true,"_content":"\n# **部分A+B**\n## 题目描述\n正整数 A 的“D(A)（为 1 位整数）部分”定义为由 A 中所有 D(A) 组成的新整数 P(A) 。例如：给定A=3862767，D(A)=6，则 A 的“6 部分”P(A)是 66，因为 A 中有 2 个 6。\n现给定 A、D(A) 、B、D(B)，请编写程序计算 P(A)+P(B)。\n\n## 输入格式\n输入在一行中依次给出 A、D(A) 、B、D(B)，中间以空格分隔，其中 0<A,B<$10^{10}$。\n## 输出格式\n在一行中输出 P(A) +P(B) 的值。\n## 输入样例1\n```null\n3862767 6 13530293 3\n```\n## 输出样例1\n```null\n399\n```\n## 输入样例2\n```null\n3862767 1 13530293 8\n```\n## 输出样例2\n```null\n0\n```\n\n## 问题解决\n### 解题思想\n本题思路比较简单。因为求a的da部分（即pa）与求b的db部分（即pb）是重复的过程，故定义一个求x的dx部分的函数。将一个多位整数的各位提取出来是一个常见的过程，提取之后再进行判断处理即可。注意要把a,b,x定义为long long型，由题给范围很容易看出来。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\nusing namespace std;\nlong long Calculate_D(long long x,int dx);\nint main()\n{\n    long long a,b,pa,pb;\n    int da,db;\n    scanf(\"%lld%d%lld%d\",&a,&da,&b,&db);\n    pa = Calculate_D(a,da);\n    pb = Calculate_D(b,db);\n    printf(\"%lld\\n\",pa + pb);\n    return 0;\n}\n//计算正整数 x 的“dx（为 1 位整数）部分”\nlong long Calculate_D(long long x,int dx)\n{\n    long long px = 0;\n    while(x){\n        if(x % 10 == dx){\n            px = px * 10 + dx;\n        }\n        x = x / 10;//不要忽略此处，否则将进入死循环\n    }\n    return px;\n}\n```\n\n>题目来源：PAT乙级1016\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat乙级1016.md","raw":"---\ntitle: PAT乙级1016 || 部分A+B（详解，C/C++示例，测试点分析）\ndate: 2019-08-18 13:04:01\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **部分A+B**\n## 题目描述\n正整数 A 的“D(A)（为 1 位整数）部分”定义为由 A 中所有 D(A) 组成的新整数 P(A) 。例如：给定A=3862767，D(A)=6，则 A 的“6 部分”P(A)是 66，因为 A 中有 2 个 6。\n现给定 A、D(A) 、B、D(B)，请编写程序计算 P(A)+P(B)。\n\n## 输入格式\n输入在一行中依次给出 A、D(A) 、B、D(B)，中间以空格分隔，其中 0<A,B<$10^{10}$。\n## 输出格式\n在一行中输出 P(A) +P(B) 的值。\n## 输入样例1\n```null\n3862767 6 13530293 3\n```\n## 输出样例1\n```null\n399\n```\n## 输入样例2\n```null\n3862767 1 13530293 8\n```\n## 输出样例2\n```null\n0\n```\n\n## 问题解决\n### 解题思想\n本题思路比较简单。因为求a的da部分（即pa）与求b的db部分（即pb）是重复的过程，故定义一个求x的dx部分的函数。将一个多位整数的各位提取出来是一个常见的过程，提取之后再进行判断处理即可。注意要把a,b,x定义为long long型，由题给范围很容易看出来。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\nusing namespace std;\nlong long Calculate_D(long long x,int dx);\nint main()\n{\n    long long a,b,pa,pb;\n    int da,db;\n    scanf(\"%lld%d%lld%d\",&a,&da,&b,&db);\n    pa = Calculate_D(a,da);\n    pb = Calculate_D(b,db);\n    printf(\"%lld\\n\",pa + pb);\n    return 0;\n}\n//计算正整数 x 的“dx（为 1 位整数）部分”\nlong long Calculate_D(long long x,int dx)\n{\n    long long px = 0;\n    while(x){\n        if(x % 10 == dx){\n            px = px * 10 + dx;\n        }\n        x = x / 10;//不要忽略此处，否则将进入死循环\n    }\n    return px;\n}\n```\n\n>题目来源：PAT乙级1016\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat乙级1016","published":1,"updated":"2019-08-21T04:56:33.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwffl002dfk0r23509kty","content":"<h1 id=\"部分A-B\"><a href=\"#部分A-B\" class=\"headerlink\" title=\"部分A+B\"></a><strong>部分A+B</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>正整数 A 的“D(A)（为 1 位整数）部分”定义为由 A 中所有 D(A) 组成的新整数 P(A) 。例如：给定A=3862767，D(A)=6，则 A 的“6 部分”P(A)是 66，因为 A 中有 2 个 6。<br>现给定 A、D(A) 、B、D(B)，请编写程序计算 P(A)+P(B)。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>输入在一行中依次给出 A、D(A) 、B、D(B)，中间以空格分隔，其中 0&lt;A,B&lt;$10^{10}$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>在一行中输出 P(A) +P(B) 的值。</p>\n<h2 id=\"输入样例1\"><a href=\"#输入样例1\" class=\"headerlink\" title=\"输入样例1\"></a>输入样例1</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3862767 6 13530293 3</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例1\"><a href=\"#输出样例1\" class=\"headerlink\" title=\"输出样例1\"></a>输出样例1</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">399</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输入样例2\"><a href=\"#输入样例2\" class=\"headerlink\" title=\"输入样例2\"></a>输入样例2</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3862767 1 13530293 8</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例2\"><a href=\"#输出样例2\" class=\"headerlink\" title=\"输出样例2\"></a>输出样例2</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题思路比较简单。因为求a的da部分（即pa）与求b的db部分（即pb）是重复的过程，故定义一个求x的dx部分的函数。将一个多位整数的各位提取出来是一个常见的过程，提取之后再进行判断处理即可。注意要把a,b,x定义为long long型，由题给范围很容易看出来。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">Calculate_D</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x,<span class=\"keyword\">int</span> dx)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a,b,pa,pb;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> da,db;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld%d%lld%d\"</span>,&amp;a,&amp;da,&amp;b,&amp;db);</span><br><span class=\"line\">    pa = Calculate_D(a,da);</span><br><span class=\"line\">    pb = Calculate_D(b,db);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,pa + pb);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//计算正整数 x 的“dx（为 1 位整数）部分”</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">Calculate_D</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x,<span class=\"keyword\">int</span> dx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> px = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x % <span class=\"number\">10</span> == dx)&#123;</span><br><span class=\"line\">            px = px * <span class=\"number\">10</span> + dx;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x = x / <span class=\"number\">10</span>;<span class=\"comment\">//不要忽略此处，否则将进入死循环</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1016<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"部分A-B\"><a href=\"#部分A-B\" class=\"headerlink\" title=\"部分A+B\"></a><strong>部分A+B</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>正整数 A 的“D(A)（为 1 位整数）部分”定义为由 A 中所有 D(A) 组成的新整数 P(A) 。例如：给定A=3862767，D(A)=6，则 A 的“6 部分”P(A)是 66，因为 A 中有 2 个 6。<br>现给定 A、D(A) 、B、D(B)，请编写程序计算 P(A)+P(B)。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>输入在一行中依次给出 A、D(A) 、B、D(B)，中间以空格分隔，其中 0&lt;A,B&lt;$10^{10}$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>在一行中输出 P(A) +P(B) 的值。</p>\n<h2 id=\"输入样例1\"><a href=\"#输入样例1\" class=\"headerlink\" title=\"输入样例1\"></a>输入样例1</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3862767 6 13530293 3</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例1\"><a href=\"#输出样例1\" class=\"headerlink\" title=\"输出样例1\"></a>输出样例1</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">399</span><br></pre></td></tr></table></figure>\n<h2 id=\"输入样例2\"><a href=\"#输入样例2\" class=\"headerlink\" title=\"输入样例2\"></a>输入样例2</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3862767 1 13530293 8</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例2\"><a href=\"#输出样例2\" class=\"headerlink\" title=\"输出样例2\"></a>输出样例2</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题思路比较简单。因为求a的da部分（即pa）与求b的db部分（即pb）是重复的过程，故定义一个求x的dx部分的函数。将一个多位整数的各位提取出来是一个常见的过程，提取之后再进行判断处理即可。注意要把a,b,x定义为long long型，由题给范围很容易看出来。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">Calculate_D</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x,<span class=\"keyword\">int</span> dx)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a,b,pa,pb;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> da,db;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld%d%lld%d\"</span>,&amp;a,&amp;da,&amp;b,&amp;db);</span><br><span class=\"line\">    pa = Calculate_D(a,da);</span><br><span class=\"line\">    pb = Calculate_D(b,db);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,pa + pb);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//计算正整数 x 的“dx（为 1 位整数）部分”</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">Calculate_D</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x,<span class=\"keyword\">int</span> dx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> px = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x % <span class=\"number\">10</span> == dx)&#123;</span><br><span class=\"line\">            px = px * <span class=\"number\">10</span> + dx;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x = x / <span class=\"number\">10</span>;<span class=\"comment\">//不要忽略此处，否则将进入死循环</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1016<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1017 || A除以B（详解，C/C++示例，测试点分析）","date":"2019-08-18T05:04:19.000Z","_content":"\n# **A除以B**\n## **题目描述**\n本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。\n## **输入格式**\n输入在一行中依次给出 A 和 B，中间以 1 空格分隔。\n## **输出格式**\n在一行中依次输出 Q 和 R，中间以 1 空格分隔。\n## **输入样例**\n```null\n123456789050987654321 7\n```\n## **输出样例**\n```null\n17636684150141093474 3\n```\n\n## 问题解决\n### 解题思想\n此题主要需解决一下几个问题：\n* 大数的存储和输入问题。\n* 大数除以一位正整数的具体实施过程\n* 执行除法的过程中特殊情况的处理\n\n由于A 是不超过 1000 位的正整数，因此只能用数组来存储A的每一位数字，因为要将大数的每一位存入数组的每一个元素，因此，我们用字符数组接收输入更方便。当遇到空格时即为大数输入结束。接下来用c来逐步实现大数的除法。c先初始化为0，然后将大数从最高位到最低位逐步赋给c，当c除以b有余数时，余数作为c下一次的十位，大数的下一位作为c下一次的个位，除第一位和最后一位外，其它余数为0且下一位小于除数b时商均需补0（此除法过程就是模拟笔算除法的过程，相应的细节可模拟笔算除法理解）。\n\n除了上面**除第一位和最后一位外，其它余数为0且下一位小于除数b时商均需补0**这一特殊情况外，还应注意以下两个特殊情况：\n\n* 测试用例的输入中有**大数的最高几位均为0的情况**（例如00012345），c被赋值这几位时是不能有输出的，我们用flag来控制即可。\n* 测试用例的输入中有**a小于b的情况**，此时退出for循环后是没有输出的（此时退出for循环后flag为0），在for循环外需要作额外处理（输出0）。\n\n### 知识拓展\n我们知道在C语言中，所有变量的定义和声明都必须在函数的开头处，而且变量定义和声明的前面不能有任何其它非声明定义的语句。而在C++中，就没有这么严格的规定了，只要在用到变量前对该变量进行定义和声明就可以，定义和声明的位置是比较灵活的（比如下面代码定义变量的位置）。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#define MAXN 1001\nusing namespace std;\nint main()\n{\n    char a[MAXN];//用字符数组来存输入的大数\n    int i = 0;\n    //输入大数\n    do{\n        a[i] = getchar();\n        i++;\n    }while(a[i-1] != ' ');//遇到空格时大数输入结束,\n    int b;                //由于输入之后i自增了1，因此判断时i需减1\n    scanf(\"%d\",&b);//输入除数\n    int c = 0;//c存当前处理的大数的部分\n    int flag = 0;\n    for(i = 0; a[i] != ' '; i++){\n        c += a[i] - '0';\n        if(c >= b){\n            printf(\"%d\",c / b);\n            c %= b;\n            flag = 1;\n        }\n        if(c == 0&&a[i+1] != ' '&&(a[i+1] - '0') < b&&flag){\n            printf(\"0\");//除第一位和最后一位外，其它余数为0\n        }               //且下一位小于除数b时均需补0\n        c *= 10;\n    }\n    if(!flag){//如果大数小于b即flag为0也就是上面的for循环没有输出，则在此处输出0\n        printf(\"0\");\n    }\n    int q;\n    q = c / 10;//循环退出时，余数多乘了10\n    printf(\" %d\\n\",q);\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1017\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat乙级1017.md","raw":"---\ntitle: PAT乙级1017 || A除以B（详解，C/C++示例，测试点分析）\ndate: 2019-08-18 13:04:19\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **A除以B**\n## **题目描述**\n本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。\n## **输入格式**\n输入在一行中依次给出 A 和 B，中间以 1 空格分隔。\n## **输出格式**\n在一行中依次输出 Q 和 R，中间以 1 空格分隔。\n## **输入样例**\n```null\n123456789050987654321 7\n```\n## **输出样例**\n```null\n17636684150141093474 3\n```\n\n## 问题解决\n### 解题思想\n此题主要需解决一下几个问题：\n* 大数的存储和输入问题。\n* 大数除以一位正整数的具体实施过程\n* 执行除法的过程中特殊情况的处理\n\n由于A 是不超过 1000 位的正整数，因此只能用数组来存储A的每一位数字，因为要将大数的每一位存入数组的每一个元素，因此，我们用字符数组接收输入更方便。当遇到空格时即为大数输入结束。接下来用c来逐步实现大数的除法。c先初始化为0，然后将大数从最高位到最低位逐步赋给c，当c除以b有余数时，余数作为c下一次的十位，大数的下一位作为c下一次的个位，除第一位和最后一位外，其它余数为0且下一位小于除数b时商均需补0（此除法过程就是模拟笔算除法的过程，相应的细节可模拟笔算除法理解）。\n\n除了上面**除第一位和最后一位外，其它余数为0且下一位小于除数b时商均需补0**这一特殊情况外，还应注意以下两个特殊情况：\n\n* 测试用例的输入中有**大数的最高几位均为0的情况**（例如00012345），c被赋值这几位时是不能有输出的，我们用flag来控制即可。\n* 测试用例的输入中有**a小于b的情况**，此时退出for循环后是没有输出的（此时退出for循环后flag为0），在for循环外需要作额外处理（输出0）。\n\n### 知识拓展\n我们知道在C语言中，所有变量的定义和声明都必须在函数的开头处，而且变量定义和声明的前面不能有任何其它非声明定义的语句。而在C++中，就没有这么严格的规定了，只要在用到变量前对该变量进行定义和声明就可以，定义和声明的位置是比较灵活的（比如下面代码定义变量的位置）。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#define MAXN 1001\nusing namespace std;\nint main()\n{\n    char a[MAXN];//用字符数组来存输入的大数\n    int i = 0;\n    //输入大数\n    do{\n        a[i] = getchar();\n        i++;\n    }while(a[i-1] != ' ');//遇到空格时大数输入结束,\n    int b;                //由于输入之后i自增了1，因此判断时i需减1\n    scanf(\"%d\",&b);//输入除数\n    int c = 0;//c存当前处理的大数的部分\n    int flag = 0;\n    for(i = 0; a[i] != ' '; i++){\n        c += a[i] - '0';\n        if(c >= b){\n            printf(\"%d\",c / b);\n            c %= b;\n            flag = 1;\n        }\n        if(c == 0&&a[i+1] != ' '&&(a[i+1] - '0') < b&&flag){\n            printf(\"0\");//除第一位和最后一位外，其它余数为0\n        }               //且下一位小于除数b时均需补0\n        c *= 10;\n    }\n    if(!flag){//如果大数小于b即flag为0也就是上面的for循环没有输出，则在此处输出0\n        printf(\"0\");\n    }\n    int q;\n    q = c / 10;//循环退出时，余数多乘了10\n    printf(\" %d\\n\",q);\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1017\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat乙级1017","published":1,"updated":"2019-08-21T04:56:47.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwffo002gfk0rln81vbam","content":"<h1 id=\"A除以B\"><a href=\"#A除以B\" class=\"headerlink\" title=\"A除以B\"></a><strong>A除以B</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行中依次给出 A 和 B，中间以 1 空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中依次输出 Q 和 R，中间以 1 空格分隔。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">123456789050987654321 7</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">17636684150141093474 3</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题主要需解决一下几个问题：</p>\n<ul>\n<li>大数的存储和输入问题。</li>\n<li>大数除以一位正整数的具体实施过程</li>\n<li>执行除法的过程中特殊情况的处理</li>\n</ul>\n<p>由于A 是不超过 1000 位的正整数，因此只能用数组来存储A的每一位数字，因为要将大数的每一位存入数组的每一个元素，因此，我们用字符数组接收输入更方便。当遇到空格时即为大数输入结束。接下来用c来逐步实现大数的除法。c先初始化为0，然后将大数从最高位到最低位逐步赋给c，当c除以b有余数时，余数作为c下一次的十位，大数的下一位作为c下一次的个位，除第一位和最后一位外，其它余数为0且下一位小于除数b时商均需补0（此除法过程就是模拟笔算除法的过程，相应的细节可模拟笔算除法理解）。</p>\n<p>除了上面<strong>除第一位和最后一位外，其它余数为0且下一位小于除数b时商均需补0</strong>这一特殊情况外，还应注意以下两个特殊情况：</p>\n<ul>\n<li>测试用例的输入中有<strong>大数的最高几位均为0的情况</strong>（例如00012345），c被赋值这几位时是不能有输出的，我们用flag来控制即可。</li>\n<li>测试用例的输入中有<strong>a小于b的情况</strong>，此时退出for循环后是没有输出的（此时退出for循环后flag为0），在for循环外需要作额外处理（输出0）。</li>\n</ul>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>我们知道在C语言中，所有变量的定义和声明都必须在函数的开头处，而且变量定义和声明的前面不能有任何其它非声明定义的语句。而在C++中，就没有这么严格的规定了，只要在用到变量前对该变量进行定义和声明就可以，定义和声明的位置是比较灵活的（比如下面代码定义变量的位置）。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a[MAXN];<span class=\"comment\">//用字符数组来存输入的大数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//输入大数</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        a[i] = getchar();</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(a[i<span class=\"number\">-1</span>] != <span class=\"string\">' '</span>);<span class=\"comment\">//遇到空格时大数输入结束,</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;                <span class=\"comment\">//由于输入之后i自增了1，因此判断时i需减1</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;b);<span class=\"comment\">//输入除数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;<span class=\"comment\">//c存当前处理的大数的部分</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; a[i] != <span class=\"string\">' '</span>; i++)&#123;</span><br><span class=\"line\">        c += a[i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c &gt;= b)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,c / b);</span><br><span class=\"line\">            c %= b;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c == <span class=\"number\">0</span>&amp;&amp;a[i+<span class=\"number\">1</span>] != <span class=\"string\">' '</span>&amp;&amp;(a[i+<span class=\"number\">1</span>] - <span class=\"string\">'0'</span>) &lt; b&amp;&amp;flag)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\"</span>);<span class=\"comment\">//除第一位和最后一位外，其它余数为0</span></span><br><span class=\"line\">        &#125;               <span class=\"comment\">//且下一位小于除数b时均需补0</span></span><br><span class=\"line\">        c *= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!flag)&#123;<span class=\"comment\">//如果大数小于b即flag为0也就是上面的for循环没有输出，则在此处输出0</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> q;</span><br><span class=\"line\">    q = c / <span class=\"number\">10</span>;<span class=\"comment\">//循环退出时，余数多乘了10</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\\n\"</span>,q);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1017<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"A除以B\"><a href=\"#A除以B\" class=\"headerlink\" title=\"A除以B\"></a><strong>A除以B</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行中依次给出 A 和 B，中间以 1 空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中依次输出 Q 和 R，中间以 1 空格分隔。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">123456789050987654321 7</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">17636684150141093474 3</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题主要需解决一下几个问题：</p>\n<ul>\n<li>大数的存储和输入问题。</li>\n<li>大数除以一位正整数的具体实施过程</li>\n<li>执行除法的过程中特殊情况的处理</li>\n</ul>\n<p>由于A 是不超过 1000 位的正整数，因此只能用数组来存储A的每一位数字，因为要将大数的每一位存入数组的每一个元素，因此，我们用字符数组接收输入更方便。当遇到空格时即为大数输入结束。接下来用c来逐步实现大数的除法。c先初始化为0，然后将大数从最高位到最低位逐步赋给c，当c除以b有余数时，余数作为c下一次的十位，大数的下一位作为c下一次的个位，除第一位和最后一位外，其它余数为0且下一位小于除数b时商均需补0（此除法过程就是模拟笔算除法的过程，相应的细节可模拟笔算除法理解）。</p>\n<p>除了上面<strong>除第一位和最后一位外，其它余数为0且下一位小于除数b时商均需补0</strong>这一特殊情况外，还应注意以下两个特殊情况：</p>\n<ul>\n<li>测试用例的输入中有<strong>大数的最高几位均为0的情况</strong>（例如00012345），c被赋值这几位时是不能有输出的，我们用flag来控制即可。</li>\n<li>测试用例的输入中有<strong>a小于b的情况</strong>，此时退出for循环后是没有输出的（此时退出for循环后flag为0），在for循环外需要作额外处理（输出0）。</li>\n</ul>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>我们知道在C语言中，所有变量的定义和声明都必须在函数的开头处，而且变量定义和声明的前面不能有任何其它非声明定义的语句。而在C++中，就没有这么严格的规定了，只要在用到变量前对该变量进行定义和声明就可以，定义和声明的位置是比较灵活的（比如下面代码定义变量的位置）。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a[MAXN];<span class=\"comment\">//用字符数组来存输入的大数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//输入大数</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        a[i] = getchar();</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(a[i<span class=\"number\">-1</span>] != <span class=\"string\">' '</span>);<span class=\"comment\">//遇到空格时大数输入结束,</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;                <span class=\"comment\">//由于输入之后i自增了1，因此判断时i需减1</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;b);<span class=\"comment\">//输入除数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;<span class=\"comment\">//c存当前处理的大数的部分</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; a[i] != <span class=\"string\">' '</span>; i++)&#123;</span><br><span class=\"line\">        c += a[i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c &gt;= b)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,c / b);</span><br><span class=\"line\">            c %= b;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c == <span class=\"number\">0</span>&amp;&amp;a[i+<span class=\"number\">1</span>] != <span class=\"string\">' '</span>&amp;&amp;(a[i+<span class=\"number\">1</span>] - <span class=\"string\">'0'</span>) &lt; b&amp;&amp;flag)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\"</span>);<span class=\"comment\">//除第一位和最后一位外，其它余数为0</span></span><br><span class=\"line\">        &#125;               <span class=\"comment\">//且下一位小于除数b时均需补0</span></span><br><span class=\"line\">        c *= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!flag)&#123;<span class=\"comment\">//如果大数小于b即flag为0也就是上面的for循环没有输出，则在此处输出0</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> q;</span><br><span class=\"line\">    q = c / <span class=\"number\">10</span>;<span class=\"comment\">//循环退出时，余数多乘了10</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\\n\"</span>,q);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1017<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1018 || 锤子剪刀布（详解，C/C++示例，测试点分析）","date":"2019-08-18T05:04:29.000Z","mathjax":true,"_content":"\n# **锤子剪刀布**\n## **题目描述**\n大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：![图解](https://images.ptausercontent.com/724da598-b37f-4f1f-99b4-71459654ce3a.jpg)\n现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。\n## **输入格式**\n输入第 1 行给出正整数 N（≤$10^5$），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。\n## **输出格式**\n输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。\n## **输入样例**\n```null\n10\nC J\nJ B\nC B\nB B\nB C\nC C\nC B\nJ B\nB C\nJ J\n```\n## **输出样例**\n```null\n5 3 2\n2 3 5\nB B\n```\n\n## 问题解决\n### 解题思想\n本题的思路并不复杂，只要注意几个要点，然后按照题目要求书写代码即可。要点如下：\n* 读入字符前要先把换行符吸收掉，否则将会把换行符读入。可采用`getchar()`函数\n* 读入字符时两个字符之间的空格要额外吸收掉，否则将会把空格读入。可采用`%*c`实现\n* 如果解不唯一，则输出按字母序最小的解。可通过如下方式实现：用字符数组存入手势时，可按字母序存入，把max[]初始化为子母序最小的下标。\n\n### 知识拓展\n在用`%c`格式读入字符时，空格字符、转义字符及回车都会被当作有效字符读入。`%*c`可实现相应位置字符只读入，不赋予相应的变量，从而可实现吸收两个字符之间的空格。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\nusing namespace std;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    char c[2];//甲乙当前的手势\n    int win[2] = {0},draw[2] = {0},fail[2] = {0};//甲乙胜、平、负的次数，均初始化为0\n    char gesture[3] = {'B','C','J'};//存入各手势，字符别忘了加单引号\n    int ges[2][3] = {0};//甲乙各手势的获胜次数，均初始化为0\n    while(n--){\n        getchar();//吸收掉缓冲区的换行符\n        scanf(\"%c%*c%c\",&c[0],&c[1]);//注意要吸收掉两个字符之间的空格\n        if(c[0] == c[1]){\n            draw[0]++;\n            draw[1]++;\n        }\n        else if(c[0] == 'B'){\n            if(c[1] == 'C'){\n                win[0]++;\n                fail[1]++;\n                ges[0][0]++;\n            }\n            else{\n                win[1]++;\n                fail[0]++;\n                ges[1][2]++;\n            }\n        }\n        else if(c[0] == 'C'){\n            if(c[1] == 'J'){\n                win[0]++;\n                fail[1]++;\n                ges[0][1]++;\n            }\n            else{\n                win[1]++;\n                fail[0]++;\n                ges[1][0]++;\n            }\n        }\n        else if(c[0] == 'J'){\n            if(c[1] == 'B'){\n                win[0]++;\n                fail[1]++;\n                ges[0][2]++;\n            }\n            else{\n                win[1]++;\n                fail[0]++;\n                ges[1][1]++;\n            }\n        }\n    }\n    for(int i = 0; i < 2; i++){\n        printf(\"%d %d %d\\n\",win[i],draw[i],fail[i]);\n    }\n    int max[2] = {0};//存入甲乙获胜次数最多的手势的下标，若不唯一，则存入按字母序最小的\n    for(int j = 0; j < 2; j++){\n        for(int i = 1; i < 3; i++){\n            if(ges[j][i] > ges[j][max[j]]){\n                max[j] = i;\n            }\n        }\n    }\n    printf(\"%c %c\\n\",gesture[max[0]],gesture[max[1]]);\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1018\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat乙级1018.md","raw":"---\ntitle: PAT乙级1018 || 锤子剪刀布（详解，C/C++示例，测试点分析）\ndate: 2019-08-18 13:04:29\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **锤子剪刀布**\n## **题目描述**\n大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：![图解](https://images.ptausercontent.com/724da598-b37f-4f1f-99b4-71459654ce3a.jpg)\n现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。\n## **输入格式**\n输入第 1 行给出正整数 N（≤$10^5$），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。\n## **输出格式**\n输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。\n## **输入样例**\n```null\n10\nC J\nJ B\nC B\nB B\nB C\nC C\nC B\nJ B\nB C\nJ J\n```\n## **输出样例**\n```null\n5 3 2\n2 3 5\nB B\n```\n\n## 问题解决\n### 解题思想\n本题的思路并不复杂，只要注意几个要点，然后按照题目要求书写代码即可。要点如下：\n* 读入字符前要先把换行符吸收掉，否则将会把换行符读入。可采用`getchar()`函数\n* 读入字符时两个字符之间的空格要额外吸收掉，否则将会把空格读入。可采用`%*c`实现\n* 如果解不唯一，则输出按字母序最小的解。可通过如下方式实现：用字符数组存入手势时，可按字母序存入，把max[]初始化为子母序最小的下标。\n\n### 知识拓展\n在用`%c`格式读入字符时，空格字符、转义字符及回车都会被当作有效字符读入。`%*c`可实现相应位置字符只读入，不赋予相应的变量，从而可实现吸收两个字符之间的空格。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\nusing namespace std;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    char c[2];//甲乙当前的手势\n    int win[2] = {0},draw[2] = {0},fail[2] = {0};//甲乙胜、平、负的次数，均初始化为0\n    char gesture[3] = {'B','C','J'};//存入各手势，字符别忘了加单引号\n    int ges[2][3] = {0};//甲乙各手势的获胜次数，均初始化为0\n    while(n--){\n        getchar();//吸收掉缓冲区的换行符\n        scanf(\"%c%*c%c\",&c[0],&c[1]);//注意要吸收掉两个字符之间的空格\n        if(c[0] == c[1]){\n            draw[0]++;\n            draw[1]++;\n        }\n        else if(c[0] == 'B'){\n            if(c[1] == 'C'){\n                win[0]++;\n                fail[1]++;\n                ges[0][0]++;\n            }\n            else{\n                win[1]++;\n                fail[0]++;\n                ges[1][2]++;\n            }\n        }\n        else if(c[0] == 'C'){\n            if(c[1] == 'J'){\n                win[0]++;\n                fail[1]++;\n                ges[0][1]++;\n            }\n            else{\n                win[1]++;\n                fail[0]++;\n                ges[1][0]++;\n            }\n        }\n        else if(c[0] == 'J'){\n            if(c[1] == 'B'){\n                win[0]++;\n                fail[1]++;\n                ges[0][2]++;\n            }\n            else{\n                win[1]++;\n                fail[0]++;\n                ges[1][1]++;\n            }\n        }\n    }\n    for(int i = 0; i < 2; i++){\n        printf(\"%d %d %d\\n\",win[i],draw[i],fail[i]);\n    }\n    int max[2] = {0};//存入甲乙获胜次数最多的手势的下标，若不唯一，则存入按字母序最小的\n    for(int j = 0; j < 2; j++){\n        for(int i = 1; i < 3; i++){\n            if(ges[j][i] > ges[j][max[j]]){\n                max[j] = i;\n            }\n        }\n    }\n    printf(\"%c %c\\n\",gesture[max[0]],gesture[max[1]]);\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1018\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat乙级1018","published":1,"updated":"2019-08-21T04:56:59.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwffq002jfk0rf0w96ozz","content":"<h1 id=\"锤子剪刀布\"><a href=\"#锤子剪刀布\" class=\"headerlink\" title=\"锤子剪刀布\"></a><strong>锤子剪刀布</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：<img src=\"https://images.ptausercontent.com/724da598-b37f-4f1f-99b4-71459654ce3a.jpg\" alt=\"图解\"><br>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入第 1 行给出正整数 N（≤$10^5$），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">C J</span><br><span class=\"line\">J B</span><br><span class=\"line\">C B</span><br><span class=\"line\">B B</span><br><span class=\"line\">B C</span><br><span class=\"line\">C C</span><br><span class=\"line\">C B</span><br><span class=\"line\">J B</span><br><span class=\"line\">B C</span><br><span class=\"line\">J J</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 3 2</span><br><span class=\"line\">2 3 5</span><br><span class=\"line\">B B</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题的思路并不复杂，只要注意几个要点，然后按照题目要求书写代码即可。要点如下：</p>\n<ul>\n<li>读入字符前要先把换行符吸收掉，否则将会把换行符读入。可采用<code>getchar()</code>函数</li>\n<li>读入字符时两个字符之间的空格要额外吸收掉，否则将会把空格读入。可采用<code>%*c</code>实现</li>\n<li>如果解不唯一，则输出按字母序最小的解。可通过如下方式实现：用字符数组存入手势时，可按字母序存入，把max[]初始化为子母序最小的下标。</li>\n</ul>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>在用<code>%c</code>格式读入字符时，空格字符、转义字符及回车都会被当作有效字符读入。<code>%*c</code>可实现相应位置字符只读入，不赋予相应的变量，从而可实现吸收两个字符之间的空格。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c[<span class=\"number\">2</span>];<span class=\"comment\">//甲乙当前的手势</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> win[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;,draw[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;,fail[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;;<span class=\"comment\">//甲乙胜、平、负的次数，均初始化为0</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> gesture[<span class=\"number\">3</span>] = &#123;<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'J'</span>&#125;;<span class=\"comment\">//存入各手势，字符别忘了加单引号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ges[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>&#125;;<span class=\"comment\">//甲乙各手势的获胜次数，均初始化为0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        getchar();<span class=\"comment\">//吸收掉缓冲区的换行符</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c%*c%c\"</span>,&amp;c[<span class=\"number\">0</span>],&amp;c[<span class=\"number\">1</span>]);<span class=\"comment\">//注意要吸收掉两个字符之间的空格</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == c[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">            draw[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">            draw[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'B'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[<span class=\"number\">1</span>] == <span class=\"string\">'C'</span>)&#123;</span><br><span class=\"line\">                win[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">0</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                win[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">1</span>][<span class=\"number\">2</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[<span class=\"number\">1</span>] == <span class=\"string\">'J'</span>)&#123;</span><br><span class=\"line\">                win[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">0</span>][<span class=\"number\">1</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                win[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">1</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'J'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[<span class=\"number\">1</span>] == <span class=\"string\">'B'</span>)&#123;</span><br><span class=\"line\">                win[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">0</span>][<span class=\"number\">2</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                win[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">1</span>][<span class=\"number\">1</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d %d\\n\"</span>,win[i],draw[i],fail[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;;<span class=\"comment\">//存入甲乙获胜次数最多的手势的下标，若不唯一，则存入按字母序最小的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">2</span>; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">3</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ges[j][i] &gt; ges[j][max[j]])&#123;</span><br><span class=\"line\">                max[j] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c %c\\n\"</span>,gesture[max[<span class=\"number\">0</span>]],gesture[max[<span class=\"number\">1</span>]]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1018<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"锤子剪刀布\"><a href=\"#锤子剪刀布\" class=\"headerlink\" title=\"锤子剪刀布\"></a><strong>锤子剪刀布</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：<img src=\"https://images.ptausercontent.com/724da598-b37f-4f1f-99b4-71459654ce3a.jpg\" alt=\"图解\"><br>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入第 1 行给出正整数 N（≤$10^5$），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">C J</span><br><span class=\"line\">J B</span><br><span class=\"line\">C B</span><br><span class=\"line\">B B</span><br><span class=\"line\">B C</span><br><span class=\"line\">C C</span><br><span class=\"line\">C B</span><br><span class=\"line\">J B</span><br><span class=\"line\">B C</span><br><span class=\"line\">J J</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 3 2</span><br><span class=\"line\">2 3 5</span><br><span class=\"line\">B B</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题的思路并不复杂，只要注意几个要点，然后按照题目要求书写代码即可。要点如下：</p>\n<ul>\n<li>读入字符前要先把换行符吸收掉，否则将会把换行符读入。可采用<code>getchar()</code>函数</li>\n<li>读入字符时两个字符之间的空格要额外吸收掉，否则将会把空格读入。可采用<code>%*c</code>实现</li>\n<li>如果解不唯一，则输出按字母序最小的解。可通过如下方式实现：用字符数组存入手势时，可按字母序存入，把max[]初始化为子母序最小的下标。</li>\n</ul>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>在用<code>%c</code>格式读入字符时，空格字符、转义字符及回车都会被当作有效字符读入。<code>%*c</code>可实现相应位置字符只读入，不赋予相应的变量，从而可实现吸收两个字符之间的空格。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c[<span class=\"number\">2</span>];<span class=\"comment\">//甲乙当前的手势</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> win[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;,draw[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;,fail[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;;<span class=\"comment\">//甲乙胜、平、负的次数，均初始化为0</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> gesture[<span class=\"number\">3</span>] = &#123;<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'J'</span>&#125;;<span class=\"comment\">//存入各手势，字符别忘了加单引号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ges[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>&#125;;<span class=\"comment\">//甲乙各手势的获胜次数，均初始化为0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        getchar();<span class=\"comment\">//吸收掉缓冲区的换行符</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c%*c%c\"</span>,&amp;c[<span class=\"number\">0</span>],&amp;c[<span class=\"number\">1</span>]);<span class=\"comment\">//注意要吸收掉两个字符之间的空格</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == c[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">            draw[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">            draw[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'B'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[<span class=\"number\">1</span>] == <span class=\"string\">'C'</span>)&#123;</span><br><span class=\"line\">                win[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">0</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                win[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">1</span>][<span class=\"number\">2</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[<span class=\"number\">1</span>] == <span class=\"string\">'J'</span>)&#123;</span><br><span class=\"line\">                win[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">0</span>][<span class=\"number\">1</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                win[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">1</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'J'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[<span class=\"number\">1</span>] == <span class=\"string\">'B'</span>)&#123;</span><br><span class=\"line\">                win[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">0</span>][<span class=\"number\">2</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                win[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">                fail[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">                ges[<span class=\"number\">1</span>][<span class=\"number\">1</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d %d\\n\"</span>,win[i],draw[i],fail[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>&#125;;<span class=\"comment\">//存入甲乙获胜次数最多的手势的下标，若不唯一，则存入按字母序最小的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">2</span>; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">3</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ges[j][i] &gt; ges[j][max[j]])&#123;</span><br><span class=\"line\">                max[j] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c %c\\n\"</span>,gesture[max[<span class=\"number\">0</span>]],gesture[max[<span class=\"number\">1</span>]]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1018<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1019 || 数字黑洞（详解，C/C++示例，测试点分析）","date":"2019-08-18T05:05:08.000Z","mathjax":true,"_content":"\n# **数字黑洞**\n## **题目描述**\n给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 `6174`，这个神奇的数字也叫 Kaprekar 常数。\n例如，我们从`6767`开始，将得到\n\n```null\n7766 - 6677 = 1089\n9810 - 0189 = 9621\n9621 - 1269 = 8352\n8532 - 2358 = 6174\n7641 - 1467 = 6174\n... ...\n```\n现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。\n## **输入格式**\n输入给出一个$ (0,10^4 )$ 区间内的正整数 N。\n## **输出格式**\n如果 *N* 的 4 位数字全相等，则在一行内输出 `N - N = 0000`；否则将计算的每一步在一行内输出，直到 `6174` 作为差出现，输出格式见样例。注意每个数字按 `4` 位数格式输出。\n## **输入样例1**\n```null\n6767\n```\n## **输出样例1**\n```null\n7766 - 6677 = 1089\n9810 - 0189 = 9621\n9621 - 1269 = 8352\n8532 - 2358 = 6174\n```\n## **输入样例2**\n```null\n2222\n```\n## **输出样例2**\n```null\n2222 - 2222 = 0000\n```\n\n## 问题解决\n### 解题思想\n设置num[]数组存放四位数的各位数字，num[3]存放千位，num[0]存放个位；提取出n的各位数字之后，采用C++标准库函数sort()对四位数字分别进行升序和降序的排序（注意sort()函数默认是按升序排序，降序排序时需要自行设置cmp_desc()函数以实现降序排序），然后将排序后的各位数字再次分别合成升序四位数asc和降序四位数des；最后按照四位数格式输出运算过程中的各整数。特别需要注意以下几点：\n* 题目中已经说明n一定是正整数，因此输入的n不会是0(第一次不会因此退出循环而导致无输出)，但n可能为`6174`，若n的输入为`6174`时，需要进入循环输出一次再退出循环，此处我用flag标记控制。（注：PAT评测系统是有一个测试点输入为`6174`的，若不特殊处理将导致此测试点不通过比如若将代码中while循环的条件改为下面的情况将产生部分错误）\n\n```cpp\nwhile(n != 0&&n != 6174)\n```\n* 注意题目要求按四位格式输出整数，因此需要控制整数的输出。若在计算过程中asc或者des或者n出现三位数以下的情况（比如0189），输出的高位要补0。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nvoid Print_num(int m);\nbool cmp_desc(int a,int b)\n{\n    return a > b;\n}\nint main()\n{\n    int n,num[4];//num[]数组存放四位数的各位数字，num[3]存放千位，num[0]存放个位\n    scanf(\"%d\",&n);\n    int flag = 1;//标记是否是第一次输入了6174，若是，则需要进入一次循环\n    while(n != 0&&(n != 6174||flag)){//注意外面两条件之间是&&而非||\n        flag = 0;//进入循环后，以后再出现n为0或6174的情况，均退出循环\n        for(int i = 0; i < 4; i++){\n            num[i] = n % 10;\n            n /= 10;\n        }//提取出n的各位数\n        sort(num,num + 4);//升序排序\n        int asc = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000;//重新合成四位数\n        sort(num,num + 4,cmp_desc);//降序排序\n        int des = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000;//重新合成四位数\n        n = asc - des;\n        Print_num(asc);\n        printf(\" - \");\n        Print_num(des);\n        printf(\" = \");\n        Print_num(n);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n//按四位数格式输出整数m\nvoid Print_num(int m)\n{\n    int j = 1000;\n    for(int i = 0; i < 4; i++){\n        printf(\"%d\",m / j);\n        m %= j;\n        j /=10;\n    }\n}\n```\n\n>题目来源：PAT乙级1019\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat乙级1019.md","raw":"---\ntitle: PAT乙级1019 || 数字黑洞（详解，C/C++示例，测试点分析）\ndate: 2019-08-18 13:05:08\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **数字黑洞**\n## **题目描述**\n给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 `6174`，这个神奇的数字也叫 Kaprekar 常数。\n例如，我们从`6767`开始，将得到\n\n```null\n7766 - 6677 = 1089\n9810 - 0189 = 9621\n9621 - 1269 = 8352\n8532 - 2358 = 6174\n7641 - 1467 = 6174\n... ...\n```\n现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。\n## **输入格式**\n输入给出一个$ (0,10^4 )$ 区间内的正整数 N。\n## **输出格式**\n如果 *N* 的 4 位数字全相等，则在一行内输出 `N - N = 0000`；否则将计算的每一步在一行内输出，直到 `6174` 作为差出现，输出格式见样例。注意每个数字按 `4` 位数格式输出。\n## **输入样例1**\n```null\n6767\n```\n## **输出样例1**\n```null\n7766 - 6677 = 1089\n9810 - 0189 = 9621\n9621 - 1269 = 8352\n8532 - 2358 = 6174\n```\n## **输入样例2**\n```null\n2222\n```\n## **输出样例2**\n```null\n2222 - 2222 = 0000\n```\n\n## 问题解决\n### 解题思想\n设置num[]数组存放四位数的各位数字，num[3]存放千位，num[0]存放个位；提取出n的各位数字之后，采用C++标准库函数sort()对四位数字分别进行升序和降序的排序（注意sort()函数默认是按升序排序，降序排序时需要自行设置cmp_desc()函数以实现降序排序），然后将排序后的各位数字再次分别合成升序四位数asc和降序四位数des；最后按照四位数格式输出运算过程中的各整数。特别需要注意以下几点：\n* 题目中已经说明n一定是正整数，因此输入的n不会是0(第一次不会因此退出循环而导致无输出)，但n可能为`6174`，若n的输入为`6174`时，需要进入循环输出一次再退出循环，此处我用flag标记控制。（注：PAT评测系统是有一个测试点输入为`6174`的，若不特殊处理将导致此测试点不通过比如若将代码中while循环的条件改为下面的情况将产生部分错误）\n\n```cpp\nwhile(n != 0&&n != 6174)\n```\n* 注意题目要求按四位格式输出整数，因此需要控制整数的输出。若在计算过程中asc或者des或者n出现三位数以下的情况（比如0189），输出的高位要补0。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nvoid Print_num(int m);\nbool cmp_desc(int a,int b)\n{\n    return a > b;\n}\nint main()\n{\n    int n,num[4];//num[]数组存放四位数的各位数字，num[3]存放千位，num[0]存放个位\n    scanf(\"%d\",&n);\n    int flag = 1;//标记是否是第一次输入了6174，若是，则需要进入一次循环\n    while(n != 0&&(n != 6174||flag)){//注意外面两条件之间是&&而非||\n        flag = 0;//进入循环后，以后再出现n为0或6174的情况，均退出循环\n        for(int i = 0; i < 4; i++){\n            num[i] = n % 10;\n            n /= 10;\n        }//提取出n的各位数\n        sort(num,num + 4);//升序排序\n        int asc = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000;//重新合成四位数\n        sort(num,num + 4,cmp_desc);//降序排序\n        int des = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000;//重新合成四位数\n        n = asc - des;\n        Print_num(asc);\n        printf(\" - \");\n        Print_num(des);\n        printf(\" = \");\n        Print_num(n);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n//按四位数格式输出整数m\nvoid Print_num(int m)\n{\n    int j = 1000;\n    for(int i = 0; i < 4; i++){\n        printf(\"%d\",m / j);\n        m %= j;\n        j /=10;\n    }\n}\n```\n\n>题目来源：PAT乙级1019\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat乙级1019","published":1,"updated":"2019-08-21T04:57:12.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfft002nfk0rkgzb2klp","content":"<h1 id=\"数字黑洞\"><a href=\"#数字黑洞\" class=\"headerlink\" title=\"数字黑洞\"></a><strong>数字黑洞</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 <code>6174</code>，这个神奇的数字也叫 Kaprekar 常数。<br>例如，我们从<code>6767</code>开始，将得到</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7766 - 6677 = 1089</span><br><span class=\"line\">9810 - 0189 = 9621</span><br><span class=\"line\">9621 - 1269 = 8352</span><br><span class=\"line\">8532 - 2358 = 6174</span><br><span class=\"line\">7641 - 1467 = 6174</span><br><span class=\"line\">... ...</span><br></pre></td></tr></table></figure></div>\n<p>现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入给出一个$ (0,10^4 )$ 区间内的正整数 N。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>如果 <em>N</em> 的 4 位数字全相等，则在一行内输出 <code>N - N = 0000</code>；否则将计算的每一步在一行内输出，直到 <code>6174</code> 作为差出现，输出格式见样例。注意每个数字按 <code>4</code> 位数格式输出。</p>\n<h2 id=\"输入样例1\"><a href=\"#输入样例1\" class=\"headerlink\" title=\"输入样例1\"></a><strong>输入样例1</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6767</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例1\"><a href=\"#输出样例1\" class=\"headerlink\" title=\"输出样例1\"></a><strong>输出样例1</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7766 - 6677 = 1089</span><br><span class=\"line\">9810 - 0189 = 9621</span><br><span class=\"line\">9621 - 1269 = 8352</span><br><span class=\"line\">8532 - 2358 = 6174</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输入样例2\"><a href=\"#输入样例2\" class=\"headerlink\" title=\"输入样例2\"></a><strong>输入样例2</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2222</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例2\"><a href=\"#输出样例2\" class=\"headerlink\" title=\"输出样例2\"></a><strong>输出样例2</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2222 - 2222 = 0000</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>设置num[]数组存放四位数的各位数字，num[3]存放千位，num[0]存放个位；提取出n的各位数字之后，采用C++标准库函数sort()对四位数字分别进行升序和降序的排序（注意sort()函数默认是按升序排序，降序排序时需要自行设置cmp_desc()函数以实现降序排序），然后将排序后的各位数字再次分别合成升序四位数asc和降序四位数des；最后按照四位数格式输出运算过程中的各整数。特别需要注意以下几点：</p>\n<ul>\n<li>题目中已经说明n一定是正整数，因此输入的n不会是0(第一次不会因此退出循环而导致无输出)，但n可能为<code>6174</code>，若n的输入为<code>6174</code>时，需要进入循环输出一次再退出循环，此处我用flag标记控制。（注：PAT评测系统是有一个测试点输入为<code>6174</code>的，若不特殊处理将导致此测试点不通过比如若将代码中while循环的条件改为下面的情况将产生部分错误）</li>\n</ul>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(n != <span class=\"number\">0</span>&amp;&amp;n != <span class=\"number\">6174</span>)</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>注意题目要求按四位格式输出整数，因此需要控制整数的输出。若在计算过程中asc或者des或者n出现三位数以下的情况（比如0189），输出的高位要补0。</li>\n</ul>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print_num</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp_desc</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,num[<span class=\"number\">4</span>];<span class=\"comment\">//num[]数组存放四位数的各位数字，num[3]存放千位，num[0]存放个位</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;<span class=\"comment\">//标记是否是第一次输入了6174，若是，则需要进入一次循环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n != <span class=\"number\">0</span>&amp;&amp;(n != <span class=\"number\">6174</span>||flag))&#123;<span class=\"comment\">//注意外面两条件之间是&amp;&amp;而非||</span></span><br><span class=\"line\">        flag = <span class=\"number\">0</span>;<span class=\"comment\">//进入循环后，以后再出现n为0或6174的情况，均退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            num[i] = n % <span class=\"number\">10</span>;</span><br><span class=\"line\">            n /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//提取出n的各位数</span></span><br><span class=\"line\">        sort(num,num + <span class=\"number\">4</span>);<span class=\"comment\">//升序排序</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> asc = num[<span class=\"number\">0</span>] + num[<span class=\"number\">1</span>] * <span class=\"number\">10</span> + num[<span class=\"number\">2</span>] * <span class=\"number\">100</span> + num[<span class=\"number\">3</span>] * <span class=\"number\">1000</span>;<span class=\"comment\">//重新合成四位数</span></span><br><span class=\"line\">        sort(num,num + <span class=\"number\">4</span>,cmp_desc);<span class=\"comment\">//降序排序</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> des = num[<span class=\"number\">0</span>] + num[<span class=\"number\">1</span>] * <span class=\"number\">10</span> + num[<span class=\"number\">2</span>] * <span class=\"number\">100</span> + num[<span class=\"number\">3</span>] * <span class=\"number\">1000</span>;<span class=\"comment\">//重新合成四位数</span></span><br><span class=\"line\">        n = asc - des;</span><br><span class=\"line\">        Print_num(asc);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" - \"</span>);</span><br><span class=\"line\">        Print_num(des);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" = \"</span>);</span><br><span class=\"line\">        Print_num(n);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//按四位数格式输出整数m</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print_num</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,m / j);</span><br><span class=\"line\">        m %= j;</span><br><span class=\"line\">        j /=<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1019<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数字黑洞\"><a href=\"#数字黑洞\" class=\"headerlink\" title=\"数字黑洞\"></a><strong>数字黑洞</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 <code>6174</code>，这个神奇的数字也叫 Kaprekar 常数。<br>例如，我们从<code>6767</code>开始，将得到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7766 - 6677 = 1089</span><br><span class=\"line\">9810 - 0189 = 9621</span><br><span class=\"line\">9621 - 1269 = 8352</span><br><span class=\"line\">8532 - 2358 = 6174</span><br><span class=\"line\">7641 - 1467 = 6174</span><br><span class=\"line\">... ...</span><br></pre></td></tr></table></figure>\n<p>现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入给出一个$ (0,10^4 )$ 区间内的正整数 N。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>如果 <em>N</em> 的 4 位数字全相等，则在一行内输出 <code>N - N = 0000</code>；否则将计算的每一步在一行内输出，直到 <code>6174</code> 作为差出现，输出格式见样例。注意每个数字按 <code>4</code> 位数格式输出。</p>\n<h2 id=\"输入样例1\"><a href=\"#输入样例1\" class=\"headerlink\" title=\"输入样例1\"></a><strong>输入样例1</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6767</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例1\"><a href=\"#输出样例1\" class=\"headerlink\" title=\"输出样例1\"></a><strong>输出样例1</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7766 - 6677 = 1089</span><br><span class=\"line\">9810 - 0189 = 9621</span><br><span class=\"line\">9621 - 1269 = 8352</span><br><span class=\"line\">8532 - 2358 = 6174</span><br></pre></td></tr></table></figure>\n<h2 id=\"输入样例2\"><a href=\"#输入样例2\" class=\"headerlink\" title=\"输入样例2\"></a><strong>输入样例2</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2222</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例2\"><a href=\"#输出样例2\" class=\"headerlink\" title=\"输出样例2\"></a><strong>输出样例2</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2222 - 2222 = 0000</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>设置num[]数组存放四位数的各位数字，num[3]存放千位，num[0]存放个位；提取出n的各位数字之后，采用C++标准库函数sort()对四位数字分别进行升序和降序的排序（注意sort()函数默认是按升序排序，降序排序时需要自行设置cmp_desc()函数以实现降序排序），然后将排序后的各位数字再次分别合成升序四位数asc和降序四位数des；最后按照四位数格式输出运算过程中的各整数。特别需要注意以下几点：</p>\n<ul>\n<li>题目中已经说明n一定是正整数，因此输入的n不会是0(第一次不会因此退出循环而导致无输出)，但n可能为<code>6174</code>，若n的输入为<code>6174</code>时，需要进入循环输出一次再退出循环，此处我用flag标记控制。（注：PAT评测系统是有一个测试点输入为<code>6174</code>的，若不特殊处理将导致此测试点不通过比如若将代码中while循环的条件改为下面的情况将产生部分错误）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(n != <span class=\"number\">0</span>&amp;&amp;n != <span class=\"number\">6174</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意题目要求按四位格式输出整数，因此需要控制整数的输出。若在计算过程中asc或者des或者n出现三位数以下的情况（比如0189），输出的高位要补0。</li>\n</ul>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print_num</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp_desc</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,num[<span class=\"number\">4</span>];<span class=\"comment\">//num[]数组存放四位数的各位数字，num[3]存放千位，num[0]存放个位</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;<span class=\"comment\">//标记是否是第一次输入了6174，若是，则需要进入一次循环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n != <span class=\"number\">0</span>&amp;&amp;(n != <span class=\"number\">6174</span>||flag))&#123;<span class=\"comment\">//注意外面两条件之间是&amp;&amp;而非||</span></span><br><span class=\"line\">        flag = <span class=\"number\">0</span>;<span class=\"comment\">//进入循环后，以后再出现n为0或6174的情况，均退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            num[i] = n % <span class=\"number\">10</span>;</span><br><span class=\"line\">            n /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//提取出n的各位数</span></span><br><span class=\"line\">        sort(num,num + <span class=\"number\">4</span>);<span class=\"comment\">//升序排序</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> asc = num[<span class=\"number\">0</span>] + num[<span class=\"number\">1</span>] * <span class=\"number\">10</span> + num[<span class=\"number\">2</span>] * <span class=\"number\">100</span> + num[<span class=\"number\">3</span>] * <span class=\"number\">1000</span>;<span class=\"comment\">//重新合成四位数</span></span><br><span class=\"line\">        sort(num,num + <span class=\"number\">4</span>,cmp_desc);<span class=\"comment\">//降序排序</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> des = num[<span class=\"number\">0</span>] + num[<span class=\"number\">1</span>] * <span class=\"number\">10</span> + num[<span class=\"number\">2</span>] * <span class=\"number\">100</span> + num[<span class=\"number\">3</span>] * <span class=\"number\">1000</span>;<span class=\"comment\">//重新合成四位数</span></span><br><span class=\"line\">        n = asc - des;</span><br><span class=\"line\">        Print_num(asc);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" - \"</span>);</span><br><span class=\"line\">        Print_num(des);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" = \"</span>);</span><br><span class=\"line\">        Print_num(n);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//按四位数格式输出整数m</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print_num</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,m / j);</span><br><span class=\"line\">        m %= j;</span><br><span class=\"line\">        j /=<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1019<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1021 || 个位数统计（详解，C/C++示例，测试点分析）","date":"2019-08-21T04:38:03.000Z","mathjax":true,"_content":"\n# **个位数统计**\n## **题目描述**\n给定一个$k$位整数 $N=d_{k−1}10^{k−1}+⋯+d_110^1+d_0$$ (0≤d_i ≤9, i=0,⋯,k−1, d_{k−1} >0)$，请编写程序统计每种不同的个位数字出现的次数。例如：给定 $N=100311$，则有 2 个 0，3 个 1，和 1 个 3。\n## **输入格式**\n每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 $N$。\n## **输出格式**\n对 $N$ 中每一种不同的个位数字，以 `D:M` 的格式在一行中输出该位数字 `D` 及其在` N` 中出现的次数 `M`。要求按 `D` 的升序输出。\n## **输入样例**\n```null\n100311\n```\n## **输出样例**\n```null\n0:2\n1:3\n3:1\n```\n\n## 问题解决\n### 解题思想\n$N$为不超过 1000 位的正整数，显然不能用单个变量来存 $N$ 的值，可用字符数组存入 $N$ 的每一位；输入时遇到换行即输入结束；设置一个整型数组coun[10]来统计各位数字出现的次数；个数为0个的数字不输出。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#define MAXN 1001\nusing namespace std;\nint main()\n{\n    char num[MAXN];//用字符数组存入输入的大数\n    int i = 0;\n    num[i] = getchar();\n    while(num[i] != '\\n'){//遇到换行即输入结束\n        i++;\n        num[i] = getchar();\n    }\n    i = 0;\n    int coun[10] = {0};//统计数组\n    while(num[i] != '\\n'){\n        int n = num[i] - '0';//字符转化为数字\n        coun[n]++;\n        i++;\n    }\n    for(i = 0; i < 10; i++){\n        if(coun[i] != 0){//个数为0个的数字不输出\n            printf(\"%d:%d\\n\",i,coun[i]);\n        }\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1021\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat乙级1021.md","raw":"---\ntitle: PAT乙级1021 || 个位数统计（详解，C/C++示例，测试点分析）\ndate: 2019-08-21 12:38:03\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **个位数统计**\n## **题目描述**\n给定一个$k$位整数 $N=d_{k−1}10^{k−1}+⋯+d_110^1+d_0$$ (0≤d_i ≤9, i=0,⋯,k−1, d_{k−1} >0)$，请编写程序统计每种不同的个位数字出现的次数。例如：给定 $N=100311$，则有 2 个 0，3 个 1，和 1 个 3。\n## **输入格式**\n每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 $N$。\n## **输出格式**\n对 $N$ 中每一种不同的个位数字，以 `D:M` 的格式在一行中输出该位数字 `D` 及其在` N` 中出现的次数 `M`。要求按 `D` 的升序输出。\n## **输入样例**\n```null\n100311\n```\n## **输出样例**\n```null\n0:2\n1:3\n3:1\n```\n\n## 问题解决\n### 解题思想\n$N$为不超过 1000 位的正整数，显然不能用单个变量来存 $N$ 的值，可用字符数组存入 $N$ 的每一位；输入时遇到换行即输入结束；设置一个整型数组coun[10]来统计各位数字出现的次数；个数为0个的数字不输出。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#define MAXN 1001\nusing namespace std;\nint main()\n{\n    char num[MAXN];//用字符数组存入输入的大数\n    int i = 0;\n    num[i] = getchar();\n    while(num[i] != '\\n'){//遇到换行即输入结束\n        i++;\n        num[i] = getchar();\n    }\n    i = 0;\n    int coun[10] = {0};//统计数组\n    while(num[i] != '\\n'){\n        int n = num[i] - '0';//字符转化为数字\n        coun[n]++;\n        i++;\n    }\n    for(i = 0; i < 10; i++){\n        if(coun[i] != 0){//个数为0个的数字不输出\n            printf(\"%d:%d\\n\",i,coun[i]);\n        }\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1021\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat乙级1021","published":1,"updated":"2019-08-21T04:58:08.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwffv002pfk0r2a5t2nxw","content":"<h1 id=\"个位数统计\"><a href=\"#个位数统计\" class=\"headerlink\" title=\"个位数统计\"></a><strong>个位数统计</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一个$k$位整数 $N=d_{k−1}10^{k−1}+⋯+d_110^1+d_0$$ (0≤d_i ≤9, i=0,⋯,k−1, d_{k−1} &gt;0)$，请编写程序统计每种不同的个位数字出现的次数。例如：给定 $N=100311$，则有 2 个 0，3 个 1，和 1 个 3。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 $N$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对 $N$ 中每一种不同的个位数字，以 <code>D:M</code> 的格式在一行中输出该位数字 <code>D</code> 及其在<code>N</code> 中出现的次数 <code>M</code>。要求按 <code>D</code> 的升序输出。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100311</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0:2</span><br><span class=\"line\">1:3</span><br><span class=\"line\">3:1</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>$N$为不超过 1000 位的正整数，显然不能用单个变量来存 $N$ 的值，可用字符数组存入 $N$ 的每一位；输入时遇到换行即输入结束；设置一个整型数组coun[10]来统计各位数字出现的次数；个数为0个的数字不输出。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> num[MAXN];<span class=\"comment\">//用字符数组存入输入的大数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    num[i] = getchar();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(num[i] != <span class=\"string\">'\\n'</span>)&#123;<span class=\"comment\">//遇到换行即输入结束</span></span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        num[i] = getchar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> coun[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>&#125;;<span class=\"comment\">//统计数组</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(num[i] != <span class=\"string\">'\\n'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = num[i] - <span class=\"string\">'0'</span>;<span class=\"comment\">//字符转化为数字</span></span><br><span class=\"line\">        coun[n]++;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(coun[i] != <span class=\"number\">0</span>)&#123;<span class=\"comment\">//个数为0个的数字不输出</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d:%d\\n\"</span>,i,coun[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1021<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"个位数统计\"><a href=\"#个位数统计\" class=\"headerlink\" title=\"个位数统计\"></a><strong>个位数统计</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一个$k$位整数 $N=d_{k−1}10^{k−1}+⋯+d_110^1+d_0$$ (0≤d_i ≤9, i=0,⋯,k−1, d_{k−1} &gt;0)$，请编写程序统计每种不同的个位数字出现的次数。例如：给定 $N=100311$，则有 2 个 0，3 个 1，和 1 个 3。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 $N$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对 $N$ 中每一种不同的个位数字，以 <code>D:M</code> 的格式在一行中输出该位数字 <code>D</code> 及其在<code>N</code> 中出现的次数 <code>M</code>。要求按 <code>D</code> 的升序输出。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100311</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0:2</span><br><span class=\"line\">1:3</span><br><span class=\"line\">3:1</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>$N$为不超过 1000 位的正整数，显然不能用单个变量来存 $N$ 的值，可用字符数组存入 $N$ 的每一位；输入时遇到换行即输入结束；设置一个整型数组coun[10]来统计各位数字出现的次数；个数为0个的数字不输出。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> num[MAXN];<span class=\"comment\">//用字符数组存入输入的大数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    num[i] = getchar();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(num[i] != <span class=\"string\">'\\n'</span>)&#123;<span class=\"comment\">//遇到换行即输入结束</span></span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        num[i] = getchar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> coun[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>&#125;;<span class=\"comment\">//统计数组</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(num[i] != <span class=\"string\">'\\n'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = num[i] - <span class=\"string\">'0'</span>;<span class=\"comment\">//字符转化为数字</span></span><br><span class=\"line\">        coun[n]++;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(coun[i] != <span class=\"number\">0</span>)&#123;<span class=\"comment\">//个数为0个的数字不输出</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d:%d\\n\"</span>,i,coun[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1021<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1020 || 月饼（详解，C/C++示例，测试点分析）","date":"2019-08-18T05:05:17.000Z","_content":"\n# **月饼**\n## **题目描述**\n月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。\n注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。\n## **输入格式**\n每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。\n## **输出格式**\n对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。\n## **输入样例**\n```null\n3 20\n18 15 10\n75 72 45\n```\n## **输出样例**\n```null\n94.50\n```\n\n## 问题解决\n### 解题思想\n为了利用每种月饼的单价对月饼进行排序，我把每种月饼的清单定义为结构体类型，利用sort()函数可非常方便地对每种月饼按单价排序；因为要按照降序进行排序，因此需定义排序规则函数cmp()；最大收益策略应是：逐次选择**单价**由高到低的月饼直到需求量得到满足为止。本题还应注意以下两个方面：\n\n* 题中说明了库存量，总售价都是正数，故应定义为实型\n\n* 若最大需求量大于所有月饼的总库存量，最大收益策略应该是卖出所有的月饼。\n\n第二个方面容易忽略，若将代码中最后计算收益的while循环的条件改为如下：\n\n```cpp\nwhile((d - ca_list[i].inv_coun) > 0))\n```\n提交时将会有一个测试点不通过（段错误），因为当需求量大于所有月饼的总库存量，i将累加到大于n甚至大于MAXN，从而导致错误或数组下标越界。加上`i < n`这个条件后在退出循环时还需要用if语句检查一下是否是由于`i >= n`而退出的循环（若是则需求量大于所有月饼的总库存量），若是，yield就不能再加上剩余的需求量乘上当前种类月饼的单价了。\n### 知识拓展\n在OJ上训练时，建议大家遇到实型数据就定义成double型，尽量不要定义为float型。在提交程序后评测出错，然后将float改为double后才得以AC时应该会有这样的“领悟”。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#include <algorithm>//使用sort()函数须加上此句\n#define MAXN 1001\nusing namespace std;\n//定义存货清单结构体类型\nstruct cargo_list\n{\n    //库存量，总售价应定义为实型\n    double inv_coun;//库存量\n    double total_pri;//总售价\n    double unit_pri;//单价(单位：亿元/万吨)\n}ca_list[MAXN];\n//定义sort()函数的比较规则函数cmp()\nbool cmp(cargo_list a,cargo_list b)\n{\n    return a.unit_pri > b.unit_pri;\n}\nint main()\n{\n    int n,d;\n    scanf(\"%d%d\",&n,&d);\n    for(int i = 0; i < n; i++){\n        scanf(\"%lf\",&ca_list[i].inv_coun);//输入库存量\n    }\n    for(int i = 0; i < n; i++){\n        scanf(\"%lf\",&ca_list[i].total_pri);//输入总售价\n        ca_list[i].unit_pri = ca_list[i].total_pri / ca_list[i].inv_coun;//计算单价\n    }\n    sort(ca_list,ca_list + n,cmp);//按单价进行降序排序\n    int i = 0;\n    double yield = 0;//收益\n    while(((d - ca_list[i].inv_coun) > 0)&&(i < n)){\n        yield += ca_list[i].total_pri;//累加收益\n        d -= ca_list[i].inv_coun;//更新需求量\n        i++;\n    }//若更新后的需求量大于当前种类月饼的库存量则继续循环否则退出\n    if(i < n){\n        yield += d * ca_list[i].unit_pri;\n    }//若因(d - ca_list[i].inv_coun) <= 0退出循环，\n     //收益还需加上剩余的需求量乘上当前种类月饼的单价\n    printf(\"%.2lf\",yield);\n    return 0;\n}\n```\n>题目来源：PAT乙级1020\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat乙级1020.md","raw":"---\ntitle: PAT乙级1020 || 月饼（详解，C/C++示例，测试点分析）\ndate: 2019-08-18 13:05:17\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **月饼**\n## **题目描述**\n月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。\n注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。\n## **输入格式**\n每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。\n## **输出格式**\n对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。\n## **输入样例**\n```null\n3 20\n18 15 10\n75 72 45\n```\n## **输出样例**\n```null\n94.50\n```\n\n## 问题解决\n### 解题思想\n为了利用每种月饼的单价对月饼进行排序，我把每种月饼的清单定义为结构体类型，利用sort()函数可非常方便地对每种月饼按单价排序；因为要按照降序进行排序，因此需定义排序规则函数cmp()；最大收益策略应是：逐次选择**单价**由高到低的月饼直到需求量得到满足为止。本题还应注意以下两个方面：\n\n* 题中说明了库存量，总售价都是正数，故应定义为实型\n\n* 若最大需求量大于所有月饼的总库存量，最大收益策略应该是卖出所有的月饼。\n\n第二个方面容易忽略，若将代码中最后计算收益的while循环的条件改为如下：\n\n```cpp\nwhile((d - ca_list[i].inv_coun) > 0))\n```\n提交时将会有一个测试点不通过（段错误），因为当需求量大于所有月饼的总库存量，i将累加到大于n甚至大于MAXN，从而导致错误或数组下标越界。加上`i < n`这个条件后在退出循环时还需要用if语句检查一下是否是由于`i >= n`而退出的循环（若是则需求量大于所有月饼的总库存量），若是，yield就不能再加上剩余的需求量乘上当前种类月饼的单价了。\n### 知识拓展\n在OJ上训练时，建议大家遇到实型数据就定义成double型，尽量不要定义为float型。在提交程序后评测出错，然后将float改为double后才得以AC时应该会有这样的“领悟”。\n\n### 代码示例（C/C++）\n\n```cpp\n#include <cstdio>\n#include <algorithm>//使用sort()函数须加上此句\n#define MAXN 1001\nusing namespace std;\n//定义存货清单结构体类型\nstruct cargo_list\n{\n    //库存量，总售价应定义为实型\n    double inv_coun;//库存量\n    double total_pri;//总售价\n    double unit_pri;//单价(单位：亿元/万吨)\n}ca_list[MAXN];\n//定义sort()函数的比较规则函数cmp()\nbool cmp(cargo_list a,cargo_list b)\n{\n    return a.unit_pri > b.unit_pri;\n}\nint main()\n{\n    int n,d;\n    scanf(\"%d%d\",&n,&d);\n    for(int i = 0; i < n; i++){\n        scanf(\"%lf\",&ca_list[i].inv_coun);//输入库存量\n    }\n    for(int i = 0; i < n; i++){\n        scanf(\"%lf\",&ca_list[i].total_pri);//输入总售价\n        ca_list[i].unit_pri = ca_list[i].total_pri / ca_list[i].inv_coun;//计算单价\n    }\n    sort(ca_list,ca_list + n,cmp);//按单价进行降序排序\n    int i = 0;\n    double yield = 0;//收益\n    while(((d - ca_list[i].inv_coun) > 0)&&(i < n)){\n        yield += ca_list[i].total_pri;//累加收益\n        d -= ca_list[i].inv_coun;//更新需求量\n        i++;\n    }//若更新后的需求量大于当前种类月饼的库存量则继续循环否则退出\n    if(i < n){\n        yield += d * ca_list[i].unit_pri;\n    }//若因(d - ca_list[i].inv_coun) <= 0退出循环，\n     //收益还需加上剩余的需求量乘上当前种类月饼的单价\n    printf(\"%.2lf\",yield);\n    return 0;\n}\n```\n>题目来源：PAT乙级1020\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat乙级1020","published":1,"updated":"2019-08-21T04:57:23.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwffy002sfk0rflpf1368","content":"<h1 id=\"月饼\"><a href=\"#月饼\" class=\"headerlink\" title=\"月饼\"></a><strong>月饼</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。<br>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 20</span><br><span class=\"line\">18 15 10</span><br><span class=\"line\">75 72 45</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">94.50</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>为了利用每种月饼的单价对月饼进行排序，我把每种月饼的清单定义为结构体类型，利用sort()函数可非常方便地对每种月饼按单价排序；因为要按照降序进行排序，因此需定义排序规则函数cmp()；最大收益策略应是：逐次选择<strong>单价</strong>由高到低的月饼直到需求量得到满足为止。本题还应注意以下两个方面：</p>\n<ul>\n<li><p>题中说明了库存量，总售价都是正数，故应定义为实型</p>\n</li>\n<li><p>若最大需求量大于所有月饼的总库存量，最大收益策略应该是卖出所有的月饼。</p>\n</li>\n</ul>\n<p>第二个方面容易忽略，若将代码中最后计算收益的while循环的条件改为如下：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>((d - ca_list[i].inv_coun) &gt; <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure></div>\n<p>提交时将会有一个测试点不通过（段错误），因为当需求量大于所有月饼的总库存量，i将累加到大于n甚至大于MAXN，从而导致错误或数组下标越界。加上<code>i &lt; n</code>这个条件后在退出循环时还需要用if语句检查一下是否是由于<code>i &gt;= n</code>而退出的循环（若是则需求量大于所有月饼的总库存量），若是，yield就不能再加上剩余的需求量乘上当前种类月饼的单价了。</p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>在OJ上训练时，建议大家遇到实型数据就定义成double型，尽量不要定义为float型。在提交程序后评测出错，然后将float改为double后才得以AC时应该会有这样的“领悟”。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;//使用sort()函数须加上此句</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"comment\">//定义存货清单结构体类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cargo_list</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//库存量，总售价应定义为实型</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> inv_coun;<span class=\"comment\">//库存量</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> total_pri;<span class=\"comment\">//总售价</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> unit_pri;<span class=\"comment\">//单价(单位：亿元/万吨)</span></span><br><span class=\"line\">&#125;ca_list[MAXN];</span><br><span class=\"line\"><span class=\"comment\">//定义sort()函数的比较规则函数cmp()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(cargo_list a,cargo_list b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.unit_pri &gt; b.unit_pri;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,d;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;d);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf\"</span>,&amp;ca_list[i].inv_coun);<span class=\"comment\">//输入库存量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf\"</span>,&amp;ca_list[i].total_pri);<span class=\"comment\">//输入总售价</span></span><br><span class=\"line\">        ca_list[i].unit_pri = ca_list[i].total_pri / ca_list[i].inv_coun;<span class=\"comment\">//计算单价</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(ca_list,ca_list + n,cmp);<span class=\"comment\">//按单价进行降序排序</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> yield = <span class=\"number\">0</span>;<span class=\"comment\">//收益</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(((d - ca_list[i].inv_coun) &gt; <span class=\"number\">0</span>)&amp;&amp;(i &lt; n))&#123;</span><br><span class=\"line\">        yield += ca_list[i].total_pri;<span class=\"comment\">//累加收益</span></span><br><span class=\"line\">        d -= ca_list[i].inv_coun;<span class=\"comment\">//更新需求量</span></span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//若更新后的需求量大于当前种类月饼的库存量则继续循环否则退出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; n)&#123;</span><br><span class=\"line\">        yield += d * ca_list[i].unit_pri;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//若因(d - ca_list[i].inv_coun) &lt;= 0退出循环，</span></span><br><span class=\"line\">     <span class=\"comment\">//收益还需加上剩余的需求量乘上当前种类月饼的单价</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.2lf\"</span>,yield);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1020<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"月饼\"><a href=\"#月饼\" class=\"headerlink\" title=\"月饼\"></a><strong>月饼</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。<br>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 20</span><br><span class=\"line\">18 15 10</span><br><span class=\"line\">75 72 45</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">94.50</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>为了利用每种月饼的单价对月饼进行排序，我把每种月饼的清单定义为结构体类型，利用sort()函数可非常方便地对每种月饼按单价排序；因为要按照降序进行排序，因此需定义排序规则函数cmp()；最大收益策略应是：逐次选择<strong>单价</strong>由高到低的月饼直到需求量得到满足为止。本题还应注意以下两个方面：</p>\n<ul>\n<li><p>题中说明了库存量，总售价都是正数，故应定义为实型</p>\n</li>\n<li><p>若最大需求量大于所有月饼的总库存量，最大收益策略应该是卖出所有的月饼。</p>\n</li>\n</ul>\n<p>第二个方面容易忽略，若将代码中最后计算收益的while循环的条件改为如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>((d - ca_list[i].inv_coun) &gt; <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure>\n<p>提交时将会有一个测试点不通过（段错误），因为当需求量大于所有月饼的总库存量，i将累加到大于n甚至大于MAXN，从而导致错误或数组下标越界。加上<code>i &lt; n</code>这个条件后在退出循环时还需要用if语句检查一下是否是由于<code>i &gt;= n</code>而退出的循环（若是则需求量大于所有月饼的总库存量），若是，yield就不能再加上剩余的需求量乘上当前种类月饼的单价了。</p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>在OJ上训练时，建议大家遇到实型数据就定义成double型，尽量不要定义为float型。在提交程序后评测出错，然后将float改为double后才得以AC时应该会有这样的“领悟”。</p>\n<h3 id=\"代码示例（C-C-）\"><a href=\"#代码示例（C-C-）\" class=\"headerlink\" title=\"代码示例（C/C++）\"></a>代码示例（C/C++）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;//使用sort()函数须加上此句</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1001</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"comment\">//定义存货清单结构体类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cargo_list</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//库存量，总售价应定义为实型</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> inv_coun;<span class=\"comment\">//库存量</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> total_pri;<span class=\"comment\">//总售价</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> unit_pri;<span class=\"comment\">//单价(单位：亿元/万吨)</span></span><br><span class=\"line\">&#125;ca_list[MAXN];</span><br><span class=\"line\"><span class=\"comment\">//定义sort()函数的比较规则函数cmp()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(cargo_list a,cargo_list b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.unit_pri &gt; b.unit_pri;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,d;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;d);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf\"</span>,&amp;ca_list[i].inv_coun);<span class=\"comment\">//输入库存量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf\"</span>,&amp;ca_list[i].total_pri);<span class=\"comment\">//输入总售价</span></span><br><span class=\"line\">        ca_list[i].unit_pri = ca_list[i].total_pri / ca_list[i].inv_coun;<span class=\"comment\">//计算单价</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(ca_list,ca_list + n,cmp);<span class=\"comment\">//按单价进行降序排序</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> yield = <span class=\"number\">0</span>;<span class=\"comment\">//收益</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(((d - ca_list[i].inv_coun) &gt; <span class=\"number\">0</span>)&amp;&amp;(i &lt; n))&#123;</span><br><span class=\"line\">        yield += ca_list[i].total_pri;<span class=\"comment\">//累加收益</span></span><br><span class=\"line\">        d -= ca_list[i].inv_coun;<span class=\"comment\">//更新需求量</span></span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//若更新后的需求量大于当前种类月饼的库存量则继续循环否则退出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; n)&#123;</span><br><span class=\"line\">        yield += d * ca_list[i].unit_pri;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//若因(d - ca_list[i].inv_coun) &lt;= 0退出循环，</span></span><br><span class=\"line\">     <span class=\"comment\">//收益还需加上剩余的需求量乘上当前种类月饼的单价</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.2lf\"</span>,yield);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1020<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"基于分层聚类图的大规模近似最近邻搜索（HCNNG）学习笔记","date":"2019-08-17T00:56:30.000Z","mathjax":true,"_content":"\n## 引言\n\n最近看了一篇论文，名为：Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search，总的来说这篇论文的创新点是值得学习的，但是论文对很多细节内容没有描述清楚，这也是我读这篇论文有些失望的地方（自己比较菜，所以细节问题不能详细描述的话，我很难理解的）。\n\n这篇论文主要有两个创新点，分别为构图算法和搜索算法，构图算法采用了一种叫做多重分层聚类方法，具体这种方法有什么优势，作者没有分析；搜索算法采用了一种叫做导向搜索的方法，我们知道，几乎所有的基于图的搜索算法的搜索过程都是采用贪婪搜索，贪婪搜索的每一步要对途径点的所有邻居计算它们到查询点的距离，如果对每一个途径点能少计算一些距离，又能保证搜索结果相同，这必然会提升搜索性能，导向搜索便是如此。\n\n## 构图算法\n\n论文中的图构建过程主要分两步，分别为多重分层聚类过程和各集簇图的融合。\n\n### Hierarchical clustering procedure\n\n**多重分层聚类过程伪代码**\n\n```pseudocode\nFunction HierarchicalClustering(P, n)\n\tData: data points P, min size of clusters n\n\tResult: graph edges E\n\tN ← | P | \n\tE ← φ\n\tif N < n then\n\t\tE ← MST3(P)\n\telse\n\t\tselect randomly p1 and p2 points from P\n\t\tP1 ← { p ∈ P | D (p, p1 ) < D (p, p2 ) }\n\t\tP2 ← { p ∈ P | D (p, p1 ) ≥ D (p, p2 ) }\n\t\tE1 ← Hierarchical Cl ustering(P1 , n )\n\t\tE2 ← Hierarchical Cl ustering(P2 , n )\n\t\tE ← E1 ∪ E2\n\treturn E\n```\n简述：输入数据集点集 $P$ 和集簇的最大尺寸 $n$ ，输出经过分层聚类添加的边 $ E$ （初始化 $E$ 为空）；如果输入数据集的大小 $N < n$ ，则直接在 $P$ 上通过最小生成树的变体连边（最大度为3，即 $MST3$ ）；否则，从 $P$ 中随机选两个点 $p_1$ 和 $p_2$ ，根据到其它点到这两点距离将数据集 $P$ 划分为两簇，对这两簇分别递归地执行分层聚类过程直到每个簇的尺寸都小于 $n$ 。\n\n### Fusion of graphs\n\n**各集簇图的融合的伪代码**\n\n```pseudocode\nFunction CreateHCNNG(P, m, n)\n\tData : data points P , number of random clusterings m , min size of clusters n\n\tResult : graph edges E\n\tE ← φ\n\tfor i ← 1 to m do\n\t\tE i ← HierarchicalClustering(P, n )\n\t\tE ← E ∪ E i\n\treturn E\n```\n\n简述：输入数据集点集 $P$ 、随机聚类数 $m$ 和集簇的最大尺寸 $n$ ，输出经过多次分层聚类添加的边 $ E$ （初始化 $E$ 为空）；对整个数据集重复分层聚类 $m$ 次，$m$ 次分层聚类得到的边都并到一起。\n\n总结分析：在数据集上只分层聚类一次，得到的图肯定是高度不连通的，因此，要执行多重的随机分层聚类过程并连接他们的结果图。\n\n注：本文采用分层聚类过程而没有采用K-means聚类原因是：如果事先不知道数据的分布情况，很难估计簇的初始数量和迭代次数。\n\n## 搜索算法\n\n### 导向搜索 VS 贪婪搜索\n\n<img src=\"directed selection1.png\">\n\n如上图所示，在搜索过程中遍历到的点 $ p$ ，贪婪搜索要计算它的所有邻居到查询点 $q$ 的距离，而导向搜索只需要计算与点 $q$ 处于同一象限的邻居。\n\n<img src=\"guided search2.png\">\n\n上图中传统的贪婪搜索从入口点到查询终止需要计算10次与查询点的距离，而导向搜索只需要计算5次。\n\n### 导向搜索\n\n要实现导向搜索，需要对数据集中的每个点和它的邻居创建树状结构，创建索引的时候为每个结点划分子空间，导向搜索时还要有获取与查询点处于同一象限的邻居的过程。\n\n#### Creation of a tree structure to search in subspaces\n\n**主要思想：**\n\n对于已经建立的图上的某点 $p$ ，它的邻居将以树状的结构存储。在这个树状结构中，除了根结点 $p$ 和叶子结点（所有的叶子结点包含了 $p$ 的所有邻居），其它内部结点只是存储了用来划分空间的维度值（用的哪一维来划分的空间）；对于某个内部结点，它存储了某个维度值，它的两个子树是根据该维度值划分的，怎么划分呢？拿处于这个子空间的所有邻居在该维的值与点 $p$ 在该维的值比较，值小于 $p$ 的邻居被划分到 $neg$ 子树，值不小于 $p$ 的邻居被划分到 $pos$ 子树，然后再分别对这两个子树重复上述过程的划分直到对某个子树（子空间）按某维划分时得到的两个子树其中一个为空为止，此时就不用再建立存储该维的内部结点了，直接将该子树作为叶子就行了。\n\n根据维度划分，但是这个维度怎么选呢？维度选不好的话可能建立的这个子树只是一个线性表了，这样的话建立这个树状结构就没意义了，为此要好好地选，建立的树要尽可能的保证平衡，这就要求每次选维度时要看看它是否能尽可能地等分子空间的邻居。\n\n**划分子空间伪代码**\n\n```pseudocode\nFunction DivideSubspace( p, Np )\n\tData : point of graph p, neighbors points Np\n\tResult : space partition tree T\n\tdim ← select dimension based on Np\n\tneg ← { v ∈ N p | v [ dim ] < p[ dim ] }\n\tpos ← { v ∈ N p | v [ dim ] ≥ p[ dim ] }\n\tif | neg| = 0 or | pos | = 0 then\n\t\tT .points ← Np\n\telse\n\tT .dim ← dim\n\tT .neg ← DivideSubspace (p, neg)\n\tT .pos ← DivideSubspace (p, pos )\nreturn T\n```\n\n随记：为了实现导向搜索，在已经建好的图上对每个结点和它的邻居都建立一个树状结构（相当于附加了一个结构），这将提升搜索性能，但是会增加索引构建时间和内存占用。\n\n#### Identification of neighbors at the same subspace of the query\n\n**主要思想：**\n\n在搜索的过程中，对于遍历到的某点 $p$ ，要获取其与查询点 $q$ 处于同一象限（二维情况，高维类似）的邻居，需要从根节点（点 $p$）开始一直遍历到叶子结点，遍历过程中遇到内部结点时（要确定下一步走哪个子树）将点 $q$ 在该维的值与内部结点的值进行比较以确定下一步走哪个子树，走到叶子结点时，把其中 $p$ 的所有邻居返回（这就是找到的与 $q$ 处于同一象限的邻居）。另外，这个过程消耗的时间微不足道。\n\n**获取特定邻居伪代码**\n\n```pseudocode\nFunction GetNeighbors( q , p, node )\n\tData : query point q , point of graph p, node of space partition tree node\n\tResult : neighbors in query's subspace Nq\n\tNq ← φ\n\tif node is a tree leaf then\n\t\tNq ← node.points\n\telse\n\t\tif q [ node.dim ] < p[ node.dim ] then\n\t\t\tNq ← GetNeighbors (q, p, node.neg)\n\t\telse\n\t\tNq ← GetNeighbors (q, p, node.pos )\n\treturn Nq\n```\n\n## 构建搜索的大致过程\n\n1. 进行一定次数的分层聚类过程来建近邻图（在每个簇中用 $MST3$ 的方法连边，与[Wang2012](https://ieeexplore.ieee.org/document/6247790)类似）\n2. 为建立的近邻图中每个结点和其邻居建立树结构\n3. 创建一定数量的 $KD-Tree$ （内部结点为维数），从这些树中返回的结点中寻找离查询点最近的结点作为入口点\n4. 从入口点执行导向搜索（返回的邻居中找不到离查询更近的，还可转向相邻的叶子结点）\n\n## 参考文献\n\n> [1]Javier Vargas Muñoz,Marcos A. Gonçalves,Zanoni Dias,Ricardo da S. Torres. Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search[J]. Pattern Recognition,2019,96.","source":"_posts/HCNNG.md","raw":"---\ntitle: 基于分层聚类图的大规模近似最近邻搜索（HCNNG）学习笔记\ndate: 2019-08-17 08:56:30\ntags:\n- 论文阅读\n- ANNS\ncategories:\n- 近似最近邻搜索\nmathjax: true\n---\n\n## 引言\n\n最近看了一篇论文，名为：Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search，总的来说这篇论文的创新点是值得学习的，但是论文对很多细节内容没有描述清楚，这也是我读这篇论文有些失望的地方（自己比较菜，所以细节问题不能详细描述的话，我很难理解的）。\n\n这篇论文主要有两个创新点，分别为构图算法和搜索算法，构图算法采用了一种叫做多重分层聚类方法，具体这种方法有什么优势，作者没有分析；搜索算法采用了一种叫做导向搜索的方法，我们知道，几乎所有的基于图的搜索算法的搜索过程都是采用贪婪搜索，贪婪搜索的每一步要对途径点的所有邻居计算它们到查询点的距离，如果对每一个途径点能少计算一些距离，又能保证搜索结果相同，这必然会提升搜索性能，导向搜索便是如此。\n\n## 构图算法\n\n论文中的图构建过程主要分两步，分别为多重分层聚类过程和各集簇图的融合。\n\n### Hierarchical clustering procedure\n\n**多重分层聚类过程伪代码**\n\n```pseudocode\nFunction HierarchicalClustering(P, n)\n\tData: data points P, min size of clusters n\n\tResult: graph edges E\n\tN ← | P | \n\tE ← φ\n\tif N < n then\n\t\tE ← MST3(P)\n\telse\n\t\tselect randomly p1 and p2 points from P\n\t\tP1 ← { p ∈ P | D (p, p1 ) < D (p, p2 ) }\n\t\tP2 ← { p ∈ P | D (p, p1 ) ≥ D (p, p2 ) }\n\t\tE1 ← Hierarchical Cl ustering(P1 , n )\n\t\tE2 ← Hierarchical Cl ustering(P2 , n )\n\t\tE ← E1 ∪ E2\n\treturn E\n```\n简述：输入数据集点集 $P$ 和集簇的最大尺寸 $n$ ，输出经过分层聚类添加的边 $ E$ （初始化 $E$ 为空）；如果输入数据集的大小 $N < n$ ，则直接在 $P$ 上通过最小生成树的变体连边（最大度为3，即 $MST3$ ）；否则，从 $P$ 中随机选两个点 $p_1$ 和 $p_2$ ，根据到其它点到这两点距离将数据集 $P$ 划分为两簇，对这两簇分别递归地执行分层聚类过程直到每个簇的尺寸都小于 $n$ 。\n\n### Fusion of graphs\n\n**各集簇图的融合的伪代码**\n\n```pseudocode\nFunction CreateHCNNG(P, m, n)\n\tData : data points P , number of random clusterings m , min size of clusters n\n\tResult : graph edges E\n\tE ← φ\n\tfor i ← 1 to m do\n\t\tE i ← HierarchicalClustering(P, n )\n\t\tE ← E ∪ E i\n\treturn E\n```\n\n简述：输入数据集点集 $P$ 、随机聚类数 $m$ 和集簇的最大尺寸 $n$ ，输出经过多次分层聚类添加的边 $ E$ （初始化 $E$ 为空）；对整个数据集重复分层聚类 $m$ 次，$m$ 次分层聚类得到的边都并到一起。\n\n总结分析：在数据集上只分层聚类一次，得到的图肯定是高度不连通的，因此，要执行多重的随机分层聚类过程并连接他们的结果图。\n\n注：本文采用分层聚类过程而没有采用K-means聚类原因是：如果事先不知道数据的分布情况，很难估计簇的初始数量和迭代次数。\n\n## 搜索算法\n\n### 导向搜索 VS 贪婪搜索\n\n<img src=\"directed selection1.png\">\n\n如上图所示，在搜索过程中遍历到的点 $ p$ ，贪婪搜索要计算它的所有邻居到查询点 $q$ 的距离，而导向搜索只需要计算与点 $q$ 处于同一象限的邻居。\n\n<img src=\"guided search2.png\">\n\n上图中传统的贪婪搜索从入口点到查询终止需要计算10次与查询点的距离，而导向搜索只需要计算5次。\n\n### 导向搜索\n\n要实现导向搜索，需要对数据集中的每个点和它的邻居创建树状结构，创建索引的时候为每个结点划分子空间，导向搜索时还要有获取与查询点处于同一象限的邻居的过程。\n\n#### Creation of a tree structure to search in subspaces\n\n**主要思想：**\n\n对于已经建立的图上的某点 $p$ ，它的邻居将以树状的结构存储。在这个树状结构中，除了根结点 $p$ 和叶子结点（所有的叶子结点包含了 $p$ 的所有邻居），其它内部结点只是存储了用来划分空间的维度值（用的哪一维来划分的空间）；对于某个内部结点，它存储了某个维度值，它的两个子树是根据该维度值划分的，怎么划分呢？拿处于这个子空间的所有邻居在该维的值与点 $p$ 在该维的值比较，值小于 $p$ 的邻居被划分到 $neg$ 子树，值不小于 $p$ 的邻居被划分到 $pos$ 子树，然后再分别对这两个子树重复上述过程的划分直到对某个子树（子空间）按某维划分时得到的两个子树其中一个为空为止，此时就不用再建立存储该维的内部结点了，直接将该子树作为叶子就行了。\n\n根据维度划分，但是这个维度怎么选呢？维度选不好的话可能建立的这个子树只是一个线性表了，这样的话建立这个树状结构就没意义了，为此要好好地选，建立的树要尽可能的保证平衡，这就要求每次选维度时要看看它是否能尽可能地等分子空间的邻居。\n\n**划分子空间伪代码**\n\n```pseudocode\nFunction DivideSubspace( p, Np )\n\tData : point of graph p, neighbors points Np\n\tResult : space partition tree T\n\tdim ← select dimension based on Np\n\tneg ← { v ∈ N p | v [ dim ] < p[ dim ] }\n\tpos ← { v ∈ N p | v [ dim ] ≥ p[ dim ] }\n\tif | neg| = 0 or | pos | = 0 then\n\t\tT .points ← Np\n\telse\n\tT .dim ← dim\n\tT .neg ← DivideSubspace (p, neg)\n\tT .pos ← DivideSubspace (p, pos )\nreturn T\n```\n\n随记：为了实现导向搜索，在已经建好的图上对每个结点和它的邻居都建立一个树状结构（相当于附加了一个结构），这将提升搜索性能，但是会增加索引构建时间和内存占用。\n\n#### Identification of neighbors at the same subspace of the query\n\n**主要思想：**\n\n在搜索的过程中，对于遍历到的某点 $p$ ，要获取其与查询点 $q$ 处于同一象限（二维情况，高维类似）的邻居，需要从根节点（点 $p$）开始一直遍历到叶子结点，遍历过程中遇到内部结点时（要确定下一步走哪个子树）将点 $q$ 在该维的值与内部结点的值进行比较以确定下一步走哪个子树，走到叶子结点时，把其中 $p$ 的所有邻居返回（这就是找到的与 $q$ 处于同一象限的邻居）。另外，这个过程消耗的时间微不足道。\n\n**获取特定邻居伪代码**\n\n```pseudocode\nFunction GetNeighbors( q , p, node )\n\tData : query point q , point of graph p, node of space partition tree node\n\tResult : neighbors in query's subspace Nq\n\tNq ← φ\n\tif node is a tree leaf then\n\t\tNq ← node.points\n\telse\n\t\tif q [ node.dim ] < p[ node.dim ] then\n\t\t\tNq ← GetNeighbors (q, p, node.neg)\n\t\telse\n\t\tNq ← GetNeighbors (q, p, node.pos )\n\treturn Nq\n```\n\n## 构建搜索的大致过程\n\n1. 进行一定次数的分层聚类过程来建近邻图（在每个簇中用 $MST3$ 的方法连边，与[Wang2012](https://ieeexplore.ieee.org/document/6247790)类似）\n2. 为建立的近邻图中每个结点和其邻居建立树结构\n3. 创建一定数量的 $KD-Tree$ （内部结点为维数），从这些树中返回的结点中寻找离查询点最近的结点作为入口点\n4. 从入口点执行导向搜索（返回的邻居中找不到离查询更近的，还可转向相邻的叶子结点）\n\n## 参考文献\n\n> [1]Javier Vargas Muñoz,Marcos A. Gonçalves,Zanoni Dias,Ricardo da S. Torres. Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search[J]. Pattern Recognition,2019,96.","slug":"HCNNG","published":1,"updated":"2019-08-17T14:47:26.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07nwfg0002ufk0r1x55hq6s","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>最近看了一篇论文，名为：Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search，总的来说这篇论文的创新点是值得学习的，但是论文对很多细节内容没有描述清楚，这也是我读这篇论文有些失望的地方（自己比较菜，所以细节问题不能详细描述的话，我很难理解的）。</p>\n<p>这篇论文主要有两个创新点，分别为构图算法和搜索算法，构图算法采用了一种叫做多重分层聚类方法，具体这种方法有什么优势，作者没有分析；搜索算法采用了一种叫做导向搜索的方法，我们知道，几乎所有的基于图的搜索算法的搜索过程都是采用贪婪搜索，贪婪搜索的每一步要对途径点的所有邻居计算它们到查询点的距离，如果对每一个途径点能少计算一些距离，又能保证搜索结果相同，这必然会提升搜索性能，导向搜索便是如此。</p>\n<h2 id=\"构图算法\"><a href=\"#构图算法\" class=\"headerlink\" title=\"构图算法\"></a>构图算法</h2><p>论文中的图构建过程主要分两步，分别为多重分层聚类过程和各集簇图的融合。</p>\n<h3 id=\"Hierarchical-clustering-procedure\"><a href=\"#Hierarchical-clustering-procedure\" class=\"headerlink\" title=\"Hierarchical clustering procedure\"></a>Hierarchical clustering procedure</h3><p><strong>多重分层聚类过程伪代码</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function HierarchicalClustering(P, n)</span><br><span class=\"line\">\tData: data points P, min size of clusters n</span><br><span class=\"line\">\tResult: graph edges E</span><br><span class=\"line\">\tN ← | P | </span><br><span class=\"line\">\tE ← φ</span><br><span class=\"line\">\tif N &lt; n then</span><br><span class=\"line\">\t\tE ← MST3(P)</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tselect randomly p1 and p2 points from P</span><br><span class=\"line\">\t\tP1 ← &#123; p ∈ P | D (p, p1 ) &lt; D (p, p2 ) &#125;</span><br><span class=\"line\">\t\tP2 ← &#123; p ∈ P | D (p, p1 ) ≥ D (p, p2 ) &#125;</span><br><span class=\"line\">\t\tE1 ← Hierarchical Cl ustering(P1 , n )</span><br><span class=\"line\">\t\tE2 ← Hierarchical Cl ustering(P2 , n )</span><br><span class=\"line\">\t\tE ← E1 ∪ E2</span><br><span class=\"line\">\treturn E</span><br></pre></td></tr></table></figure></div>\n<p>简述：输入数据集点集 $P$ 和集簇的最大尺寸 $n$ ，输出经过分层聚类添加的边 $ E$ （初始化 $E$ 为空）；如果输入数据集的大小 $N &lt; n$ ，则直接在 $P$ 上通过最小生成树的变体连边（最大度为3，即 $MST3$ ）；否则，从 $P$ 中随机选两个点 $p_1$ 和 $p_2$ ，根据到其它点到这两点距离将数据集 $P$ 划分为两簇，对这两簇分别递归地执行分层聚类过程直到每个簇的尺寸都小于 $n$ 。</p>\n<h3 id=\"Fusion-of-graphs\"><a href=\"#Fusion-of-graphs\" class=\"headerlink\" title=\"Fusion of graphs\"></a>Fusion of graphs</h3><p><strong>各集簇图的融合的伪代码</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function CreateHCNNG(P, m, n)</span><br><span class=\"line\">\tData : data points P , number of random clusterings m , min size of clusters n</span><br><span class=\"line\">\tResult : graph edges E</span><br><span class=\"line\">\tE ← φ</span><br><span class=\"line\">\tfor i ← 1 to m do</span><br><span class=\"line\">\t\tE i ← HierarchicalClustering(P, n )</span><br><span class=\"line\">\t\tE ← E ∪ E i</span><br><span class=\"line\">\treturn E</span><br></pre></td></tr></table></figure></div>\n<p>简述：输入数据集点集 $P$ 、随机聚类数 $m$ 和集簇的最大尺寸 $n$ ，输出经过多次分层聚类添加的边 $ E$ （初始化 $E$ 为空）；对整个数据集重复分层聚类 $m$ 次，$m$ 次分层聚类得到的边都并到一起。</p>\n<p>总结分析：在数据集上只分层聚类一次，得到的图肯定是高度不连通的，因此，要执行多重的随机分层聚类过程并连接他们的结果图。</p>\n<p>注：本文采用分层聚类过程而没有采用K-means聚类原因是：如果事先不知道数据的分布情况，很难估计簇的初始数量和迭代次数。</p>\n<h2 id=\"搜索算法\"><a href=\"#搜索算法\" class=\"headerlink\" title=\"搜索算法\"></a>搜索算法</h2><h3 id=\"导向搜索-VS-贪婪搜索\"><a href=\"#导向搜索-VS-贪婪搜索\" class=\"headerlink\" title=\"导向搜索 VS 贪婪搜索\"></a>导向搜索 VS 贪婪搜索</h3><p><img src=\"//whenever5225.github.io/2019/08/17/HCNNG/directed selection1.png\"></p>\n<p>如上图所示，在搜索过程中遍历到的点 $ p$ ，贪婪搜索要计算它的所有邻居到查询点 $q$ 的距离，而导向搜索只需要计算与点 $q$ 处于同一象限的邻居。</p>\n<p><img src=\"//whenever5225.github.io/2019/08/17/HCNNG/guided search2.png\"></p>\n<p>上图中传统的贪婪搜索从入口点到查询终止需要计算10次与查询点的距离，而导向搜索只需要计算5次。</p>\n<h3 id=\"导向搜索\"><a href=\"#导向搜索\" class=\"headerlink\" title=\"导向搜索\"></a>导向搜索</h3><p>要实现导向搜索，需要对数据集中的每个点和它的邻居创建树状结构，创建索引的时候为每个结点划分子空间，导向搜索时还要有获取与查询点处于同一象限的邻居的过程。</p>\n<h4 id=\"Creation-of-a-tree-structure-to-search-in-subspaces\"><a href=\"#Creation-of-a-tree-structure-to-search-in-subspaces\" class=\"headerlink\" title=\"Creation of a tree structure to search in subspaces\"></a>Creation of a tree structure to search in subspaces</h4><p><strong>主要思想：</strong></p>\n<p>对于已经建立的图上的某点 $p$ ，它的邻居将以树状的结构存储。在这个树状结构中，除了根结点 $p$ 和叶子结点（所有的叶子结点包含了 $p$ 的所有邻居），其它内部结点只是存储了用来划分空间的维度值（用的哪一维来划分的空间）；对于某个内部结点，它存储了某个维度值，它的两个子树是根据该维度值划分的，怎么划分呢？拿处于这个子空间的所有邻居在该维的值与点 $p$ 在该维的值比较，值小于 $p$ 的邻居被划分到 $neg$ 子树，值不小于 $p$ 的邻居被划分到 $pos$ 子树，然后再分别对这两个子树重复上述过程的划分直到对某个子树（子空间）按某维划分时得到的两个子树其中一个为空为止，此时就不用再建立存储该维的内部结点了，直接将该子树作为叶子就行了。</p>\n<p>根据维度划分，但是这个维度怎么选呢？维度选不好的话可能建立的这个子树只是一个线性表了，这样的话建立这个树状结构就没意义了，为此要好好地选，建立的树要尽可能的保证平衡，这就要求每次选维度时要看看它是否能尽可能地等分子空间的邻居。</p>\n<p><strong>划分子空间伪代码</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function DivideSubspace( p, Np )</span><br><span class=\"line\">\tData : point of graph p, neighbors points Np</span><br><span class=\"line\">\tResult : space partition tree T</span><br><span class=\"line\">\tdim ← select dimension based on Np</span><br><span class=\"line\">\tneg ← &#123; v ∈ N p | v [ dim ] &lt; p[ dim ] &#125;</span><br><span class=\"line\">\tpos ← &#123; v ∈ N p | v [ dim ] ≥ p[ dim ] &#125;</span><br><span class=\"line\">\tif | neg| = 0 or | pos | = 0 then</span><br><span class=\"line\">\t\tT .points ← Np</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\tT .dim ← dim</span><br><span class=\"line\">\tT .neg ← DivideSubspace (p, neg)</span><br><span class=\"line\">\tT .pos ← DivideSubspace (p, pos )</span><br><span class=\"line\">return T</span><br></pre></td></tr></table></figure></div>\n<p>随记：为了实现导向搜索，在已经建好的图上对每个结点和它的邻居都建立一个树状结构（相当于附加了一个结构），这将提升搜索性能，但是会增加索引构建时间和内存占用。</p>\n<h4 id=\"Identification-of-neighbors-at-the-same-subspace-of-the-query\"><a href=\"#Identification-of-neighbors-at-the-same-subspace-of-the-query\" class=\"headerlink\" title=\"Identification of neighbors at the same subspace of the query\"></a>Identification of neighbors at the same subspace of the query</h4><p><strong>主要思想：</strong></p>\n<p>在搜索的过程中，对于遍历到的某点 $p$ ，要获取其与查询点 $q$ 处于同一象限（二维情况，高维类似）的邻居，需要从根节点（点 $p$）开始一直遍历到叶子结点，遍历过程中遇到内部结点时（要确定下一步走哪个子树）将点 $q$ 在该维的值与内部结点的值进行比较以确定下一步走哪个子树，走到叶子结点时，把其中 $p$ 的所有邻居返回（这就是找到的与 $q$ 处于同一象限的邻居）。另外，这个过程消耗的时间微不足道。</p>\n<p><strong>获取特定邻居伪代码</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function GetNeighbors( q , p, node )</span><br><span class=\"line\">\tData : query point q , point of graph p, node of space partition tree node</span><br><span class=\"line\">\tResult : neighbors in query&apos;s subspace Nq</span><br><span class=\"line\">\tNq ← φ</span><br><span class=\"line\">\tif node is a tree leaf then</span><br><span class=\"line\">\t\tNq ← node.points</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tif q [ node.dim ] &lt; p[ node.dim ] then</span><br><span class=\"line\">\t\t\tNq ← GetNeighbors (q, p, node.neg)</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\tNq ← GetNeighbors (q, p, node.pos )</span><br><span class=\"line\">\treturn Nq</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"构建搜索的大致过程\"><a href=\"#构建搜索的大致过程\" class=\"headerlink\" title=\"构建搜索的大致过程\"></a>构建搜索的大致过程</h2><ol>\n<li>进行一定次数的分层聚类过程来建近邻图（在每个簇中用 $MST3$ 的方法连边，与<a href=\"https://ieeexplore.ieee.org/document/6247790\" target=\"_blank\" rel=\"noopener\">Wang2012</a>类似）</li>\n<li>为建立的近邻图中每个结点和其邻居建立树结构</li>\n<li>创建一定数量的 $KD-Tree$ （内部结点为维数），从这些树中返回的结点中寻找离查询点最近的结点作为入口点</li>\n<li>从入口点执行导向搜索（返回的邻居中找不到离查询更近的，还可转向相邻的叶子结点）</li>\n</ol>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]Javier Vargas Muñoz,Marcos A. Gonçalves,Zanoni Dias,Ricardo da S. Torres. Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search[J]. Pattern Recognition,2019,96.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>最近看了一篇论文，名为：Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search，总的来说这篇论文的创新点是值得学习的，但是论文对很多细节内容没有描述清楚，这也是我读这篇论文有些失望的地方（自己比较菜，所以细节问题不能详细描述的话，我很难理解的）。</p>\n<p>这篇论文主要有两个创新点，分别为构图算法和搜索算法，构图算法采用了一种叫做多重分层聚类方法，具体这种方法有什么优势，作者没有分析；搜索算法采用了一种叫做导向搜索的方法，我们知道，几乎所有的基于图的搜索算法的搜索过程都是采用贪婪搜索，贪婪搜索的每一步要对途径点的所有邻居计算它们到查询点的距离，如果对每一个途径点能少计算一些距离，又能保证搜索结果相同，这必然会提升搜索性能，导向搜索便是如此。</p>\n<h2 id=\"构图算法\"><a href=\"#构图算法\" class=\"headerlink\" title=\"构图算法\"></a>构图算法</h2><p>论文中的图构建过程主要分两步，分别为多重分层聚类过程和各集簇图的融合。</p>\n<h3 id=\"Hierarchical-clustering-procedure\"><a href=\"#Hierarchical-clustering-procedure\" class=\"headerlink\" title=\"Hierarchical clustering procedure\"></a>Hierarchical clustering procedure</h3><p><strong>多重分层聚类过程伪代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function HierarchicalClustering(P, n)</span><br><span class=\"line\">\tData: data points P, min size of clusters n</span><br><span class=\"line\">\tResult: graph edges E</span><br><span class=\"line\">\tN ← | P | </span><br><span class=\"line\">\tE ← φ</span><br><span class=\"line\">\tif N &lt; n then</span><br><span class=\"line\">\t\tE ← MST3(P)</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tselect randomly p1 and p2 points from P</span><br><span class=\"line\">\t\tP1 ← &#123; p ∈ P | D (p, p1 ) &lt; D (p, p2 ) &#125;</span><br><span class=\"line\">\t\tP2 ← &#123; p ∈ P | D (p, p1 ) ≥ D (p, p2 ) &#125;</span><br><span class=\"line\">\t\tE1 ← Hierarchical Cl ustering(P1 , n )</span><br><span class=\"line\">\t\tE2 ← Hierarchical Cl ustering(P2 , n )</span><br><span class=\"line\">\t\tE ← E1 ∪ E2</span><br><span class=\"line\">\treturn E</span><br></pre></td></tr></table></figure>\n<p>简述：输入数据集点集 $P$ 和集簇的最大尺寸 $n$ ，输出经过分层聚类添加的边 $ E$ （初始化 $E$ 为空）；如果输入数据集的大小 $N &lt; n$ ，则直接在 $P$ 上通过最小生成树的变体连边（最大度为3，即 $MST3$ ）；否则，从 $P$ 中随机选两个点 $p_1$ 和 $p_2$ ，根据到其它点到这两点距离将数据集 $P$ 划分为两簇，对这两簇分别递归地执行分层聚类过程直到每个簇的尺寸都小于 $n$ 。</p>\n<h3 id=\"Fusion-of-graphs\"><a href=\"#Fusion-of-graphs\" class=\"headerlink\" title=\"Fusion of graphs\"></a>Fusion of graphs</h3><p><strong>各集簇图的融合的伪代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function CreateHCNNG(P, m, n)</span><br><span class=\"line\">\tData : data points P , number of random clusterings m , min size of clusters n</span><br><span class=\"line\">\tResult : graph edges E</span><br><span class=\"line\">\tE ← φ</span><br><span class=\"line\">\tfor i ← 1 to m do</span><br><span class=\"line\">\t\tE i ← HierarchicalClustering(P, n )</span><br><span class=\"line\">\t\tE ← E ∪ E i</span><br><span class=\"line\">\treturn E</span><br></pre></td></tr></table></figure>\n<p>简述：输入数据集点集 $P$ 、随机聚类数 $m$ 和集簇的最大尺寸 $n$ ，输出经过多次分层聚类添加的边 $ E$ （初始化 $E$ 为空）；对整个数据集重复分层聚类 $m$ 次，$m$ 次分层聚类得到的边都并到一起。</p>\n<p>总结分析：在数据集上只分层聚类一次，得到的图肯定是高度不连通的，因此，要执行多重的随机分层聚类过程并连接他们的结果图。</p>\n<p>注：本文采用分层聚类过程而没有采用K-means聚类原因是：如果事先不知道数据的分布情况，很难估计簇的初始数量和迭代次数。</p>\n<h2 id=\"搜索算法\"><a href=\"#搜索算法\" class=\"headerlink\" title=\"搜索算法\"></a>搜索算法</h2><h3 id=\"导向搜索-VS-贪婪搜索\"><a href=\"#导向搜索-VS-贪婪搜索\" class=\"headerlink\" title=\"导向搜索 VS 贪婪搜索\"></a>导向搜索 VS 贪婪搜索</h3><p><img src=\"//whenever5225.github.io/2019/08/17/HCNNG/directed selection1.png\"></p>\n<p>如上图所示，在搜索过程中遍历到的点 $ p$ ，贪婪搜索要计算它的所有邻居到查询点 $q$ 的距离，而导向搜索只需要计算与点 $q$ 处于同一象限的邻居。</p>\n<p><img src=\"//whenever5225.github.io/2019/08/17/HCNNG/guided search2.png\"></p>\n<p>上图中传统的贪婪搜索从入口点到查询终止需要计算10次与查询点的距离，而导向搜索只需要计算5次。</p>\n<h3 id=\"导向搜索\"><a href=\"#导向搜索\" class=\"headerlink\" title=\"导向搜索\"></a>导向搜索</h3><p>要实现导向搜索，需要对数据集中的每个点和它的邻居创建树状结构，创建索引的时候为每个结点划分子空间，导向搜索时还要有获取与查询点处于同一象限的邻居的过程。</p>\n<h4 id=\"Creation-of-a-tree-structure-to-search-in-subspaces\"><a href=\"#Creation-of-a-tree-structure-to-search-in-subspaces\" class=\"headerlink\" title=\"Creation of a tree structure to search in subspaces\"></a>Creation of a tree structure to search in subspaces</h4><p><strong>主要思想：</strong></p>\n<p>对于已经建立的图上的某点 $p$ ，它的邻居将以树状的结构存储。在这个树状结构中，除了根结点 $p$ 和叶子结点（所有的叶子结点包含了 $p$ 的所有邻居），其它内部结点只是存储了用来划分空间的维度值（用的哪一维来划分的空间）；对于某个内部结点，它存储了某个维度值，它的两个子树是根据该维度值划分的，怎么划分呢？拿处于这个子空间的所有邻居在该维的值与点 $p$ 在该维的值比较，值小于 $p$ 的邻居被划分到 $neg$ 子树，值不小于 $p$ 的邻居被划分到 $pos$ 子树，然后再分别对这两个子树重复上述过程的划分直到对某个子树（子空间）按某维划分时得到的两个子树其中一个为空为止，此时就不用再建立存储该维的内部结点了，直接将该子树作为叶子就行了。</p>\n<p>根据维度划分，但是这个维度怎么选呢？维度选不好的话可能建立的这个子树只是一个线性表了，这样的话建立这个树状结构就没意义了，为此要好好地选，建立的树要尽可能的保证平衡，这就要求每次选维度时要看看它是否能尽可能地等分子空间的邻居。</p>\n<p><strong>划分子空间伪代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function DivideSubspace( p, Np )</span><br><span class=\"line\">\tData : point of graph p, neighbors points Np</span><br><span class=\"line\">\tResult : space partition tree T</span><br><span class=\"line\">\tdim ← select dimension based on Np</span><br><span class=\"line\">\tneg ← &#123; v ∈ N p | v [ dim ] &lt; p[ dim ] &#125;</span><br><span class=\"line\">\tpos ← &#123; v ∈ N p | v [ dim ] ≥ p[ dim ] &#125;</span><br><span class=\"line\">\tif | neg| = 0 or | pos | = 0 then</span><br><span class=\"line\">\t\tT .points ← Np</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\tT .dim ← dim</span><br><span class=\"line\">\tT .neg ← DivideSubspace (p, neg)</span><br><span class=\"line\">\tT .pos ← DivideSubspace (p, pos )</span><br><span class=\"line\">return T</span><br></pre></td></tr></table></figure>\n<p>随记：为了实现导向搜索，在已经建好的图上对每个结点和它的邻居都建立一个树状结构（相当于附加了一个结构），这将提升搜索性能，但是会增加索引构建时间和内存占用。</p>\n<h4 id=\"Identification-of-neighbors-at-the-same-subspace-of-the-query\"><a href=\"#Identification-of-neighbors-at-the-same-subspace-of-the-query\" class=\"headerlink\" title=\"Identification of neighbors at the same subspace of the query\"></a>Identification of neighbors at the same subspace of the query</h4><p><strong>主要思想：</strong></p>\n<p>在搜索的过程中，对于遍历到的某点 $p$ ，要获取其与查询点 $q$ 处于同一象限（二维情况，高维类似）的邻居，需要从根节点（点 $p$）开始一直遍历到叶子结点，遍历过程中遇到内部结点时（要确定下一步走哪个子树）将点 $q$ 在该维的值与内部结点的值进行比较以确定下一步走哪个子树，走到叶子结点时，把其中 $p$ 的所有邻居返回（这就是找到的与 $q$ 处于同一象限的邻居）。另外，这个过程消耗的时间微不足道。</p>\n<p><strong>获取特定邻居伪代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function GetNeighbors( q , p, node )</span><br><span class=\"line\">\tData : query point q , point of graph p, node of space partition tree node</span><br><span class=\"line\">\tResult : neighbors in query&apos;s subspace Nq</span><br><span class=\"line\">\tNq ← φ</span><br><span class=\"line\">\tif node is a tree leaf then</span><br><span class=\"line\">\t\tNq ← node.points</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tif q [ node.dim ] &lt; p[ node.dim ] then</span><br><span class=\"line\">\t\t\tNq ← GetNeighbors (q, p, node.neg)</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\tNq ← GetNeighbors (q, p, node.pos )</span><br><span class=\"line\">\treturn Nq</span><br></pre></td></tr></table></figure>\n<h2 id=\"构建搜索的大致过程\"><a href=\"#构建搜索的大致过程\" class=\"headerlink\" title=\"构建搜索的大致过程\"></a>构建搜索的大致过程</h2><ol>\n<li>进行一定次数的分层聚类过程来建近邻图（在每个簇中用 $MST3$ 的方法连边，与<a href=\"https://ieeexplore.ieee.org/document/6247790\" target=\"_blank\" rel=\"noopener\">Wang2012</a>类似）</li>\n<li>为建立的近邻图中每个结点和其邻居建立树结构</li>\n<li>创建一定数量的 $KD-Tree$ （内部结点为维数），从这些树中返回的结点中寻找离查询点最近的结点作为入口点</li>\n<li>从入口点执行导向搜索（返回的邻居中找不到离查询更近的，还可转向相邻的叶子结点）</li>\n</ol>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]Javier Vargas Muñoz,Marcos A. Gonçalves,Zanoni Dias,Ricardo da S. Torres. Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search[J]. Pattern Recognition,2019,96.</p>\n</blockquote>\n"}],"PostAsset":[{"_id":"source/_posts/Q-HNSW/SQ量化计算示例.png","slug":"SQ量化计算示例.png","post":"ck07nwfcc0000fk0rh49koqon","modified":1,"renderable":0},{"_id":"source/_posts/hdf5使用/hdf5结构1.png","post":"ck07nwfd50008fk0rgro7a8y4","slug":"hdf5结构1.png","modified":1,"renderable":1},{"_id":"source/_posts/HCNNG/directed selection1.png","post":"ck07nwfg0002ufk0r1x55hq6s","slug":"directed selection1.png","modified":1,"renderable":1},{"_id":"source/_posts/HCNNG/guided search2.png","post":"ck07nwfg0002ufk0r1x55hq6s","slug":"guided search2.png","modified":1,"renderable":1},{"_id":"source/_posts/Q-HNSW/pq.png","post":"ck07nwfcc0000fk0rh49koqon","slug":"pq.png","modified":1,"renderable":1},{"_id":"source/_posts/Q-HNSW/pq2.png","post":"ck07nwfcc0000fk0rh49koqon","slug":"pq2.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck07nwfd30007fk0r2qkcls48","category_id":"ck07nwfcw0004fk0r0byho7ie","_id":"ck07nwfdh000dfk0rvfbafe8x"},{"post_id":"ck07nwfcc0000fk0rh49koqon","category_id":"ck07nwfcw0004fk0r0byho7ie","_id":"ck07nwfdl000hfk0rm4iqyf8k"},{"post_id":"ck07nwfcp0002fk0rqnsk5stl","category_id":"ck07nwfcw0004fk0r0byho7ie","_id":"ck07nwfdp000lfk0rlhdm7wez"},{"post_id":"ck07nwfd00006fk0r6ea8ces9","category_id":"ck07nwfcw0004fk0r0byho7ie","_id":"ck07nwfdu000qfk0r23gr61oc"},{"post_id":"ck07nwfd50008fk0rgro7a8y4","category_id":"ck07nwfdp000kfk0rpnn44m43","_id":"ck07nwfe0000vfk0r9mlms37t"},{"post_id":"ck07nwfdw000tfk0rm52r0ope","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfe50011fk0ro9kh2w6a"},{"post_id":"ck07nwfdb000bfk0rtfhfqj5n","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfe80016fk0rttopfut6"},{"post_id":"ck07nwfdy000ufk0rkm1q6s5u","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfeb0019fk0r2n0kpyyg"},{"post_id":"ck07nwfe1000yfk0rqdiiif2a","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfee001dfk0r9j55fqd6"},{"post_id":"ck07nwfdf000cfk0r98kcbxa2","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfeh001ffk0rg8risw4q"},{"post_id":"ck07nwfe40010fk0rcozgru1m","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfek001jfk0rzk3jen18"},{"post_id":"ck07nwfe70015fk0rgpzwaups","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfeo001mfk0rogxok6gv"},{"post_id":"ck07nwfdk000gfk0rk3l855sq","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfes001rfk0rslv326vw"},{"post_id":"ck07nwfea0018fk0r9lp7r6dd","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfew001ufk0r387aszu4"},{"post_id":"ck07nwfed001cfk0r57aicjc7","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfez001xfk0r4euey3ez"},{"post_id":"ck07nwfdn000jfk0rxryasrxq","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwff3001zfk0rlwnrqkxz"},{"post_id":"ck07nwfef001efk0rsir04j15","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwff50022fk0rwuh7rnjs"},{"post_id":"ck07nwfej001ifk0rvl542j0w","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfff0025fk0r6zyqbqam"},{"post_id":"ck07nwfdr000ofk0rpu8nxj8e","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwffi0028fk0rg01wk51a"},{"post_id":"ck07nwfen001lfk0rgbruzxyr","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwffk002cfk0rhjmko3dt"},{"post_id":"ck07nwfer001qfk0r07eh6mrw","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwffn002efk0rqi7sao7a"},{"post_id":"ck07nwfdt000pfk0rwn2czmxt","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwffp002hfk0r7uzp7p7f"},{"post_id":"ck07nwfev001tfk0rz3db6ypm","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwffr002kfk0r3wnil05d"},{"post_id":"ck07nwfey001wfk0r6rl0vlu7","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwffu002ofk0rts0z3zci"},{"post_id":"ck07nwff1001yfk0r82mr5u0u","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwffw002qfk0rxqgekas7"},{"post_id":"ck07nwff40021fk0riqxa6hc7","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwffz002tfk0rkbwm7907"},{"post_id":"ck07nwffe0024fk0rih19i3xq","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfg1002vfk0rjykek9v5"},{"post_id":"ck07nwffg0027fk0rf41qv0pp","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfg2002yfk0rkddj0zor"},{"post_id":"ck07nwffj002bfk0r1lytof08","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfg40030fk0r0h5gkt9a"},{"post_id":"ck07nwffl002dfk0r23509kty","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfg50033fk0rycryxjew"},{"post_id":"ck07nwffo002gfk0rln81vbam","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfg60035fk0r9wb23z9k"},{"post_id":"ck07nwffq002jfk0rf0w96ozz","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfg70038fk0rlug1dy9j"},{"post_id":"ck07nwfft002nfk0rkgzb2klp","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfg8003afk0ra4xhlsiz"},{"post_id":"ck07nwffv002pfk0r2a5t2nxw","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfg9003dfk0r5yevkmqp"},{"post_id":"ck07nwffy002sfk0rflpf1368","category_id":"ck07nwfdv000rfk0r3du7vd8v","_id":"ck07nwfga003ffk0r5wsqt7kd"},{"post_id":"ck07nwfg0002ufk0r1x55hq6s","category_id":"ck07nwfcw0004fk0r0byho7ie","_id":"ck07nwfgb003ifk0rk1axsh3t"}],"PostTag":[{"post_id":"ck07nwfcc0000fk0rh49koqon","tag_id":"ck07nwfcz0005fk0r985xb4i6","_id":"ck07nwfdm000ifk0rcpkmmu0o"},{"post_id":"ck07nwfcc0000fk0rh49koqon","tag_id":"ck07nwfd7000afk0r18l62egk","_id":"ck07nwfdp000mfk0rmfa6gge7"},{"post_id":"ck07nwfcp0002fk0rqnsk5stl","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfe3000zfk0r7dab84ks"},{"post_id":"ck07nwfcp0002fk0rqnsk5stl","tag_id":"ck07nwfd7000afk0r18l62egk","_id":"ck07nwfe60013fk0r6beu5prf"},{"post_id":"ck07nwfcp0002fk0rqnsk5stl","tag_id":"ck07nwfdv000sfk0rboda8vi0","_id":"ck07nwfe90017fk0r9kdnhal8"},{"post_id":"ck07nwfd00006fk0r6ea8ces9","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfem001kfk0rnpe9ij86"},{"post_id":"ck07nwfd00006fk0r6ea8ces9","tag_id":"ck07nwfd7000afk0r18l62egk","_id":"ck07nwfep001ofk0rrxr2t97t"},{"post_id":"ck07nwfd00006fk0r6ea8ces9","tag_id":"ck07nwfdv000sfk0rboda8vi0","_id":"ck07nwfet001sfk0rija5np6e"},{"post_id":"ck07nwfd30007fk0r2qkcls48","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwffd0023fk0rbh3m9hs5"},{"post_id":"ck07nwfd30007fk0r2qkcls48","tag_id":"ck07nwfd7000afk0r18l62egk","_id":"ck07nwffg0026fk0rfu4ojmq9"},{"post_id":"ck07nwfd30007fk0r2qkcls48","tag_id":"ck07nwfdv000sfk0rboda8vi0","_id":"ck07nwffj002afk0rb57t358h"},{"post_id":"ck07nwfd50008fk0rgro7a8y4","tag_id":"ck07nwff40020fk0r7lt881la","_id":"ck07nwffp002ifk0rj3lm397j"},{"post_id":"ck07nwfd50008fk0rgro7a8y4","tag_id":"ck07nwffi0029fk0r1mvqj6cd","_id":"ck07nwffs002lfk0rh12ciz1x"},{"post_id":"ck07nwffy002sfk0rflpf1368","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfg2002wfk0rxzc7r49x"},{"post_id":"ck07nwffy002sfk0rflpf1368","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfg4002zfk0r09nuhmgx"},{"post_id":"ck07nwffy002sfk0rflpf1368","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfg40031fk0rqrygv9u3"},{"post_id":"ck07nwfdb000bfk0rtfhfqj5n","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfg60034fk0rlbppo8zu"},{"post_id":"ck07nwfdb000bfk0rtfhfqj5n","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfg60036fk0rg3okxxek"},{"post_id":"ck07nwfdb000bfk0rtfhfqj5n","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfg70039fk0ra42m1ies"},{"post_id":"ck07nwfg0002ufk0r1x55hq6s","tag_id":"ck07nwfcz0005fk0r985xb4i6","_id":"ck07nwfg8003bfk0rk3qnevj6"},{"post_id":"ck07nwfg0002ufk0r1x55hq6s","tag_id":"ck07nwfd7000afk0r18l62egk","_id":"ck07nwfg9003efk0rt3vjvi29"},{"post_id":"ck07nwfdf000cfk0r98kcbxa2","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfga003gfk0rt1nnhz6d"},{"post_id":"ck07nwfdf000cfk0r98kcbxa2","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfgb003jfk0redqu4131"},{"post_id":"ck07nwfdf000cfk0r98kcbxa2","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfgc003kfk0rkm3w848t"},{"post_id":"ck07nwfdk000gfk0rk3l855sq","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfgd003mfk0rfnxpzu0f"},{"post_id":"ck07nwfdk000gfk0rk3l855sq","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfgd003nfk0rfxbs20hq"},{"post_id":"ck07nwfdk000gfk0rk3l855sq","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfge003pfk0rpczsmiqq"},{"post_id":"ck07nwfdn000jfk0rxryasrxq","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfgh003rfk0rcwhgnxfh"},{"post_id":"ck07nwfdn000jfk0rxryasrxq","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfgh003sfk0rb83rzlpj"},{"post_id":"ck07nwfdn000jfk0rxryasrxq","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfgi003ufk0rqqi8cjip"},{"post_id":"ck07nwfdr000ofk0rpu8nxj8e","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfgk003wfk0rrqpbkhy5"},{"post_id":"ck07nwfdr000ofk0rpu8nxj8e","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfgk003xfk0rqgt3j01i"},{"post_id":"ck07nwfdr000ofk0rpu8nxj8e","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfgl003zfk0r70p178y5"},{"post_id":"ck07nwfdt000pfk0rwn2czmxt","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfgn0041fk0rbyxzc50g"},{"post_id":"ck07nwfdt000pfk0rwn2czmxt","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfgn0042fk0rwvjhqcic"},{"post_id":"ck07nwfdt000pfk0rwn2czmxt","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfgo0044fk0rz3ypkmlw"},{"post_id":"ck07nwfdw000tfk0rm52r0ope","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfgq0046fk0relfoqvaa"},{"post_id":"ck07nwfdw000tfk0rm52r0ope","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfgq0047fk0ryplj58ed"},{"post_id":"ck07nwfdw000tfk0rm52r0ope","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfgs0049fk0r18uz8t4n"},{"post_id":"ck07nwfdy000ufk0rkm1q6s5u","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfgu004bfk0rolq69avg"},{"post_id":"ck07nwfdy000ufk0rkm1q6s5u","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfgv004cfk0r6pla2mxw"},{"post_id":"ck07nwfdy000ufk0rkm1q6s5u","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfgw004efk0r7gp7ab9b"},{"post_id":"ck07nwfe1000yfk0rqdiiif2a","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfgx004gfk0r5kjffvwd"},{"post_id":"ck07nwfe1000yfk0rqdiiif2a","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfgx004hfk0r38comswt"},{"post_id":"ck07nwfe1000yfk0rqdiiif2a","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfgy004jfk0rpeumh815"},{"post_id":"ck07nwfe40010fk0rcozgru1m","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfh0004lfk0rwhkpwrhe"},{"post_id":"ck07nwfe40010fk0rcozgru1m","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfh0004mfk0rpmvrewyl"},{"post_id":"ck07nwfe40010fk0rcozgru1m","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfh1004ofk0rkmxw4bo8"},{"post_id":"ck07nwfe70015fk0rgpzwaups","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfh2004qfk0ra0kzu6v4"},{"post_id":"ck07nwfe70015fk0rgpzwaups","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfh2004rfk0r0sb2qj3o"},{"post_id":"ck07nwfe70015fk0rgpzwaups","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfh3004tfk0re2po722p"},{"post_id":"ck07nwfea0018fk0r9lp7r6dd","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfh5004vfk0ryc7dip24"},{"post_id":"ck07nwfea0018fk0r9lp7r6dd","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfh5004wfk0rq2b8elym"},{"post_id":"ck07nwfea0018fk0r9lp7r6dd","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfh6004yfk0r7mqx04ii"},{"post_id":"ck07nwfed001cfk0r57aicjc7","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfh70050fk0rm961rys7"},{"post_id":"ck07nwfed001cfk0r57aicjc7","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfh70051fk0r3awj7gov"},{"post_id":"ck07nwfed001cfk0r57aicjc7","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfh80053fk0rspzmrv6a"},{"post_id":"ck07nwfef001efk0rsir04j15","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfh90055fk0rv6nvndbj"},{"post_id":"ck07nwfef001efk0rsir04j15","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfh90056fk0rgb3xb9b2"},{"post_id":"ck07nwfef001efk0rsir04j15","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfhb0058fk0raxmvbhc0"},{"post_id":"ck07nwfej001ifk0rvl542j0w","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfhc005afk0r6gz543ft"},{"post_id":"ck07nwfej001ifk0rvl542j0w","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfhc005bfk0rmwa2pcqo"},{"post_id":"ck07nwfej001ifk0rvl542j0w","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfhd005dfk0rfto911r0"},{"post_id":"ck07nwfen001lfk0rgbruzxyr","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfhe005ffk0rt6bhjydj"},{"post_id":"ck07nwfen001lfk0rgbruzxyr","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfhe005gfk0rmkej8kko"},{"post_id":"ck07nwfen001lfk0rgbruzxyr","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfhh005ifk0rcud07ewm"},{"post_id":"ck07nwfer001qfk0r07eh6mrw","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfhi005kfk0rpexodleh"},{"post_id":"ck07nwfer001qfk0r07eh6mrw","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfhj005lfk0rh6e0d4yz"},{"post_id":"ck07nwfer001qfk0r07eh6mrw","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfhk005nfk0rkpovim1i"},{"post_id":"ck07nwfev001tfk0rz3db6ypm","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfhl005pfk0rqz5vqmly"},{"post_id":"ck07nwfev001tfk0rz3db6ypm","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfhl005qfk0rgyyemv81"},{"post_id":"ck07nwfev001tfk0rz3db6ypm","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfhm005sfk0rcfdk8l9v"},{"post_id":"ck07nwfey001wfk0r6rl0vlu7","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfhn005ufk0rb0of348d"},{"post_id":"ck07nwfey001wfk0r6rl0vlu7","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfhn005vfk0rgz5s6uoq"},{"post_id":"ck07nwfey001wfk0r6rl0vlu7","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfho005xfk0rh5u2k1i8"},{"post_id":"ck07nwff1001yfk0r82mr5u0u","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfhp005zfk0r39jzp700"},{"post_id":"ck07nwff1001yfk0r82mr5u0u","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfhp0060fk0ry84xrvqt"},{"post_id":"ck07nwff1001yfk0r82mr5u0u","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfhq0062fk0rs8mjyy4m"},{"post_id":"ck07nwff40021fk0riqxa6hc7","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfhs0064fk0regwvpqvi"},{"post_id":"ck07nwff40021fk0riqxa6hc7","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfhs0065fk0r8kue11cq"},{"post_id":"ck07nwff40021fk0riqxa6hc7","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfht0067fk0rqkao03hi"},{"post_id":"ck07nwffe0024fk0rih19i3xq","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfhv0069fk0rcj6qfktt"},{"post_id":"ck07nwffe0024fk0rih19i3xq","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfhv006afk0r1d1f01k7"},{"post_id":"ck07nwffe0024fk0rih19i3xq","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfhw006cfk0rd8iuntcw"},{"post_id":"ck07nwffg0027fk0rf41qv0pp","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfhy006efk0roqhu3731"},{"post_id":"ck07nwffg0027fk0rf41qv0pp","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfhy006ffk0rbpg7bjw2"},{"post_id":"ck07nwffg0027fk0rf41qv0pp","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfi0006hfk0r52t5laii"},{"post_id":"ck07nwffj002bfk0r1lytof08","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfi1006jfk0rl493pqv7"},{"post_id":"ck07nwffj002bfk0r1lytof08","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfi1006kfk0rpof3gk7g"},{"post_id":"ck07nwffj002bfk0r1lytof08","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfi2006mfk0r8fi975wr"},{"post_id":"ck07nwffl002dfk0r23509kty","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfi3006ofk0rhgtnivy6"},{"post_id":"ck07nwffl002dfk0r23509kty","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfi3006pfk0roichy0nn"},{"post_id":"ck07nwffl002dfk0r23509kty","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfi4006rfk0r18rrjvf3"},{"post_id":"ck07nwffo002gfk0rln81vbam","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfi4006sfk0rlf31grjc"},{"post_id":"ck07nwffo002gfk0rln81vbam","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfi5006ufk0rzaet4mpc"},{"post_id":"ck07nwffo002gfk0rln81vbam","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfi6006vfk0rm2rtayir"},{"post_id":"ck07nwffq002jfk0rf0w96ozz","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfi7006xfk0rs3zz76wg"},{"post_id":"ck07nwffq002jfk0rf0w96ozz","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfi7006yfk0rjsmot9c1"},{"post_id":"ck07nwffq002jfk0rf0w96ozz","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfi7006zfk0rh5to0je1"},{"post_id":"ck07nwfft002nfk0rkgzb2klp","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfi70070fk0rqkbzfh5c"},{"post_id":"ck07nwfft002nfk0rkgzb2klp","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfi80071fk0ri6uj38ly"},{"post_id":"ck07nwfft002nfk0rkgzb2klp","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfi80072fk0rm31zwbo2"},{"post_id":"ck07nwffv002pfk0r2a5t2nxw","tag_id":"ck07nwffn002ffk0rnemndax5","_id":"ck07nwfi80073fk0rohux8bds"},{"post_id":"ck07nwffv002pfk0r2a5t2nxw","tag_id":"ck07nwfdi000ffk0rhcobmih2","_id":"ck07nwfi80074fk0r819m7sr0"},{"post_id":"ck07nwffv002pfk0r2a5t2nxw","tag_id":"ck07nwffx002rfk0rmy7doel3","_id":"ck07nwfi80075fk0r7joe3l9m"}],"Tag":[{"name":"论文阅读","_id":"ck07nwfcz0005fk0r985xb4i6"},{"name":"ANNS","_id":"ck07nwfd7000afk0r18l62egk"},{"name":"C/C++","_id":"ck07nwfdi000ffk0rhcobmih2"},{"name":"源码阅读","_id":"ck07nwfdv000sfk0rboda8vi0"},{"name":"HDF5","_id":"ck07nwff40020fk0r7lt881la"},{"name":"python","_id":"ck07nwffi0029fk0r1mvqj6cd"},{"name":"PAT","_id":"ck07nwffn002ffk0rnemndax5"},{"name":"编程","_id":"ck07nwffx002rfk0rmy7doel3"}]}}