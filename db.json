{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/uploads/avatar.png","path":"uploads/avatar.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/affix.js","path":"js/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/post-details.js","path":"js/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.all-contributorsrc","hash":"a5a536579490546f2275da03765738ceabe45584","modified":1565963317274},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1565963317274},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1565963317274},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1565963317274},{"_id":"themes/next/.gitignore","hash":"b80cec1d5e6a73d1cec382aad8046d1352a1e963","modified":1565963317274},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1565963317274},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1565963317274},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1565963317274},{"_id":"themes/next/README.md","hash":"2fcc7621e898732ef7976b89ca2511f84c577c35","modified":1565963317274},{"_id":"themes/next/_config.yml","hash":"018c82cf699be64855ea5dd4932e24f062c394b2","modified":1565960400810},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1565963317274},{"_id":"themes/next/gulpfile.coffee","hash":"2ba4aeddc257a74a209edf5218137010662cd5fb","modified":1565963317274},{"_id":"themes/next/package.json","hash":"170e67ca35a7c1ddc7dae50a90f6d4270143331f","modified":1565963317278},{"_id":"source/_posts/HCNNG.md","hash":"06a3b4f8bd9141916169789490105f3b76961ce6","modified":1566007745116},{"_id":"source/_posts/Q-HNSW.md","hash":"c6ed2f782ed70fa98f7127f4bd2aa5be35966c9f","modified":1565963317270},{"_id":"source/_posts/anns-nsg-code1.md","hash":"50716ba359e0016546e8d86b201bbce6505c504f","modified":1565963317270},{"_id":"source/_posts/anns-nsg-code2.md","hash":"5d650b32201ce164e913559d90dbeec9fe44fc56","modified":1565963317270},{"_id":"source/_posts/anns-nsg-code3.md","hash":"070cc55a31bccb8bee3aeb8c02753ffc2dab85ad","modified":1565963317270},{"_id":"source/_posts/pat1001.md","hash":"e854e665f046a2c6bedb389062e3594039be160a","modified":1565963317270},{"_id":"source/_posts/pat1002.md","hash":"525cdc0fe026a9fcbee519bd59ae623844c1061f","modified":1565963317270},{"_id":"source/_posts/pat1003.md","hash":"11df71855b4c7c56d0a805e05ef545c49dece381","modified":1565963317274},{"_id":"source/_posts/pat1004.md","hash":"592b44883239e1537918066b8c162bdacddf343c","modified":1565963317274},{"_id":"source/_posts/pat1005.md","hash":"f846ac85752193f64824d5d56056ac81480d74dc","modified":1565963317274},{"_id":"source/_posts/pat1006.md","hash":"fccf5137461be16da2c7c3a42b3afdbd12b97470","modified":1565963317274},{"_id":"source/_posts/pat1007.md","hash":"c0004b9ade8497a9a92d66bc21231cbe6036f688","modified":1565963317274},{"_id":"source/_posts/pat1008.md","hash":"37454ec41860e70f6ecac068e78ce7f4f164708f","modified":1565963519590},{"_id":"source/_posts/pat1009.md","hash":"5c23a6050f7878f2568eddb2d04dec977dd15805","modified":1565963317274},{"_id":"source/_posts/pat1010.md","hash":"a17ff5b4b513a18fd2d58497785c62158bcff682","modified":1565963317274},{"_id":"source/categories/index.md","hash":"6a8071844e89dfd70d36e2146f4255d77d893fd4","modified":1565963317274},{"_id":"source/tags/index.md","hash":"f86715088a98cda558f1bf4ffe975995139ad2a0","modified":1565963317274},{"_id":"source/uploads/avatar.png","hash":"cd9d8967569834b632c4e195471555e993c519a3","modified":1565963317274},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"c149f003d03501565e7688915cd8f2e99fbf8f42","modified":1565963317274},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"d91296a4c9facf6e2dc15815820b6444262f575c","modified":1565963317274},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1565963317274},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3239625bb2573e61f7bcce27a74882a9ff7021e9","modified":1565963317274},{"_id":"themes/next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1565963317274},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1565963317274},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1565963317274},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"b795f819d4e85197c31ac8892aab55e19bca970a","modified":1565963317274},{"_id":"themes/next/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1565963317274},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1565963317274},{"_id":"themes/next/.github/release-drafter.yml","hash":"fbd6210c4454c2db6cad1960dd03c89488d68c87","modified":1565963317274},{"_id":"themes/next/.github/stale.yml","hash":"41bf97ee86b8940a0b2e754499ec77fd2b44b717","modified":1565963317274},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1565963317274},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1565963317274},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"4094dab82cbdfdd0de117e94b508bbd5ceb3d363","modified":1565963317274},{"_id":"themes/next/docs/AUTHORS.md","hash":"9b6dea4c6ad89b1cf588251e0886c028d8f427e2","modified":1565963317274},{"_id":"themes/next/docs/DATA-FILES.md","hash":"290237970f023ad1345dcb8825fe3004de69900c","modified":1565963317274},{"_id":"themes/next/docs/INSTALLATION.md","hash":"5385246ab4756e3e26ec9fe1f6a6759812177cc4","modified":1565963317274},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"1fb2c852fad03b73882069f1ec0659db2e1f2da0","modified":1565963317274},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1565963317274},{"_id":"themes/next/docs/MATH.md","hash":"026d2cff73c22a30ea39c50783557ff4913aceac","modified":1565963317274},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"a07ca23c38f6e4dddd4b74016b30e88cd3796f75","modified":1565963317274},{"_id":"themes/next/languages/de.yml","hash":"88dcfa3e53cef1b7f858f98ca9f980179169ae4c","modified":1565963317274},{"_id":"themes/next/languages/default.yml","hash":"4de207d89824422ccec5bc754a81af032d5e30f9","modified":1565963317274},{"_id":"themes/next/languages/en.yml","hash":"4de207d89824422ccec5bc754a81af032d5e30f9","modified":1565963317274},{"_id":"themes/next/languages/es.yml","hash":"a5203c7bbae70bc40f2ee526f9e8105ca9be851e","modified":1565963317274},{"_id":"themes/next/languages/fa.yml","hash":"cc1f3a13e020e2cc666ddc57aaebc4c1ebd669d0","modified":1565963317274},{"_id":"themes/next/languages/fr.yml","hash":"c1e2e892c678920854e1f3df409118398523849e","modified":1565963317274},{"_id":"themes/next/languages/hu.yml","hash":"3b4c10c86a228da70dc4b1a1784a6f942e186032","modified":1565963317274},{"_id":"themes/next/languages/id.yml","hash":"3a9f4485e6801e0e6fae749133a52e3797760795","modified":1565963317274},{"_id":"themes/next/languages/it.yml","hash":"28ff9197a3d21e838e33bb026d8adb544320cb1a","modified":1565963317274},{"_id":"themes/next/languages/ja.yml","hash":"8f85a6500716191159f16c7f484ba61ddd16eeb6","modified":1565963317274},{"_id":"themes/next/languages/ko.yml","hash":"1df31bf037bcb6868a4bd60c49ff55eec5b8167f","modified":1565963317274},{"_id":"themes/next/languages/nl.yml","hash":"6f4a339ecc67a140f3f9c7bec369cbda6b45afd7","modified":1565963317274},{"_id":"themes/next/languages/pt-BR.yml","hash":"301a0535df5de7b585c7c9752053c41c6ef26f9b","modified":1565963317274},{"_id":"themes/next/languages/pt.yml","hash":"6d87701443e33a13574049e613f064f1eb250c95","modified":1565963317274},{"_id":"themes/next/languages/ru.yml","hash":"93872ac01074159566ee3e1738eea6e9216bab8e","modified":1565963317274},{"_id":"themes/next/languages/tr.yml","hash":"5489606e6c40c0b226a3414c8e5037aac965211d","modified":1565963317274},{"_id":"themes/next/languages/uk.yml","hash":"765ba405778f07d7ec3713606568852b04e1a862","modified":1565963317274},{"_id":"themes/next/languages/vi.yml","hash":"6a812db8606498980cd64f001e9ef2f50e124809","modified":1565963317274},{"_id":"themes/next/languages/zh-CN.yml","hash":"844d201c96fc7b50ee69e57e81d3418b4e367f65","modified":1566007310633},{"_id":"themes/next/languages/zh-HK.yml","hash":"7a5e47f561d4b6e132f7f3b09676afbf8520264e","modified":1565963317274},{"_id":"themes/next/languages/zh-TW.yml","hash":"3f3674cac8f47a9a509a7557ea1557bbfbd027e8","modified":1565963317274},{"_id":"themes/next/layout/_layout.swig","hash":"7c7eeb42b631c46ec02cb723b22b68ae80409aa3","modified":1565963317274},{"_id":"themes/next/layout/archive.swig","hash":"9941337701a8c0377a7af0024d948fcbb3a29a58","modified":1565963317278},{"_id":"themes/next/layout/category.swig","hash":"3020f7646dc3c79d44e3b5f1ce24b06d5b9fc13a","modified":1565963317278},{"_id":"themes/next/layout/index.swig","hash":"8cf3451dd2d5727920b351a8f5eefdddb5bf3638","modified":1565963317278},{"_id":"themes/next/layout/page.swig","hash":"dc48085a0c69c60155d57aa546ded835a1ff767e","modified":1565963317278},{"_id":"themes/next/layout/post.swig","hash":"4291b34b17fc6f1c06eb69852c894913e889a774","modified":1565963317278},{"_id":"themes/next/layout/tag.swig","hash":"02b5dfdfa1d1ff61f161f592d38b09454c941036","modified":1565963317278},{"_id":"themes/next/scripts/codeblock.js","hash":"080e262bc3b0cb1d43baf3881a7d9a0f0cbe6ce5","modified":1565963317278},{"_id":"source/_posts/HCNNG/directed selection1.png","hash":"d50290e0eaed07cd49396f0c74d553def9877918","modified":1565144762610},{"_id":"source/_posts/HCNNG/guided search2.png","hash":"f205acd008ed89f3c3872fd3ecacbef5801fc243","modified":1565145198502},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c37a60580c901c79ccb22564b228a46e06207445","modified":1565963317274},{"_id":"themes/next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"57e1e06e845193e80c7df4a4454af28352526f7a","modified":1565963317274},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"07c423cce4157b8e2dbf60907ccbf3f18c4cf98a","modified":1565963317274},{"_id":"themes/next/.github/ISSUE_TEMPLATE/non-english.md","hash":"0b0727ff4d5180ae67f930fb4f8e9488e33eda9f","modified":1565963317274},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"67d04e3e29a2675d1a9f87d1ae6ea0769e963ff1","modified":1565963317274},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1565963317274},{"_id":"themes/next/docs/ru/README.md","hash":"932d3965d8b1a1ff653c07a0cafcdbf5892d6945","modified":1565963317274},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1565963317274},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"caa624092175d44e3d3a8c6ca23922718da2354c","modified":1565963317274},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"0dfb458370a0ffbbe37c00f53c15e3aa3e79b125","modified":1565963317274},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"2949ccf2cba5238f01a1386a9e91e646c7a22260","modified":1565963317274},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"c46f3f7496fc422207cc5954e10a2bc972b650aa","modified":1565963317274},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"c13546dd70a99a7d2d409cddf5d59f2f4d4d44a4","modified":1565963317274},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"e568a1b3c532e0ecf33cc237e1425b2579bd006d","modified":1565963317274},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"83feca62190abcca0332915ffe0eefe582573085","modified":1565963317274},{"_id":"themes/next/docs/zh-CN/README.md","hash":"79a73361b24e7fb7022992702961faacd6a2f9fe","modified":1565963317274},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"ba918bbd8faf32c28335693f03ff37c6acaff7f3","modified":1565963317274},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"41625b8424b680e7c81fc9294e0bb1859434ce01","modified":1565963317274},{"_id":"themes/next/layout/_macro/post.swig","hash":"77c85ee0310c75face777a3bcc190439e49020dc","modified":1565963317274},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a5ceff84bbe9ad2be780ff58aeea91972c32d44","modified":1565963317278},{"_id":"themes/next/layout/_partials/comments.swig","hash":"62f1556e9b8cc3217dad9ab4db8f474088fa1383","modified":1565963317278},{"_id":"themes/next/layout/_partials/footer.swig","hash":"ff9a950a81c1c66f2d3cbe9304c427c728716d7f","modified":1565963317278},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"40e940c3213b74933e529cd64f64c1f6f512b5ca","modified":1565963317278},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"769a983fe2f77908bfc8590ff37a0d8958b47598","modified":1565963317278},{"_id":"themes/next/layout/_partials/pjax.swig","hash":"6d7d2e1676f0abd7d4a4d607eca51065e02d07f4","modified":1565963317278},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"4b0c972c44bfa7ab07604280563deb9cc3974657","modified":1565963317278},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"e3c54ae7eca24a85148ec3bfb6712abf07c418c9","modified":1565963317278},{"_id":"themes/next/layout/_scripts/index.swig","hash":"3807bed8ae3f632019f26e282ef613d2275287ee","modified":1565963317278},{"_id":"themes/next/layout/_scripts/next-boot.swig","hash":"283e78eb795f52236026434dab6a0667f14d3c08","modified":1565963317278},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1565963317278},{"_id":"themes/next/layout/_scripts/three.swig","hash":"216849ad2503f578839c500ede529744a3abaf03","modified":1565963317278},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"70482f40ed63cfc3cef805ff93cf1a7c4b512fbc","modified":1565963317278},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1565963317278},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"2aec6040ac80977dd0c04b918fcc8851ed569947","modified":1565963317278},{"_id":"themes/next/layout/_third-party/facebook-sdk.swig","hash":"e7103dc133c8a6109e2a2e086c8e65ac80dbf6bb","modified":1565963317278},{"_id":"themes/next/layout/_third-party/index.swig","hash":"56133a4237a5cdee2bd874a2b3c0be2ac967dd2b","modified":1565963317278},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"ccef9c8ef5406a33af56fe5493492ee8ac2bb965","modified":1565963317278},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1565963317278},{"_id":"themes/next/layout/_third-party/vkontakte-api.swig","hash":"dc9c90c69734e658ec82995f3cfa286003c01281","modified":1565963317278},{"_id":"themes/next/scripts/events/core.js","hash":"a25690d8b03779f7e318108c8eace9baf6d4283a","modified":1565963317278},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"834599d2b83f06e90f8cf618cddc106fe900ba5c","modified":1565963317278},{"_id":"themes/next/scripts/filters/exturl.js","hash":"9c32675f64121ffbe454189b8e418b408f79d9c2","modified":1565963317278},{"_id":"themes/next/scripts/filters/lazyload.js","hash":"51672320fff6b39f56fe6a2881c611afe4e79b8e","modified":1565963317278},{"_id":"themes/next/scripts/filters/minify.js","hash":"ef2c0280521462da88f220ba69b047d5d99adc76","modified":1565963317278},{"_id":"themes/next/scripts/helpers/engine.js","hash":"896a581feb9432e58a325ad04d66d6310a12374e","modified":1565963317278},{"_id":"themes/next/scripts/helpers/font.js","hash":"53169e2d04f0c21e68beb07c212be0a6c2a9aaea","modified":1565963317278},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1565963317278},{"_id":"themes/next/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1565963317278},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1565963317278},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1565963317278},{"_id":"themes/next/scripts/tags/full-image.js","hash":"70b1d6ed969143e3912daf051ccc3585d984c146","modified":1565963317278},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"8fc05f22b88553bc1d96e0c925799cd97920fc6a","modified":1565963317278},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"60f880c1e11a7df1aee4f2e01d65451fecc0372c","modified":1565963317278},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1565963317278},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1565963317278},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1565963317278},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1565963317278},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1565963317278},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1565963317278},{"_id":"themes/next/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1565963317282},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1565963317282},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1565963317282},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1565963317282},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1565963317282},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1565963317282},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1565963317282},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1565963317282},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1565963317282},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1565963317282},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1565963317282},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1565963317282},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1565963317282},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1565963317282},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1565963317282},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1565963317282},{"_id":"themes/next/source/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1565963317282},{"_id":"themes/next/source/js/algolia-search.js","hash":"955ae621677ae99416dd8f362eea02ef39811eca","modified":1565963317282},{"_id":"themes/next/source/js/local-search.js","hash":"a857346f051001d6fe0c7ef1780b313f9e5c7955","modified":1565963317282},{"_id":"themes/next/source/js/motion.js","hash":"4d1a9ab5ce397c093711769045288ce48fd392bd","modified":1565963317282},{"_id":"themes/next/source/js/next-boot.js","hash":"1fc6c1b80f265396cb193b37d4138cc3c8fe08c7","modified":1565963317282},{"_id":"themes/next/source/js/post-details.js","hash":"b72c145c7995fe6975b637ef3bcbb2c41b47c289","modified":1565963317282},{"_id":"themes/next/source/js/scrollspy.js","hash":"e630d9b05ab6bcc9ebab92435587d5a554eb0e3b","modified":1565963317282},{"_id":"themes/next/source/js/utils.js","hash":"6c83632baed3fb9b55c23ee3ecbea5c63072f2b0","modified":1565963317282},{"_id":"source/_posts/Q-HNSW/pq.png","hash":"36be539633c975ca81544a5e9874d2a6f9b0d0f1","modified":1565963317270},{"_id":"source/_posts/Q-HNSW/pq2.png","hash":"912a0020d0c2b0f97216bc5376950c47abd35546","modified":1565963317270},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565963317282},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565963317282},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565963317282},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"9e959646899a1dd381c0bea870408cd392c93c70","modified":1565963317274},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"1dc3875981923aee38b7b1e3ca3813b75ed6ab9c","modified":1565963317274},{"_id":"themes/next/layout/_partials/analytics/busuanzi-counter.swig","hash":"b35b2bf2ce3d73cabe8c443a45c2a82d45baf151","modified":1565963317278},{"_id":"themes/next/layout/_partials/analytics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1565963317278},{"_id":"themes/next/layout/_partials/analytics/index.swig","hash":"2925f6353934b1b2adc2808059e64dd7d220edd7","modified":1565963317278},{"_id":"themes/next/layout/_partials/analytics/tencent-analytics.swig","hash":"493a1ef6c8f475d4dd3156a6ab37690dc75695ea","modified":1565963317278},{"_id":"themes/next/layout/_partials/analytics/tencent-mta.swig","hash":"198813a3f382bda4278fe3759bf0f18a5769bb33","modified":1565963317278},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"6f02724e24945d7e5f0dcd351deebc90996ad38d","modified":1565963317278},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"62c54241724fb7da90b9598c356691f3b4fda7a1","modified":1565963317278},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"8dd7ac5ccc52848b3d0fb0f102874c1a8c1c45b6","modified":1565963317278},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"536421ab2e32436211a604cf9ddd6924e20a56ce","modified":1565963317278},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"a14a301e3d7187595b37b2ab419709a9c81a3a76","modified":1565963317278},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"a72e33e11df9d3639cdebab4f480e397c70deacb","modified":1565963317278},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"883ea1d024a8262eb8d3213de71c8ccb30daf095","modified":1565963317278},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"d3c25d70f0fd76121e4cacb9f8af4ccbe2a3c74d","modified":1565963317278},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"3ed15de413b9ca83641bbd0b740f94b450630357","modified":1565963317278},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"38683b340b199ab204a43f3d2cd41e21f01ceb06","modified":1565963317278},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"e2549106ea26ac48019aa3f8023b8fdc78c0f6db","modified":1565963317278},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"40483139657cde24356c6a4033a6386b909327a9","modified":1565963317278},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"2edfaf1579ea58e15cb5583fb7962dfee9af2257","modified":1565963317278},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"d9fe715fee716f78c7976c4e8838da71439ee0e0","modified":1565963317278},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"7bce91d429216724db5e337ec64cf7f05b022c97","modified":1565963317278},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1565963317278},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"15b542f5b06b7532234af367340b9ed9fcebb0ac","modified":1565963317278},{"_id":"themes/next/layout/_partials/share/index.swig","hash":"609ce79f47756977b90bce365614d4f8d1020196","modified":1565963317278},{"_id":"themes/next/layout/_partials/share/likely.swig","hash":"3ca3fe150c4dc4fd938410f367814445436fb67a","modified":1565963317278},{"_id":"themes/next/layout/_partials/share/needsharebutton.swig","hash":"09ae1250c1e142d251cc0e979097f1dd95e277bb","modified":1565963317278},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"84a4201867c034afbf25862b63af4a582f7086b1","modified":1565963317278},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"5b05f165547391bf231e52f56f3d925efc09bc44","modified":1565963317278},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"5258d3dbfbb6d585f798c697463f8b67b7dea02b","modified":1565963317278},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1565963317278},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1565963317278},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"f2ff7799baac49eb9779f66e0cd083fac70b87a2","modified":1565963317278},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"509621f1a68e7ab41193a14a2c50a21aff976f9e","modified":1565963317278},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-jquery.swig","hash":"b485797073495e24bf2f0b85880d513257bfed72","modified":1565963317278},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"7fd0459d2f1cfe1254f2c2b8087dc094c8cb0e84","modified":1565963317278},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1565963317278},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"753ae34ed3852ea3c75a9f29d057f53a9829f247","modified":1565963317278},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"3b9c50e3cbfa2c4d6cb0ffd443a994a212f3dbfc","modified":1565963317278},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"051fadd4cb777769fc4c0fe3cb0b309e3236e5c2","modified":1565963317278},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"20fcbed44aede1b908bd17d7a0279b03639068b1","modified":1565963317278},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"4dc2a96ad40b40d9b89da21105feee05df81ff35","modified":1565963317278},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1565963317278},{"_id":"themes/next/layout/_third-party/chat/index.swig","hash":"5ab4a8b4306c837d2f8c211a9d7fdaed76fa254d","modified":1565963317278},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1565963317278},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"1130b8bd60f3b84397974486e6586d7f0afaf836","modified":1565963317278},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"4e076cb5d50588c8fc5e032b6c9e8f6601628561","modified":1565963317278},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"1e27f34b06f8144905e6904b67dfc03c99d16499","modified":1565963317278},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"620ae7b01e6272ce31fb214c2c9422df60aa589a","modified":1565963317278},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f95bc4d7ffaddc3c0df0ef3eeeaac58ff83f560","modified":1565963317278},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"f40c1ca8ed4e7e92bc47f130243ef2cc396f38a8","modified":1565963317278},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"8b2b0997ebf5e9d17dcd6c0b7601dea0eec26b2e","modified":1565963317278},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"079910669dcc9b0606dde15c66bfdcf1c97b8119","modified":1565963317278},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"68d38da0762e82f7188b589479fa1cf80c7688ea","modified":1565963317278},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"157abdff4c5fddceae5af2631b5fff202abc0e5e","modified":1565963317278},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"b2fd17688f0433571b37704bc8df798e175e7811","modified":1565963317278},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"353da7ea00400897ae920a085aa4bee2224da50d","modified":1565963317278},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1565963317278},{"_id":"themes/next/layout/_third-party/tags/index.swig","hash":"83d0a8f71878c6b96a04ba08567b9064de6cce83","modified":1565963317278},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"119f67181cde1bd5391bc073b11343ea853513fb","modified":1565963317278},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"f3357db3b0d829f5f104ce740bee16abb4b0f473","modified":1565963317278},{"_id":"themes/next/scripts/events/lib/config.js","hash":"867b23bb231224064a79df5278ba0a02215044eb","modified":1565963317278},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1565963317278},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"251dcc22ed213da9b6135e1b958010e3352408d4","modified":1565963317278},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"00922e352b5585ae15cc19eaec8f5c31bd57814c","modified":1565963317278},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1565963317278},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"8f4643a844f90ca0ad853de1fe7c687c7569503d","modified":1565963317278},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"0388d10adf2330be20ec932010e35a81f4296c5d","modified":1565963317278},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"a9ebe8e80edb5e19ec4b845090d260ae9de1566a","modified":1565963317278},{"_id":"themes/next/scripts/filters/comment/facebook-comments-plugin.js","hash":"8d5379344310ae67c1e8880e517d643e40670874","modified":1565963317278},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"4505867a0598b83583f9740ecba3e4f053d18ebe","modified":1565963317278},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"71ee48847a1e54962640a4b64298ecc3e76565f8","modified":1565963317278},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"0c12943b5d681cf070431c3ff9256eaf358d4a3c","modified":1565963317278},{"_id":"themes/next/scripts/filters/comment/vkontakte.js","hash":"2aa608a4bc664e87e4e56b016a28dc7d798d9966","modified":1565963317278},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1565963317282},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2bb4c78b5da482751085beb73ab01ecd2dcbccda","modified":1565963317282},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"b82c5b13ca6d1a6424dcc1245fb7722cac090579","modified":1565963317282},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"451f1f904df8b39015ccff5ce804c047f132b1f4","modified":1565963317282},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"4c101c21b4f2712e47dba869ccc116b245fb0909","modified":1565963317282},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"db52bce619bb848189e83b7bfabd1b2a06fd5578","modified":1565963317282},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f1308b410fb4ed648631d301e981db4dc72d6cd5","modified":1565963317282},{"_id":"themes/next/source/js/schemes/muse.js","hash":"3367e85556ba4d138b4f9ad33d00b723bb75557a","modified":1565963317282},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b1bfc528190a93256fda7863685d5424636e87ed","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1565963317282},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1565963317286},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1565963317286},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1565963317286},{"_id":"themes/next/source/lib/jquery/index.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1565963317286},{"_id":"source/_posts/Q-HNSW/SQ量化计算示例.png","hash":"8d291107c44eaa85656ca8bcad574c52e90cab56","modified":1565963317270},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"1c178041435de8076a1ce31304184007a837fcbb","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"58a80925a845d590d4a9736ae92a6b03dc7c575f","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"2b14d2a3f814c9dbd92c00835878925f9f10ca28","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"dc658f44f4cda38684a584c95a6823e96c970a6d","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"1960299fe99163f44f1cd90210eea1ef4b2cb723","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"390993b47942a47d23ed8904c92e0186b6e9af29","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"4bec027d48ebb95acd5f5786456ee1eb19a23ee4","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/scrollbar.styl","hash":"202ee1f1f8e64d8292df16f40ee176ff4e5d7e71","modified":1565963317278},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"bdf464ee7972a007949acbe555d82e57621b3714","modified":1565963317282},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"442f7598991b92ec8bc3ce5343e18730da92e4fb","modified":1565963317282},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1238932450efc3f4c2e25c704794437ac78e6164","modified":1565963317282},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"4c4986b704c3cc3167c3c2a69c454446cf152528","modified":1565963317282},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"4f7140cc0db08b47a25c4c7aad71047d433051a1","modified":1565963317282},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"e9e3bcef3f9a3541a11e5f3edfed2a3d13d22b80","modified":1565963317282},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"173fe462331ba12d612f7ade8f18c0f9e259fa5d","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"65328fbc073901d78729463e46cb28a4c37a6fac","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"71d75fa309cf5b96d876da536f57c047e57afcff","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"87d19a45db10689aae9a09736efd1eb896a35b3d","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"3462ffd270f3e218e0a8362262466e79d731f975","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f87b7a7d30e9111f7af269dcf7bd8c1893343fe8","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"0c4ab171ecf12e49c95b66b3f1aa2ab2f3281c87","modified":1566008003243},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"49c6c656ed6e7348f967c01f8302fe1f6a5e3cd9","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"54c5e23ec3dcbbc77848ededba76e861cf0f4719","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"bdc0ada1eec3c1d625bfe2c148cdfc1b3460fa32","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"0138165021be463f19e092f8972ac41aea3fb68a","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"45f03b3bb80e32fd5648ce723055d7552b87d97c","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"2fa573d7c04b8fa4717fc50265d7e4273f4325ea","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"cbeb23488b707418a60b59ef8d6abc4f0d671959","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"2e0681fa265a55f0259969109a3b9e3788bf516c","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ce3820f199b54d09f7216a5df14d4492736c4520","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"4b976940b728a78428e88f40acf9a801223af88a","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"10b4794ba62726fc052c74d786d962ed79d0780b","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1565963317286},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1565963317286},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"0442cccb1111eec0d38357fba810319d781b7ef9","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"172a83db23cb3f8a95e7cd6046befbc841caa869","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"4c7140804d1ca65396959a3e8f8b79b9c4d3233f","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"cf37dc0ef20a8423a28b056458e1fa609875789a","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"dada73ae88f01fab2ab4d2c83eddfc558de2110a","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"080f22922d89ca714a2463d6eaedfd4cb68e8aef","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/highlight/copy-code.styl","hash":"d42c19193bd6d398cd1196a2848659c2b63b17d7","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"d58080515f4392e08ca69728d842dc798f7e662a","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"a67dc85f6d158dac20e951ab55988ff7e9e1739b","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"d416014be2accb53931ac0b4c60a0c5e3cf2d180","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"1f217159862b12a89350e11b5097a8f3031af28f","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"621dc55fe935afe68a19f67b7447524292bc7e56","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"207019d9e4911060dc23f01f821727fe0fe4717c","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"83afee4c02f63642267a4d1487d028dc83c7739c","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"7cee1dc30f323e9f46e1fd4cf61c1a3d4cebb8b0","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"f96b241dea210e494b9173be76cce65faee7157a","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"bb892e5934a3b525afd1e578db991b747ea4c1eb","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"8b0dde1df553a5a2f5e0765e4e4ce48e9ab2c90e","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"c60afb603d58cad3ad13e1a16c66832538510063","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2e2a09dddd2a394a635bcefb6207b6cddcb784c7","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"c898a67edb271c26f81e98acab93299a99fe3b95","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"fdebe803d61e781883453d6301b7e2bcf5a8ec05","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"70d13702896e03013f694f89d5a68adbf0fff4af","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"556140847ee1333cf97d4ee63a5f58cb371a9369","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"6d379b38cab56666e24463a7a4d52006e232a8b1","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"dcf801bd2478e125dffc0e23c0e720d048cf580f","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"e292224b3d01a845b303a04ff83dc5c6945a553c","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2ef546b4cfa5038ebb050c592c5135bbeb51af41","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"cd7ab38366a73edf3e7576d2629339660080b6f6","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"1d9f17a59b030dd05732ccdc5b187705f0353130","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"8fc3facb9e9d4dae2578d0a271648d997a7f9bf3","modified":1565963317278},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"f3108a247549fbdf11071d023add3f1b34ad2b23","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"b2eca1259b9df8df81c5768bbb9b7ef65826e360","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"bfa93a958115ddd562cd10f74b2eb887b6d3f187","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"92381084e1aaf6798f058668aacef15bf1721739","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"02e5a998748a67fa885fb06fae242bcf3f2786fb","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"0527bc64708a9446dc7bbb2c7e39ab3a61251c26","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"5d63f7479ee0f645e7538c60e827036fad74766d","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"78d309e22206a4addda3c393282518dae02250ed","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"278c31ed96474cd8a2ba465ed4131327e9d598bd","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"f211554f09a9005fad30b3e8f031be7f3fb7016a","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"90edaf377646093a07ea4e26accb861be9ebbb2b","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"438f3f7209fa6b8ab092a6f200a8c8c009565291","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"c2fc1a5105d6691d680f7b77b9301db416ebac8b","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"85b8606763f4177d2f9a11c1909a21ab1ae2011c","modified":1565963317282},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"d048206fad5ace7f8df16cbc0b074b46ade16f81","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"dd55feb43312489b5ec5692cc9d83ad150d7b389","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/_sidebar.styl","hash":"1c3371551dadb86a4bf662c1adaa0dc2d2654ff7","modified":1565963317282},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"a29de6af7503a854e962eca8a3b8b911525ef2e5","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1565963317282},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1565963317282}],"Category":[{"name":"近似最近邻搜索","_id":"cjzewx81z0004wtfkhjt2r4pe"},{"name":"PAT","_id":"cjzewx82a000lwtfk3rbkk1uk"}],"Data":[],"Page":[{"title":"categories","date":"2019-08-09T12:35:42.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-08-09 20:35:42\ntype: \"categories\"\n---\n","updated":"2019-08-16T13:48:37.274Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjzewx81w0001wtfk9ygbagxh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-08-09T12:35:11.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-08-09 20:35:11\ntype: \"tags\"\n---\n","updated":"2019-08-16T13:48:37.274Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjzewx81y0003wtfkccxoq4oz","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"量化编码的分层可通航小世界图（HNSW）笔记","date":"2019-08-11T10:23:46.000Z","mathjax":true,"_content":"\n\n## 引言\n\n### 两种改进方法\n\nHNSW内存开销大，基于量化编码的检索算法能够压缩数据集向量，大幅度降低内存占用。将量化编码与HNSW结合，有两种改进方法：\n\n1. 使用标量量化编码向量的HNSWSQ算法\n2. 使用乘积量化编码向量的HNSWPQ算法\n\n### HNSW内存开销大的原因\n\n1. 需要存储全部的数据集元素\n2. 需要存储每一层中节点之间的连接关系\n\n## 乘积量化\n\n### PQ乘积量化\n\n#### 建立码本和量化编码\n<img src=\"pq.png\">\n\n将`N * 128`的数据集进行切分，划分为4个子空间，每个子空间中向量的维数为32，得到`N * 4 * 32`。每个字段（子空间）同样有`N`个向量，对这`N`个向量进行聚类得到256个类中心，这样4个字段一共有`4 * 256`个类中心。每个子空间的所有`N`个向量都可以用该子空间的256个类中心的某一向量表示，对256个类中心进行编码只需8位即可，从而任一向量在该子空间的子向量的编码就可以用该子向量所属的类中心的编码来表示。\n\n待编码样本如何编码？\n\n对于待编码的样本，将它进行相同的切分，然后在各个子空间里逐一找到距离它们最近的类中心，然后用类中心的id来表示它们，即完成了待编码样本的编码。\n\n#### 码字的搜索算法\n\n<img src=\"pq2.png\">\n\n对于某个查询向量，要查询离其最近的k个向量，关键就是计算查询向量与dataset中的样本距离了。暴力方法就是计算数据集中所有的样本与查询向量的距离，然后进行排序，选出top@k个最近的样本返回。对数据集进行PQ乘积量化编码后，这个过程就变成下面的方式：\n\n将查询向量进行切分，切分方式与对数据集切分的相同，计算查询向量的每个子向量在相应的子空间中到256个类中心的距离，从而得到`4 * 256`的距离矩阵。某个样本到查询向量的距离就可以通过以下方式得到（不需单独计算了）：\n\n比如该样本的编码是(124, 56, 132, 222)，在`4 * 256`的距离矩阵中依次找出（查表）查询向量的相应子向量到编码为124（第一个子空间），编码为56（第二个子空间），编码为132（第三个子空间），编码为222（第四个子空间）的类中心的距离，将这4个距离相加的和作为该样本（编码是(124, 56, 132, 222)）到查询向量的距离。\n\n#### PQ乘积量化能够加速索引的原理\n\n* 将全样本的距离计算，转化为到子空间类中心的距离计算（加快查询）\n* 对特征进行编码后，可以用一个相对比较短的编码来表示样本（降低内存消耗）\n* 存储时只需存储类中心的向量值（计算距离时只需要它们 ）\n\n注：暴力搜索的距离计算的次数随样本数目`N`成线性增长，对于上面的例子，PQ乘积量化只需`4 * 256`次距离计算。\n\n## HNSWPQ算法\n\n与原始的HNSW算法相比，不再需要在内存中保持原始向量。将HNSW算法作为索引算法，采用PQ算法进行向量编码，由于使用PQ算法对原始向量编码，需要将HNSW算法插入过程中与近邻点距离的计算相应地修改为PQ的距离计算。\n\n### HNSWPQ的构建过程\n\n1. 对**原始向量**量化编码建立码本存储在内存中\n2. 新插入的结点作为查询结点，得到其能达到的最大层（指数衰减概率分布）\n3. 选邻居时，计算某结点与查询向量的距离应为PQ的距离计算\n\n与原HNSW算法相比，主要有两方面的不同：\n\n* 原HNSW算法直接在原始向量上构建，而HNSWPQ算法需要先对原始向量进行量化编码建立码本在此基础上再逐个插入结点构建（增加了一步）\n* 原HNSW算法计算距离时是直接计算，而HNSWPQ算法采用PQ距离计算方法（计算速度快）\n\n## HNSWSQ算法\n\n标量量化（SQ）对向量的每一维都进行量化，HNSWSQ算法采用最大最小量化方法。对于向量的第 $ i $ 维，通过样本集训练获取该维出现的最大值 $ vmax[i] $ 和最小值 $ vmin[i] $ ，然后将向量 $ \\vec{a} $ 第 $ i $ 维的值量化为:\n$$\n\\frac{x_i - vmin[i]} {vmax[i]}\n$$\n其中，$ i = 1, ..., n $ ，量化后的值编码存储，假设每一维编码为１个字节，则进一步处理为：\n$$\nf(x_i) = \\lfloor \\varphi( \\frac{x_i - vmin[i]} {vmax[i]} ) \\times 255\\rfloor\n$$\n其中：\n\n$$\n \\varphi(x) = \\begin{cases}\n1 & x \\geq 1\\\\\nx & 0 < x < 1\\\\\n0 & x \\leq 0\n\\end{cases}\n$$\nHNSWSQ算法在插入结点计算距离时，首先将编码后的向量解码还原，然后计算查询向量与解码向量的距离。\n\n<img src=\"SQ量化计算示例.png\">\n\n## 量化后性能分析\n### HNSWPQ算法性能分析\n\n与原始的HNSW算法相比，HNSWPQ算法在同样查询时间下Recall@1准确率要低很多，内存占用几乎只有 HNSW算法的一半（主要是结点连接关系），构建索引耗时是HNSW的几倍，主要是编码引起。\n\n随着PQ子量化器（子空间）的增多，由于量化误差的降低，各算法的Recall@1准确率逐步提高。\n\n### HNSWSQ算法性能分析\n\n在GIST-1M数据集上HNSWSQ8的内存开销只有HNSW算法的29.5%，两者性能相当；在SIFT-1M数据集上，两者性能相当，构建索引耗时相当，HNSWSQ8的内存占用比HNSW低45%。\n\n## 参考文献\n\n> [1]李秋珍,白兴强,李立夏,王赢.量化编码的分层可通航小世界图算法[J].计算机工程与科学,2019,41(04):618-625.\n> [2]Yong Yuan, 图像检索：再叙ANN Search, http://yongyuan.name/blog/ann-search.html, 2019.7.30.","source":"_posts/Q-HNSW.md","raw":"---\ntitle: 量化编码的分层可通航小世界图（HNSW）笔记\ndate: 2019-08-11 18:23:46\ntags:\n- 论文阅读\n- ANNS\ncategories:\n- 近似最近邻搜索\nmathjax: true\n---\n\n\n## 引言\n\n### 两种改进方法\n\nHNSW内存开销大，基于量化编码的检索算法能够压缩数据集向量，大幅度降低内存占用。将量化编码与HNSW结合，有两种改进方法：\n\n1. 使用标量量化编码向量的HNSWSQ算法\n2. 使用乘积量化编码向量的HNSWPQ算法\n\n### HNSW内存开销大的原因\n\n1. 需要存储全部的数据集元素\n2. 需要存储每一层中节点之间的连接关系\n\n## 乘积量化\n\n### PQ乘积量化\n\n#### 建立码本和量化编码\n<img src=\"pq.png\">\n\n将`N * 128`的数据集进行切分，划分为4个子空间，每个子空间中向量的维数为32，得到`N * 4 * 32`。每个字段（子空间）同样有`N`个向量，对这`N`个向量进行聚类得到256个类中心，这样4个字段一共有`4 * 256`个类中心。每个子空间的所有`N`个向量都可以用该子空间的256个类中心的某一向量表示，对256个类中心进行编码只需8位即可，从而任一向量在该子空间的子向量的编码就可以用该子向量所属的类中心的编码来表示。\n\n待编码样本如何编码？\n\n对于待编码的样本，将它进行相同的切分，然后在各个子空间里逐一找到距离它们最近的类中心，然后用类中心的id来表示它们，即完成了待编码样本的编码。\n\n#### 码字的搜索算法\n\n<img src=\"pq2.png\">\n\n对于某个查询向量，要查询离其最近的k个向量，关键就是计算查询向量与dataset中的样本距离了。暴力方法就是计算数据集中所有的样本与查询向量的距离，然后进行排序，选出top@k个最近的样本返回。对数据集进行PQ乘积量化编码后，这个过程就变成下面的方式：\n\n将查询向量进行切分，切分方式与对数据集切分的相同，计算查询向量的每个子向量在相应的子空间中到256个类中心的距离，从而得到`4 * 256`的距离矩阵。某个样本到查询向量的距离就可以通过以下方式得到（不需单独计算了）：\n\n比如该样本的编码是(124, 56, 132, 222)，在`4 * 256`的距离矩阵中依次找出（查表）查询向量的相应子向量到编码为124（第一个子空间），编码为56（第二个子空间），编码为132（第三个子空间），编码为222（第四个子空间）的类中心的距离，将这4个距离相加的和作为该样本（编码是(124, 56, 132, 222)）到查询向量的距离。\n\n#### PQ乘积量化能够加速索引的原理\n\n* 将全样本的距离计算，转化为到子空间类中心的距离计算（加快查询）\n* 对特征进行编码后，可以用一个相对比较短的编码来表示样本（降低内存消耗）\n* 存储时只需存储类中心的向量值（计算距离时只需要它们 ）\n\n注：暴力搜索的距离计算的次数随样本数目`N`成线性增长，对于上面的例子，PQ乘积量化只需`4 * 256`次距离计算。\n\n## HNSWPQ算法\n\n与原始的HNSW算法相比，不再需要在内存中保持原始向量。将HNSW算法作为索引算法，采用PQ算法进行向量编码，由于使用PQ算法对原始向量编码，需要将HNSW算法插入过程中与近邻点距离的计算相应地修改为PQ的距离计算。\n\n### HNSWPQ的构建过程\n\n1. 对**原始向量**量化编码建立码本存储在内存中\n2. 新插入的结点作为查询结点，得到其能达到的最大层（指数衰减概率分布）\n3. 选邻居时，计算某结点与查询向量的距离应为PQ的距离计算\n\n与原HNSW算法相比，主要有两方面的不同：\n\n* 原HNSW算法直接在原始向量上构建，而HNSWPQ算法需要先对原始向量进行量化编码建立码本在此基础上再逐个插入结点构建（增加了一步）\n* 原HNSW算法计算距离时是直接计算，而HNSWPQ算法采用PQ距离计算方法（计算速度快）\n\n## HNSWSQ算法\n\n标量量化（SQ）对向量的每一维都进行量化，HNSWSQ算法采用最大最小量化方法。对于向量的第 $ i $ 维，通过样本集训练获取该维出现的最大值 $ vmax[i] $ 和最小值 $ vmin[i] $ ，然后将向量 $ \\vec{a} $ 第 $ i $ 维的值量化为:\n$$\n\\frac{x_i - vmin[i]} {vmax[i]}\n$$\n其中，$ i = 1, ..., n $ ，量化后的值编码存储，假设每一维编码为１个字节，则进一步处理为：\n$$\nf(x_i) = \\lfloor \\varphi( \\frac{x_i - vmin[i]} {vmax[i]} ) \\times 255\\rfloor\n$$\n其中：\n\n$$\n \\varphi(x) = \\begin{cases}\n1 & x \\geq 1\\\\\nx & 0 < x < 1\\\\\n0 & x \\leq 0\n\\end{cases}\n$$\nHNSWSQ算法在插入结点计算距离时，首先将编码后的向量解码还原，然后计算查询向量与解码向量的距离。\n\n<img src=\"SQ量化计算示例.png\">\n\n## 量化后性能分析\n### HNSWPQ算法性能分析\n\n与原始的HNSW算法相比，HNSWPQ算法在同样查询时间下Recall@1准确率要低很多，内存占用几乎只有 HNSW算法的一半（主要是结点连接关系），构建索引耗时是HNSW的几倍，主要是编码引起。\n\n随着PQ子量化器（子空间）的增多，由于量化误差的降低，各算法的Recall@1准确率逐步提高。\n\n### HNSWSQ算法性能分析\n\n在GIST-1M数据集上HNSWSQ8的内存开销只有HNSW算法的29.5%，两者性能相当；在SIFT-1M数据集上，两者性能相当，构建索引耗时相当，HNSWSQ8的内存占用比HNSW低45%。\n\n## 参考文献\n\n> [1]李秋珍,白兴强,李立夏,王赢.量化编码的分层可通航小世界图算法[J].计算机工程与科学,2019,41(04):618-625.\n> [2]Yong Yuan, 图像检索：再叙ANN Search, http://yongyuan.name/blog/ann-search.html, 2019.7.30.","slug":"Q-HNSW","published":1,"updated":"2019-08-16T13:48:37.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx81t0000wtfk4n9i3nk2","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><h3 id=\"两种改进方法\"><a href=\"#两种改进方法\" class=\"headerlink\" title=\"两种改进方法\"></a>两种改进方法</h3><p>HNSW内存开销大，基于量化编码的检索算法能够压缩数据集向量，大幅度降低内存占用。将量化编码与HNSW结合，有两种改进方法：</p>\n<ol>\n<li>使用标量量化编码向量的HNSWSQ算法</li>\n<li>使用乘积量化编码向量的HNSWPQ算法</li>\n</ol>\n<h3 id=\"HNSW内存开销大的原因\"><a href=\"#HNSW内存开销大的原因\" class=\"headerlink\" title=\"HNSW内存开销大的原因\"></a>HNSW内存开销大的原因</h3><ol>\n<li>需要存储全部的数据集元素</li>\n<li>需要存储每一层中节点之间的连接关系</li>\n</ol>\n<h2 id=\"乘积量化\"><a href=\"#乘积量化\" class=\"headerlink\" title=\"乘积量化\"></a>乘积量化</h2><h3 id=\"PQ乘积量化\"><a href=\"#PQ乘积量化\" class=\"headerlink\" title=\"PQ乘积量化\"></a>PQ乘积量化</h3><h4 id=\"建立码本和量化编码\"><a href=\"#建立码本和量化编码\" class=\"headerlink\" title=\"建立码本和量化编码\"></a>建立码本和量化编码</h4><p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/pq.png\"></p>\n<p>将<code>N * 128</code>的数据集进行切分，划分为4个子空间，每个子空间中向量的维数为32，得到<code>N * 4 * 32</code>。每个字段（子空间）同样有<code>N</code>个向量，对这<code>N</code>个向量进行聚类得到256个类中心，这样4个字段一共有<code>4 * 256</code>个类中心。每个子空间的所有<code>N</code>个向量都可以用该子空间的256个类中心的某一向量表示，对256个类中心进行编码只需8位即可，从而任一向量在该子空间的子向量的编码就可以用该子向量所属的类中心的编码来表示。</p>\n<p>待编码样本如何编码？</p>\n<p>对于待编码的样本，将它进行相同的切分，然后在各个子空间里逐一找到距离它们最近的类中心，然后用类中心的id来表示它们，即完成了待编码样本的编码。</p>\n<h4 id=\"码字的搜索算法\"><a href=\"#码字的搜索算法\" class=\"headerlink\" title=\"码字的搜索算法\"></a>码字的搜索算法</h4><p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/pq2.png\"></p>\n<p>对于某个查询向量，要查询离其最近的k个向量，关键就是计算查询向量与dataset中的样本距离了。暴力方法就是计算数据集中所有的样本与查询向量的距离，然后进行排序，选出top@k个最近的样本返回。对数据集进行PQ乘积量化编码后，这个过程就变成下面的方式：</p>\n<p>将查询向量进行切分，切分方式与对数据集切分的相同，计算查询向量的每个子向量在相应的子空间中到256个类中心的距离，从而得到<code>4 * 256</code>的距离矩阵。某个样本到查询向量的距离就可以通过以下方式得到（不需单独计算了）：</p>\n<p>比如该样本的编码是(124, 56, 132, 222)，在<code>4 * 256</code>的距离矩阵中依次找出（查表）查询向量的相应子向量到编码为124（第一个子空间），编码为56（第二个子空间），编码为132（第三个子空间），编码为222（第四个子空间）的类中心的距离，将这4个距离相加的和作为该样本（编码是(124, 56, 132, 222)）到查询向量的距离。</p>\n<h4 id=\"PQ乘积量化能够加速索引的原理\"><a href=\"#PQ乘积量化能够加速索引的原理\" class=\"headerlink\" title=\"PQ乘积量化能够加速索引的原理\"></a>PQ乘积量化能够加速索引的原理</h4><ul>\n<li>将全样本的距离计算，转化为到子空间类中心的距离计算（加快查询）</li>\n<li>对特征进行编码后，可以用一个相对比较短的编码来表示样本（降低内存消耗）</li>\n<li>存储时只需存储类中心的向量值（计算距离时只需要它们 ）</li>\n</ul>\n<p>注：暴力搜索的距离计算的次数随样本数目<code>N</code>成线性增长，对于上面的例子，PQ乘积量化只需<code>4 * 256</code>次距离计算。</p>\n<h2 id=\"HNSWPQ算法\"><a href=\"#HNSWPQ算法\" class=\"headerlink\" title=\"HNSWPQ算法\"></a>HNSWPQ算法</h2><p>与原始的HNSW算法相比，不再需要在内存中保持原始向量。将HNSW算法作为索引算法，采用PQ算法进行向量编码，由于使用PQ算法对原始向量编码，需要将HNSW算法插入过程中与近邻点距离的计算相应地修改为PQ的距离计算。</p>\n<h3 id=\"HNSWPQ的构建过程\"><a href=\"#HNSWPQ的构建过程\" class=\"headerlink\" title=\"HNSWPQ的构建过程\"></a>HNSWPQ的构建过程</h3><ol>\n<li>对<strong>原始向量</strong>量化编码建立码本存储在内存中</li>\n<li>新插入的结点作为查询结点，得到其能达到的最大层（指数衰减概率分布）</li>\n<li>选邻居时，计算某结点与查询向量的距离应为PQ的距离计算</li>\n</ol>\n<p>与原HNSW算法相比，主要有两方面的不同：</p>\n<ul>\n<li>原HNSW算法直接在原始向量上构建，而HNSWPQ算法需要先对原始向量进行量化编码建立码本在此基础上再逐个插入结点构建（增加了一步）</li>\n<li>原HNSW算法计算距离时是直接计算，而HNSWPQ算法采用PQ距离计算方法（计算速度快）</li>\n</ul>\n<h2 id=\"HNSWSQ算法\"><a href=\"#HNSWSQ算法\" class=\"headerlink\" title=\"HNSWSQ算法\"></a>HNSWSQ算法</h2><p>标量量化（SQ）对向量的每一维都进行量化，HNSWSQ算法采用最大最小量化方法。对于向量的第 $ i $ 维，通过样本集训练获取该维出现的最大值 $ vmax[i] $ 和最小值 $ vmin[i] $ ，然后将向量 $ \\vec{a} $ 第 $ i $ 维的值量化为:</p>\n<script type=\"math/tex; mode=display\">\n\\frac{x_i - vmin[i]} {vmax[i]}</script><p>其中，$ i = 1, …, n $ ，量化后的值编码存储，假设每一维编码为１个字节，则进一步处理为：</p>\n<script type=\"math/tex; mode=display\">\nf(x_i) = \\lfloor \\varphi( \\frac{x_i - vmin[i]} {vmax[i]} ) \\times 255\\rfloor</script><p>其中：</p>\n<script type=\"math/tex; mode=display\">\n \\varphi(x) = \\begin{cases}\n1 & x \\geq 1\\\\\nx & 0 < x < 1\\\\\n0 & x \\leq 0\n\\end{cases}</script><p>HNSWSQ算法在插入结点计算距离时，首先将编码后的向量解码还原，然后计算查询向量与解码向量的距离。</p>\n<p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/SQ量化计算示例.png\"></p>\n<h2 id=\"量化后性能分析\"><a href=\"#量化后性能分析\" class=\"headerlink\" title=\"量化后性能分析\"></a>量化后性能分析</h2><h3 id=\"HNSWPQ算法性能分析\"><a href=\"#HNSWPQ算法性能分析\" class=\"headerlink\" title=\"HNSWPQ算法性能分析\"></a>HNSWPQ算法性能分析</h3><p>与原始的HNSW算法相比，HNSWPQ算法在同样查询时间下Recall@1准确率要低很多，内存占用几乎只有 HNSW算法的一半（主要是结点连接关系），构建索引耗时是HNSW的几倍，主要是编码引起。</p>\n<p>随着PQ子量化器（子空间）的增多，由于量化误差的降低，各算法的Recall@1准确率逐步提高。</p>\n<h3 id=\"HNSWSQ算法性能分析\"><a href=\"#HNSWSQ算法性能分析\" class=\"headerlink\" title=\"HNSWSQ算法性能分析\"></a>HNSWSQ算法性能分析</h3><p>在GIST-1M数据集上HNSWSQ8的内存开销只有HNSW算法的29.5%，两者性能相当；在SIFT-1M数据集上，两者性能相当，构建索引耗时相当，HNSWSQ8的内存占用比HNSW低45%。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]李秋珍,白兴强,李立夏,王赢.量化编码的分层可通航小世界图算法[J].计算机工程与科学,2019,41(04):618-625.<br>[2]Yong Yuan, 图像检索：再叙ANN Search, <a href=\"http://yongyuan.name/blog/ann-search.html\" target=\"_blank\" rel=\"noopener\">http://yongyuan.name/blog/ann-search.html</a>, 2019.7.30.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><h3 id=\"两种改进方法\"><a href=\"#两种改进方法\" class=\"headerlink\" title=\"两种改进方法\"></a>两种改进方法</h3><p>HNSW内存开销大，基于量化编码的检索算法能够压缩数据集向量，大幅度降低内存占用。将量化编码与HNSW结合，有两种改进方法：</p>\n<ol>\n<li>使用标量量化编码向量的HNSWSQ算法</li>\n<li>使用乘积量化编码向量的HNSWPQ算法</li>\n</ol>\n<h3 id=\"HNSW内存开销大的原因\"><a href=\"#HNSW内存开销大的原因\" class=\"headerlink\" title=\"HNSW内存开销大的原因\"></a>HNSW内存开销大的原因</h3><ol>\n<li>需要存储全部的数据集元素</li>\n<li>需要存储每一层中节点之间的连接关系</li>\n</ol>\n<h2 id=\"乘积量化\"><a href=\"#乘积量化\" class=\"headerlink\" title=\"乘积量化\"></a>乘积量化</h2><h3 id=\"PQ乘积量化\"><a href=\"#PQ乘积量化\" class=\"headerlink\" title=\"PQ乘积量化\"></a>PQ乘积量化</h3><h4 id=\"建立码本和量化编码\"><a href=\"#建立码本和量化编码\" class=\"headerlink\" title=\"建立码本和量化编码\"></a>建立码本和量化编码</h4><p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/pq.png\"></p>\n<p>将<code>N * 128</code>的数据集进行切分，划分为4个子空间，每个子空间中向量的维数为32，得到<code>N * 4 * 32</code>。每个字段（子空间）同样有<code>N</code>个向量，对这<code>N</code>个向量进行聚类得到256个类中心，这样4个字段一共有<code>4 * 256</code>个类中心。每个子空间的所有<code>N</code>个向量都可以用该子空间的256个类中心的某一向量表示，对256个类中心进行编码只需8位即可，从而任一向量在该子空间的子向量的编码就可以用该子向量所属的类中心的编码来表示。</p>\n<p>待编码样本如何编码？</p>\n<p>对于待编码的样本，将它进行相同的切分，然后在各个子空间里逐一找到距离它们最近的类中心，然后用类中心的id来表示它们，即完成了待编码样本的编码。</p>\n<h4 id=\"码字的搜索算法\"><a href=\"#码字的搜索算法\" class=\"headerlink\" title=\"码字的搜索算法\"></a>码字的搜索算法</h4><p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/pq2.png\"></p>\n<p>对于某个查询向量，要查询离其最近的k个向量，关键就是计算查询向量与dataset中的样本距离了。暴力方法就是计算数据集中所有的样本与查询向量的距离，然后进行排序，选出top@k个最近的样本返回。对数据集进行PQ乘积量化编码后，这个过程就变成下面的方式：</p>\n<p>将查询向量进行切分，切分方式与对数据集切分的相同，计算查询向量的每个子向量在相应的子空间中到256个类中心的距离，从而得到<code>4 * 256</code>的距离矩阵。某个样本到查询向量的距离就可以通过以下方式得到（不需单独计算了）：</p>\n<p>比如该样本的编码是(124, 56, 132, 222)，在<code>4 * 256</code>的距离矩阵中依次找出（查表）查询向量的相应子向量到编码为124（第一个子空间），编码为56（第二个子空间），编码为132（第三个子空间），编码为222（第四个子空间）的类中心的距离，将这4个距离相加的和作为该样本（编码是(124, 56, 132, 222)）到查询向量的距离。</p>\n<h4 id=\"PQ乘积量化能够加速索引的原理\"><a href=\"#PQ乘积量化能够加速索引的原理\" class=\"headerlink\" title=\"PQ乘积量化能够加速索引的原理\"></a>PQ乘积量化能够加速索引的原理</h4><ul>\n<li>将全样本的距离计算，转化为到子空间类中心的距离计算（加快查询）</li>\n<li>对特征进行编码后，可以用一个相对比较短的编码来表示样本（降低内存消耗）</li>\n<li>存储时只需存储类中心的向量值（计算距离时只需要它们 ）</li>\n</ul>\n<p>注：暴力搜索的距离计算的次数随样本数目<code>N</code>成线性增长，对于上面的例子，PQ乘积量化只需<code>4 * 256</code>次距离计算。</p>\n<h2 id=\"HNSWPQ算法\"><a href=\"#HNSWPQ算法\" class=\"headerlink\" title=\"HNSWPQ算法\"></a>HNSWPQ算法</h2><p>与原始的HNSW算法相比，不再需要在内存中保持原始向量。将HNSW算法作为索引算法，采用PQ算法进行向量编码，由于使用PQ算法对原始向量编码，需要将HNSW算法插入过程中与近邻点距离的计算相应地修改为PQ的距离计算。</p>\n<h3 id=\"HNSWPQ的构建过程\"><a href=\"#HNSWPQ的构建过程\" class=\"headerlink\" title=\"HNSWPQ的构建过程\"></a>HNSWPQ的构建过程</h3><ol>\n<li>对<strong>原始向量</strong>量化编码建立码本存储在内存中</li>\n<li>新插入的结点作为查询结点，得到其能达到的最大层（指数衰减概率分布）</li>\n<li>选邻居时，计算某结点与查询向量的距离应为PQ的距离计算</li>\n</ol>\n<p>与原HNSW算法相比，主要有两方面的不同：</p>\n<ul>\n<li>原HNSW算法直接在原始向量上构建，而HNSWPQ算法需要先对原始向量进行量化编码建立码本在此基础上再逐个插入结点构建（增加了一步）</li>\n<li>原HNSW算法计算距离时是直接计算，而HNSWPQ算法采用PQ距离计算方法（计算速度快）</li>\n</ul>\n<h2 id=\"HNSWSQ算法\"><a href=\"#HNSWSQ算法\" class=\"headerlink\" title=\"HNSWSQ算法\"></a>HNSWSQ算法</h2><p>标量量化（SQ）对向量的每一维都进行量化，HNSWSQ算法采用最大最小量化方法。对于向量的第 $ i $ 维，通过样本集训练获取该维出现的最大值 $ vmax[i] $ 和最小值 $ vmin[i] $ ，然后将向量 $ \\vec{a} $ 第 $ i $ 维的值量化为:</p>\n<script type=\"math/tex; mode=display\">\n\\frac{x_i - vmin[i]} {vmax[i]}</script><p>其中，$ i = 1, …, n $ ，量化后的值编码存储，假设每一维编码为１个字节，则进一步处理为：</p>\n<script type=\"math/tex; mode=display\">\nf(x_i) = \\lfloor \\varphi( \\frac{x_i - vmin[i]} {vmax[i]} ) \\times 255\\rfloor</script><p>其中：</p>\n<script type=\"math/tex; mode=display\">\n \\varphi(x) = \\begin{cases}\n1 & x \\geq 1\\\\\nx & 0 < x < 1\\\\\n0 & x \\leq 0\n\\end{cases}</script><p>HNSWSQ算法在插入结点计算距离时，首先将编码后的向量解码还原，然后计算查询向量与解码向量的距离。</p>\n<p><img src=\"//whenever5225.github.io/2019/08/11/Q-HNSW/SQ量化计算示例.png\"></p>\n<h2 id=\"量化后性能分析\"><a href=\"#量化后性能分析\" class=\"headerlink\" title=\"量化后性能分析\"></a>量化后性能分析</h2><h3 id=\"HNSWPQ算法性能分析\"><a href=\"#HNSWPQ算法性能分析\" class=\"headerlink\" title=\"HNSWPQ算法性能分析\"></a>HNSWPQ算法性能分析</h3><p>与原始的HNSW算法相比，HNSWPQ算法在同样查询时间下Recall@1准确率要低很多，内存占用几乎只有 HNSW算法的一半（主要是结点连接关系），构建索引耗时是HNSW的几倍，主要是编码引起。</p>\n<p>随着PQ子量化器（子空间）的增多，由于量化误差的降低，各算法的Recall@1准确率逐步提高。</p>\n<h3 id=\"HNSWSQ算法性能分析\"><a href=\"#HNSWSQ算法性能分析\" class=\"headerlink\" title=\"HNSWSQ算法性能分析\"></a>HNSWSQ算法性能分析</h3><p>在GIST-1M数据集上HNSWSQ8的内存开销只有HNSW算法的29.5%，两者性能相当；在SIFT-1M数据集上，两者性能相当，构建索引耗时相当，HNSWSQ8的内存占用比HNSW低45%。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]李秋珍,白兴强,李立夏,王赢.量化编码的分层可通航小世界图算法[J].计算机工程与科学,2019,41(04):618-625.<br>[2]Yong Yuan, 图像检索：再叙ANN Search, <a href=\"http://yongyuan.name/blog/ann-search.html\" target=\"_blank\" rel=\"noopener\">http://yongyuan.name/blog/ann-search.html</a>, 2019.7.30.</p>\n</blockquote>\n"},{"title":"基于分层聚类图的大规模近似最近邻搜索（HCNNG）学习笔记","date":"2019-08-17T00:56:30.000Z","mathjax":true,"_content":"\n## 引言\n\n最近看了一篇论文，名为：Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search，总的来说这篇论文的创新点是值得学习的，但是论文对很多细节内容没有描述清楚，这也是我读这篇论文有些失望的地方（自己比较菜，所以细节问题不能详细描述的话，我很难理解的）。\n\n这篇论文主要有两个创新点，分别为构图算法和搜索算法，构图算法采用了一种叫做多重分层聚类方法，具体这种方法有什么优势，作者没有分析；搜索算法采用了一种叫做导向搜索的方法，我们知道，几乎所有的基于图的搜索算法的搜索过程都是采用贪婪搜索，贪婪搜索的每一步要对途径点的所有邻居计算它们到查询点的距离，如果对每一个途径点能少计算一些距离，又能保证搜索结果相同，这必然会提升搜索性能，导向搜索便是如此。\n\n## 构图算法\n\n论文中的图构建过程主要分两步，分别为多重分层聚类过程和各集簇图的融合。\n\n### Hierarchical clustering procedure\n\n**多重分层聚类过程伪代码**\n\n```pseudocode\nFunction HierarchicalClustering(P, n)\n\tData: data points P, min size of clusters n\n\tResult: graph edges E\n\tN ← | P | \n\tE ← φ\n\tif N < n then\n\t\tE ← MST3(P)\n\telse\n\t\tselect randomly p1 and p2 points from P\n\t\tP1 ← { p ∈ P | D (p, p1 ) < D (p, p2 ) }\n\t\tP2 ← { p ∈ P | D (p, p1 ) ≥ D (p, p2 ) }\n\t\tE1 ← Hierarchical Cl ustering(P1 , n )\n\t\tE2 ← Hierarchical Cl ustering(P2 , n )\n\t\tE ← E1 ∪ E2\n\treturn E\n```\n简述：输入数据集点集 $P$ 和集簇的最大尺寸 $n$ ，输出经过分层聚类添加的边 $ E$ （初始化 $E$ 为空）；如果输入数据集的大小 $N < n$ ，则直接在 $P$ 上通过最小生成树的变体连边（最大度为3，即 $MST3$ ）；否则，从 $P$ 中随机选两个点 $p_1$ 和 $p_2$ ，根据到其它点到这两点距离将数据集 $P$ 划分为两簇，对这两簇分别递归地执行分层聚类过程直到每个簇的尺寸都小于 $n$ 。\n\n### Fusion of graphs\n\n**各集簇图的融合的伪代码**\n\n```pseudocode\nFunction CreateHCNNG(P, m, n)\n\tData : data points P , number of random clusterings m , min size of clusters n\n\tResult : graph edges E\n\tE ← φ\n\tfor i ← 1 to m do\n\t\tE i ← HierarchicalClustering(P, n )\n\t\tE ← E ∪ E i\n\treturn E\n```\n\n简述：输入数据集点集 $P$ 、随机聚类数 $m$ 和集簇的最大尺寸 $n$ ，输出经过多次分层聚类添加的边 $ E$ （初始化 $E$ 为空）；对整个数据集重复分层聚类 $m$ 次，$m$ 次分层聚类得到的边都并到一起。\n\n总结分析：在数据集上只分层聚类一次，得到的图肯定是高度不连通的，因此，要执行多重的随机分层聚类过程并连接他们的结果图。\n\n注：本文采用分层聚类过程而没有采用K-means聚类原因是：如果事先不知道数据的分布情况，很难估计簇的初始数量和迭代次数。\n\n## 搜索算法\n\n### 导向搜索 VS 贪婪搜索\n\n<img src=\"directed selection1.png\">\n\n如上图所示，在搜索过程中遍历到的点 $ p$ ，贪婪搜索要计算它的所有邻居到查询点 $q$ 的距离，而导向搜索只需要计算与点 $q$ 处于同一象限的邻居。\n\n<img src=\"guided search2.png\">\n\n上图中传统的贪婪搜索从入口点到查询终止需要计算10次与查询点的距离，而导向搜索只需要计算5次。\n\n### 导向搜索\n\n要实现导向搜索，需要对数据集中的每个点和它的邻居创建树状结构，创建索引的时候为每个结点划分子空间，导向搜索时还要有获取与查询点处于同一象限的邻居的过程。\n\n#### Creation of a tree structure to search in subspaces\n\n**主要思想：**\n\n对于已经建立的图上的某点 $p$ ，它的邻居将以树状的结构存储。在这个树状结构中，除了根结点 $p$ 和叶子结点（所有的叶子结点包含了 $p$ 的所有邻居），其它内部结点只是存储了用来划分空间的维度值（用的哪一维来划分的空间）；对于某个内部结点，它存储了某个维度值，它的两个子树是根据该维度值划分的，怎么划分呢？拿处于这个子空间的所有邻居在该维的值与点 $p$ 在该维的值比较，值小于 $p$ 的邻居被划分到 $neg$ 子树，值不小于 $p$ 的邻居被划分到 $pos$ 子树，然后再分别对这两个子树重复上述过程的划分直到对某个子树（子空间）按某维划分时得到的两个子树其中一个为空为止，此时就不用再建立存储该维的内部结点了，直接将该子树作为叶子就行了。\n\n根据维度划分，但是这个维度怎么选呢？维度选不好的话可能建立的这个子树只是一个线性表了，这样的话建立这个树状结构就没意义了，为此要好好地选，建立的树要尽可能的保证平衡，这就要求每次选维度时要看看它是否能尽可能地等分子空间的邻居。\n\n**划分子空间伪代码**\n\n```pseudocode\nFunction DivideSubspace( p, Np )\n\tData : point of graph p, neighbors points Np\n\tResult : space partition tree T\n\tdim ← select dimension based on Np\n\tneg ← { v ∈ N p | v [ dim ] < p[ dim ] }\n\tpos ← { v ∈ N p | v [ dim ] ≥ p[ dim ] }\n\tif | neg| = 0 or | pos | = 0 then\n\t\tT .points ← Np\n\telse\n\tT .dim ← dim\n\tT .neg ← DivideSubspace (p, neg)\n\tT .pos ← DivideSubspace (p, pos )\nreturn T\n```\n\n随记：为了实现导向搜索，在已经建好的图上对每个结点和它的邻居都建立一个树状结构（相当于附加了一个结构），这将提升搜索性能，但是会增加索引构建时间和内存占用。\n\n#### Identification of neighbors at the same subspace of the query\n\n**主要思想：**\n\n在搜索的过程中，对于遍历到的某点 $p$ ，要获取其与查询点 $q$ 处于同一象限（二维情况，高维类似）的邻居，需要从根节点（点 $p$）开始一直遍历到叶子结点，遍历过程中遇到内部结点时（要确定下一步走哪个子树）将点 $q$ 在该维的值与内部结点的值进行比较以确定下一步走哪个子树，走到叶子结点时，把其中 $p$ 的所有邻居返回（这就是找到的与 $q$ 处于同一象限的邻居）。另外，这个过程消耗的时间微不足道。\n\n**获取特定邻居伪代码**\n\n```pseudocode\nFunction GetNeighbors( q , p, node )\n\tData : query point q , point of graph p, node of space partition tree node\n\tResult : neighbors in query's subspace Nq\n\tNq ← φ\n\tif node is a tree leaf then\n\t\tNq ← node.points\n\telse\n\t\tif q [ node.dim ] < p[ node.dim ] then\n\t\t\tNq ← GetNeighbors (q, p, node.neg)\n\t\telse\n\t\tNq ← GetNeighbors (q, p, node.pos )\n\treturn Nq\n```\n\n## 构建搜索的大致过程\n\n1. 进行一定次数的分层聚类过程来建近邻图（在每个簇中用 $MST3$ 的方法连边，与[Wang2012](https://ieeexplore.ieee.org/document/6247790)类似）\n2. 为建立的近邻图中每个结点和其邻居建立树结构\n3. 创建一定数量的 $KD-Tree$ （内部结点为维数），从这些树中返回的结点中寻找离查询点最近的结点作为入口点\n4. 从入口点执行导向搜索（返回的邻居中找不到离查询更近的，还可转向相邻的叶子结点）\n\n## 参考文献\n\n> [1]Javier Vargas Muñoz,Marcos A. Gonçalves,Zanoni Dias,Ricardo da S. Torres. Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search[J]. Pattern Recognition,2019,96.","source":"_posts/HCNNG.md","raw":"---\ntitle: 基于分层聚类图的大规模近似最近邻搜索（HCNNG）学习笔记\ndate: 2019-08-17 08:56:30\ntags:\n- 论文阅读\n- ANNS\ncategories:\n- 近似最近邻搜索\nmathjax: true\n---\n\n## 引言\n\n最近看了一篇论文，名为：Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search，总的来说这篇论文的创新点是值得学习的，但是论文对很多细节内容没有描述清楚，这也是我读这篇论文有些失望的地方（自己比较菜，所以细节问题不能详细描述的话，我很难理解的）。\n\n这篇论文主要有两个创新点，分别为构图算法和搜索算法，构图算法采用了一种叫做多重分层聚类方法，具体这种方法有什么优势，作者没有分析；搜索算法采用了一种叫做导向搜索的方法，我们知道，几乎所有的基于图的搜索算法的搜索过程都是采用贪婪搜索，贪婪搜索的每一步要对途径点的所有邻居计算它们到查询点的距离，如果对每一个途径点能少计算一些距离，又能保证搜索结果相同，这必然会提升搜索性能，导向搜索便是如此。\n\n## 构图算法\n\n论文中的图构建过程主要分两步，分别为多重分层聚类过程和各集簇图的融合。\n\n### Hierarchical clustering procedure\n\n**多重分层聚类过程伪代码**\n\n```pseudocode\nFunction HierarchicalClustering(P, n)\n\tData: data points P, min size of clusters n\n\tResult: graph edges E\n\tN ← | P | \n\tE ← φ\n\tif N < n then\n\t\tE ← MST3(P)\n\telse\n\t\tselect randomly p1 and p2 points from P\n\t\tP1 ← { p ∈ P | D (p, p1 ) < D (p, p2 ) }\n\t\tP2 ← { p ∈ P | D (p, p1 ) ≥ D (p, p2 ) }\n\t\tE1 ← Hierarchical Cl ustering(P1 , n )\n\t\tE2 ← Hierarchical Cl ustering(P2 , n )\n\t\tE ← E1 ∪ E2\n\treturn E\n```\n简述：输入数据集点集 $P$ 和集簇的最大尺寸 $n$ ，输出经过分层聚类添加的边 $ E$ （初始化 $E$ 为空）；如果输入数据集的大小 $N < n$ ，则直接在 $P$ 上通过最小生成树的变体连边（最大度为3，即 $MST3$ ）；否则，从 $P$ 中随机选两个点 $p_1$ 和 $p_2$ ，根据到其它点到这两点距离将数据集 $P$ 划分为两簇，对这两簇分别递归地执行分层聚类过程直到每个簇的尺寸都小于 $n$ 。\n\n### Fusion of graphs\n\n**各集簇图的融合的伪代码**\n\n```pseudocode\nFunction CreateHCNNG(P, m, n)\n\tData : data points P , number of random clusterings m , min size of clusters n\n\tResult : graph edges E\n\tE ← φ\n\tfor i ← 1 to m do\n\t\tE i ← HierarchicalClustering(P, n )\n\t\tE ← E ∪ E i\n\treturn E\n```\n\n简述：输入数据集点集 $P$ 、随机聚类数 $m$ 和集簇的最大尺寸 $n$ ，输出经过多次分层聚类添加的边 $ E$ （初始化 $E$ 为空）；对整个数据集重复分层聚类 $m$ 次，$m$ 次分层聚类得到的边都并到一起。\n\n总结分析：在数据集上只分层聚类一次，得到的图肯定是高度不连通的，因此，要执行多重的随机分层聚类过程并连接他们的结果图。\n\n注：本文采用分层聚类过程而没有采用K-means聚类原因是：如果事先不知道数据的分布情况，很难估计簇的初始数量和迭代次数。\n\n## 搜索算法\n\n### 导向搜索 VS 贪婪搜索\n\n<img src=\"directed selection1.png\">\n\n如上图所示，在搜索过程中遍历到的点 $ p$ ，贪婪搜索要计算它的所有邻居到查询点 $q$ 的距离，而导向搜索只需要计算与点 $q$ 处于同一象限的邻居。\n\n<img src=\"guided search2.png\">\n\n上图中传统的贪婪搜索从入口点到查询终止需要计算10次与查询点的距离，而导向搜索只需要计算5次。\n\n### 导向搜索\n\n要实现导向搜索，需要对数据集中的每个点和它的邻居创建树状结构，创建索引的时候为每个结点划分子空间，导向搜索时还要有获取与查询点处于同一象限的邻居的过程。\n\n#### Creation of a tree structure to search in subspaces\n\n**主要思想：**\n\n对于已经建立的图上的某点 $p$ ，它的邻居将以树状的结构存储。在这个树状结构中，除了根结点 $p$ 和叶子结点（所有的叶子结点包含了 $p$ 的所有邻居），其它内部结点只是存储了用来划分空间的维度值（用的哪一维来划分的空间）；对于某个内部结点，它存储了某个维度值，它的两个子树是根据该维度值划分的，怎么划分呢？拿处于这个子空间的所有邻居在该维的值与点 $p$ 在该维的值比较，值小于 $p$ 的邻居被划分到 $neg$ 子树，值不小于 $p$ 的邻居被划分到 $pos$ 子树，然后再分别对这两个子树重复上述过程的划分直到对某个子树（子空间）按某维划分时得到的两个子树其中一个为空为止，此时就不用再建立存储该维的内部结点了，直接将该子树作为叶子就行了。\n\n根据维度划分，但是这个维度怎么选呢？维度选不好的话可能建立的这个子树只是一个线性表了，这样的话建立这个树状结构就没意义了，为此要好好地选，建立的树要尽可能的保证平衡，这就要求每次选维度时要看看它是否能尽可能地等分子空间的邻居。\n\n**划分子空间伪代码**\n\n```pseudocode\nFunction DivideSubspace( p, Np )\n\tData : point of graph p, neighbors points Np\n\tResult : space partition tree T\n\tdim ← select dimension based on Np\n\tneg ← { v ∈ N p | v [ dim ] < p[ dim ] }\n\tpos ← { v ∈ N p | v [ dim ] ≥ p[ dim ] }\n\tif | neg| = 0 or | pos | = 0 then\n\t\tT .points ← Np\n\telse\n\tT .dim ← dim\n\tT .neg ← DivideSubspace (p, neg)\n\tT .pos ← DivideSubspace (p, pos )\nreturn T\n```\n\n随记：为了实现导向搜索，在已经建好的图上对每个结点和它的邻居都建立一个树状结构（相当于附加了一个结构），这将提升搜索性能，但是会增加索引构建时间和内存占用。\n\n#### Identification of neighbors at the same subspace of the query\n\n**主要思想：**\n\n在搜索的过程中，对于遍历到的某点 $p$ ，要获取其与查询点 $q$ 处于同一象限（二维情况，高维类似）的邻居，需要从根节点（点 $p$）开始一直遍历到叶子结点，遍历过程中遇到内部结点时（要确定下一步走哪个子树）将点 $q$ 在该维的值与内部结点的值进行比较以确定下一步走哪个子树，走到叶子结点时，把其中 $p$ 的所有邻居返回（这就是找到的与 $q$ 处于同一象限的邻居）。另外，这个过程消耗的时间微不足道。\n\n**获取特定邻居伪代码**\n\n```pseudocode\nFunction GetNeighbors( q , p, node )\n\tData : query point q , point of graph p, node of space partition tree node\n\tResult : neighbors in query's subspace Nq\n\tNq ← φ\n\tif node is a tree leaf then\n\t\tNq ← node.points\n\telse\n\t\tif q [ node.dim ] < p[ node.dim ] then\n\t\t\tNq ← GetNeighbors (q, p, node.neg)\n\t\telse\n\t\tNq ← GetNeighbors (q, p, node.pos )\n\treturn Nq\n```\n\n## 构建搜索的大致过程\n\n1. 进行一定次数的分层聚类过程来建近邻图（在每个簇中用 $MST3$ 的方法连边，与[Wang2012](https://ieeexplore.ieee.org/document/6247790)类似）\n2. 为建立的近邻图中每个结点和其邻居建立树结构\n3. 创建一定数量的 $KD-Tree$ （内部结点为维数），从这些树中返回的结点中寻找离查询点最近的结点作为入口点\n4. 从入口点执行导向搜索（返回的邻居中找不到离查询更近的，还可转向相邻的叶子结点）\n\n## 参考文献\n\n> [1]Javier Vargas Muñoz,Marcos A. Gonçalves,Zanoni Dias,Ricardo da S. Torres. Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search[J]. Pattern Recognition,2019,96.","slug":"HCNNG","published":1,"updated":"2019-08-17T02:09:05.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx81x0002wtfkhp87z45w","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>最近看了一篇论文，名为：Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search，总的来说这篇论文的创新点是值得学习的，但是论文对很多细节内容没有描述清楚，这也是我读这篇论文有些失望的地方（自己比较菜，所以细节问题不能详细描述的话，我很难理解的）。</p>\n<p>这篇论文主要有两个创新点，分别为构图算法和搜索算法，构图算法采用了一种叫做多重分层聚类方法，具体这种方法有什么优势，作者没有分析；搜索算法采用了一种叫做导向搜索的方法，我们知道，几乎所有的基于图的搜索算法的搜索过程都是采用贪婪搜索，贪婪搜索的每一步要对途径点的所有邻居计算它们到查询点的距离，如果对每一个途径点能少计算一些距离，又能保证搜索结果相同，这必然会提升搜索性能，导向搜索便是如此。</p>\n<h2 id=\"构图算法\"><a href=\"#构图算法\" class=\"headerlink\" title=\"构图算法\"></a>构图算法</h2><p>论文中的图构建过程主要分两步，分别为多重分层聚类过程和各集簇图的融合。</p>\n<h3 id=\"Hierarchical-clustering-procedure\"><a href=\"#Hierarchical-clustering-procedure\" class=\"headerlink\" title=\"Hierarchical clustering procedure\"></a>Hierarchical clustering procedure</h3><p><strong>多重分层聚类过程伪代码</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function HierarchicalClustering(P, n)</span><br><span class=\"line\">\tData: data points P, min size of clusters n</span><br><span class=\"line\">\tResult: graph edges E</span><br><span class=\"line\">\tN ← | P | </span><br><span class=\"line\">\tE ← φ</span><br><span class=\"line\">\tif N &lt; n then</span><br><span class=\"line\">\t\tE ← MST3(P)</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tselect randomly p1 and p2 points from P</span><br><span class=\"line\">\t\tP1 ← &#123; p ∈ P | D (p, p1 ) &lt; D (p, p2 ) &#125;</span><br><span class=\"line\">\t\tP2 ← &#123; p ∈ P | D (p, p1 ) ≥ D (p, p2 ) &#125;</span><br><span class=\"line\">\t\tE1 ← Hierarchical Cl ustering(P1 , n )</span><br><span class=\"line\">\t\tE2 ← Hierarchical Cl ustering(P2 , n )</span><br><span class=\"line\">\t\tE ← E1 ∪ E2</span><br><span class=\"line\">\treturn E</span><br></pre></td></tr></table></figure></div>\n<p>简述：输入数据集点集 $P$ 和集簇的最大尺寸 $n$ ，输出经过分层聚类添加的边 $ E$ （初始化 $E$ 为空）；如果输入数据集的大小 $N &lt; n$ ，则直接在 $P$ 上通过最小生成树的变体连边（最大度为3，即 $MST3$ ）；否则，从 $P$ 中随机选两个点 $p_1$ 和 $p_2$ ，根据到其它点到这两点距离将数据集 $P$ 划分为两簇，对这两簇分别递归地执行分层聚类过程直到每个簇的尺寸都小于 $n$ 。</p>\n<h3 id=\"Fusion-of-graphs\"><a href=\"#Fusion-of-graphs\" class=\"headerlink\" title=\"Fusion of graphs\"></a>Fusion of graphs</h3><p><strong>各集簇图的融合的伪代码</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function CreateHCNNG(P, m, n)</span><br><span class=\"line\">\tData : data points P , number of random clusterings m , min size of clusters n</span><br><span class=\"line\">\tResult : graph edges E</span><br><span class=\"line\">\tE ← φ</span><br><span class=\"line\">\tfor i ← 1 to m do</span><br><span class=\"line\">\t\tE i ← HierarchicalClustering(P, n )</span><br><span class=\"line\">\t\tE ← E ∪ E i</span><br><span class=\"line\">\treturn E</span><br></pre></td></tr></table></figure></div>\n<p>简述：输入数据集点集 $P$ 、随机聚类数 $m$ 和集簇的最大尺寸 $n$ ，输出经过多次分层聚类添加的边 $ E$ （初始化 $E$ 为空）；对整个数据集重复分层聚类 $m$ 次，$m$ 次分层聚类得到的边都并到一起。</p>\n<p>总结分析：在数据集上只分层聚类一次，得到的图肯定是高度不连通的，因此，要执行多重的随机分层聚类过程并连接他们的结果图。</p>\n<p>注：本文采用分层聚类过程而没有采用K-means聚类原因是：如果事先不知道数据的分布情况，很难估计簇的初始数量和迭代次数。</p>\n<h2 id=\"搜索算法\"><a href=\"#搜索算法\" class=\"headerlink\" title=\"搜索算法\"></a>搜索算法</h2><h3 id=\"导向搜索-VS-贪婪搜索\"><a href=\"#导向搜索-VS-贪婪搜索\" class=\"headerlink\" title=\"导向搜索 VS 贪婪搜索\"></a>导向搜索 VS 贪婪搜索</h3><p><img src=\"//whenever5225.github.io/2019/08/17/HCNNG/directed selection1.png\"></p>\n<p>如上图所示，在搜索过程中遍历到的点 $ p$ ，贪婪搜索要计算它的所有邻居到查询点 $q$ 的距离，而导向搜索只需要计算与点 $q$ 处于同一象限的邻居。</p>\n<p><img src=\"//whenever5225.github.io/2019/08/17/HCNNG/guided search2.png\"></p>\n<p>上图中传统的贪婪搜索从入口点到查询终止需要计算10次与查询点的距离，而导向搜索只需要计算5次。</p>\n<h3 id=\"导向搜索\"><a href=\"#导向搜索\" class=\"headerlink\" title=\"导向搜索\"></a>导向搜索</h3><p>要实现导向搜索，需要对数据集中的每个点和它的邻居创建树状结构，创建索引的时候为每个结点划分子空间，导向搜索时还要有获取与查询点处于同一象限的邻居的过程。</p>\n<h4 id=\"Creation-of-a-tree-structure-to-search-in-subspaces\"><a href=\"#Creation-of-a-tree-structure-to-search-in-subspaces\" class=\"headerlink\" title=\"Creation of a tree structure to search in subspaces\"></a>Creation of a tree structure to search in subspaces</h4><p><strong>主要思想：</strong></p>\n<p>对于已经建立的图上的某点 $p$ ，它的邻居将以树状的结构存储。在这个树状结构中，除了根结点 $p$ 和叶子结点（所有的叶子结点包含了 $p$ 的所有邻居），其它内部结点只是存储了用来划分空间的维度值（用的哪一维来划分的空间）；对于某个内部结点，它存储了某个维度值，它的两个子树是根据该维度值划分的，怎么划分呢？拿处于这个子空间的所有邻居在该维的值与点 $p$ 在该维的值比较，值小于 $p$ 的邻居被划分到 $neg$ 子树，值不小于 $p$ 的邻居被划分到 $pos$ 子树，然后再分别对这两个子树重复上述过程的划分直到对某个子树（子空间）按某维划分时得到的两个子树其中一个为空为止，此时就不用再建立存储该维的内部结点了，直接将该子树作为叶子就行了。</p>\n<p>根据维度划分，但是这个维度怎么选呢？维度选不好的话可能建立的这个子树只是一个线性表了，这样的话建立这个树状结构就没意义了，为此要好好地选，建立的树要尽可能的保证平衡，这就要求每次选维度时要看看它是否能尽可能地等分子空间的邻居。</p>\n<p><strong>划分子空间伪代码</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function DivideSubspace( p, Np )</span><br><span class=\"line\">\tData : point of graph p, neighbors points Np</span><br><span class=\"line\">\tResult : space partition tree T</span><br><span class=\"line\">\tdim ← select dimension based on Np</span><br><span class=\"line\">\tneg ← &#123; v ∈ N p | v [ dim ] &lt; p[ dim ] &#125;</span><br><span class=\"line\">\tpos ← &#123; v ∈ N p | v [ dim ] ≥ p[ dim ] &#125;</span><br><span class=\"line\">\tif | neg| = 0 or | pos | = 0 then</span><br><span class=\"line\">\t\tT .points ← Np</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\tT .dim ← dim</span><br><span class=\"line\">\tT .neg ← DivideSubspace (p, neg)</span><br><span class=\"line\">\tT .pos ← DivideSubspace (p, pos )</span><br><span class=\"line\">return T</span><br></pre></td></tr></table></figure></div>\n<p>随记：为了实现导向搜索，在已经建好的图上对每个结点和它的邻居都建立一个树状结构（相当于附加了一个结构），这将提升搜索性能，但是会增加索引构建时间和内存占用。</p>\n<h4 id=\"Identification-of-neighbors-at-the-same-subspace-of-the-query\"><a href=\"#Identification-of-neighbors-at-the-same-subspace-of-the-query\" class=\"headerlink\" title=\"Identification of neighbors at the same subspace of the query\"></a>Identification of neighbors at the same subspace of the query</h4><p><strong>主要思想：</strong></p>\n<p>在搜索的过程中，对于遍历到的某点 $p$ ，要获取其与查询点 $q$ 处于同一象限（二维情况，高维类似）的邻居，需要从根节点（点 $p$）开始一直遍历到叶子结点，遍历过程中遇到内部结点时（要确定下一步走哪个子树）将点 $q$ 在该维的值与内部结点的值进行比较以确定下一步走哪个子树，走到叶子结点时，把其中 $p$ 的所有邻居返回（这就是找到的与 $q$ 处于同一象限的邻居）。另外，这个过程消耗的时间微不足道。</p>\n<p><strong>获取特定邻居伪代码</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function GetNeighbors( q , p, node )</span><br><span class=\"line\">\tData : query point q , point of graph p, node of space partition tree node</span><br><span class=\"line\">\tResult : neighbors in query&apos;s subspace Nq</span><br><span class=\"line\">\tNq ← φ</span><br><span class=\"line\">\tif node is a tree leaf then</span><br><span class=\"line\">\t\tNq ← node.points</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tif q [ node.dim ] &lt; p[ node.dim ] then</span><br><span class=\"line\">\t\t\tNq ← GetNeighbors (q, p, node.neg)</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\tNq ← GetNeighbors (q, p, node.pos )</span><br><span class=\"line\">\treturn Nq</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"构建搜索的大致过程\"><a href=\"#构建搜索的大致过程\" class=\"headerlink\" title=\"构建搜索的大致过程\"></a>构建搜索的大致过程</h2><ol>\n<li>进行一定次数的分层聚类过程来建近邻图（在每个簇中用 $MST3$ 的方法连边，与<a href=\"https://ieeexplore.ieee.org/document/6247790\" target=\"_blank\" rel=\"noopener\">Wang2012</a>类似）</li>\n<li>为建立的近邻图中每个结点和其邻居建立树结构</li>\n<li>创建一定数量的 $KD-Tree$ （内部结点为维数），从这些树中返回的结点中寻找离查询点最近的结点作为入口点</li>\n<li>从入口点执行导向搜索（返回的邻居中找不到离查询更近的，还可转向相邻的叶子结点）</li>\n</ol>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]Javier Vargas Muñoz,Marcos A. Gonçalves,Zanoni Dias,Ricardo da S. Torres. Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search[J]. Pattern Recognition,2019,96.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>最近看了一篇论文，名为：Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search，总的来说这篇论文的创新点是值得学习的，但是论文对很多细节内容没有描述清楚，这也是我读这篇论文有些失望的地方（自己比较菜，所以细节问题不能详细描述的话，我很难理解的）。</p>\n<p>这篇论文主要有两个创新点，分别为构图算法和搜索算法，构图算法采用了一种叫做多重分层聚类方法，具体这种方法有什么优势，作者没有分析；搜索算法采用了一种叫做导向搜索的方法，我们知道，几乎所有的基于图的搜索算法的搜索过程都是采用贪婪搜索，贪婪搜索的每一步要对途径点的所有邻居计算它们到查询点的距离，如果对每一个途径点能少计算一些距离，又能保证搜索结果相同，这必然会提升搜索性能，导向搜索便是如此。</p>\n<h2 id=\"构图算法\"><a href=\"#构图算法\" class=\"headerlink\" title=\"构图算法\"></a>构图算法</h2><p>论文中的图构建过程主要分两步，分别为多重分层聚类过程和各集簇图的融合。</p>\n<h3 id=\"Hierarchical-clustering-procedure\"><a href=\"#Hierarchical-clustering-procedure\" class=\"headerlink\" title=\"Hierarchical clustering procedure\"></a>Hierarchical clustering procedure</h3><p><strong>多重分层聚类过程伪代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function HierarchicalClustering(P, n)</span><br><span class=\"line\">\tData: data points P, min size of clusters n</span><br><span class=\"line\">\tResult: graph edges E</span><br><span class=\"line\">\tN ← | P | </span><br><span class=\"line\">\tE ← φ</span><br><span class=\"line\">\tif N &lt; n then</span><br><span class=\"line\">\t\tE ← MST3(P)</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tselect randomly p1 and p2 points from P</span><br><span class=\"line\">\t\tP1 ← &#123; p ∈ P | D (p, p1 ) &lt; D (p, p2 ) &#125;</span><br><span class=\"line\">\t\tP2 ← &#123; p ∈ P | D (p, p1 ) ≥ D (p, p2 ) &#125;</span><br><span class=\"line\">\t\tE1 ← Hierarchical Cl ustering(P1 , n )</span><br><span class=\"line\">\t\tE2 ← Hierarchical Cl ustering(P2 , n )</span><br><span class=\"line\">\t\tE ← E1 ∪ E2</span><br><span class=\"line\">\treturn E</span><br></pre></td></tr></table></figure>\n<p>简述：输入数据集点集 $P$ 和集簇的最大尺寸 $n$ ，输出经过分层聚类添加的边 $ E$ （初始化 $E$ 为空）；如果输入数据集的大小 $N &lt; n$ ，则直接在 $P$ 上通过最小生成树的变体连边（最大度为3，即 $MST3$ ）；否则，从 $P$ 中随机选两个点 $p_1$ 和 $p_2$ ，根据到其它点到这两点距离将数据集 $P$ 划分为两簇，对这两簇分别递归地执行分层聚类过程直到每个簇的尺寸都小于 $n$ 。</p>\n<h3 id=\"Fusion-of-graphs\"><a href=\"#Fusion-of-graphs\" class=\"headerlink\" title=\"Fusion of graphs\"></a>Fusion of graphs</h3><p><strong>各集簇图的融合的伪代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function CreateHCNNG(P, m, n)</span><br><span class=\"line\">\tData : data points P , number of random clusterings m , min size of clusters n</span><br><span class=\"line\">\tResult : graph edges E</span><br><span class=\"line\">\tE ← φ</span><br><span class=\"line\">\tfor i ← 1 to m do</span><br><span class=\"line\">\t\tE i ← HierarchicalClustering(P, n )</span><br><span class=\"line\">\t\tE ← E ∪ E i</span><br><span class=\"line\">\treturn E</span><br></pre></td></tr></table></figure>\n<p>简述：输入数据集点集 $P$ 、随机聚类数 $m$ 和集簇的最大尺寸 $n$ ，输出经过多次分层聚类添加的边 $ E$ （初始化 $E$ 为空）；对整个数据集重复分层聚类 $m$ 次，$m$ 次分层聚类得到的边都并到一起。</p>\n<p>总结分析：在数据集上只分层聚类一次，得到的图肯定是高度不连通的，因此，要执行多重的随机分层聚类过程并连接他们的结果图。</p>\n<p>注：本文采用分层聚类过程而没有采用K-means聚类原因是：如果事先不知道数据的分布情况，很难估计簇的初始数量和迭代次数。</p>\n<h2 id=\"搜索算法\"><a href=\"#搜索算法\" class=\"headerlink\" title=\"搜索算法\"></a>搜索算法</h2><h3 id=\"导向搜索-VS-贪婪搜索\"><a href=\"#导向搜索-VS-贪婪搜索\" class=\"headerlink\" title=\"导向搜索 VS 贪婪搜索\"></a>导向搜索 VS 贪婪搜索</h3><p><img src=\"//whenever5225.github.io/2019/08/17/HCNNG/directed selection1.png\"></p>\n<p>如上图所示，在搜索过程中遍历到的点 $ p$ ，贪婪搜索要计算它的所有邻居到查询点 $q$ 的距离，而导向搜索只需要计算与点 $q$ 处于同一象限的邻居。</p>\n<p><img src=\"//whenever5225.github.io/2019/08/17/HCNNG/guided search2.png\"></p>\n<p>上图中传统的贪婪搜索从入口点到查询终止需要计算10次与查询点的距离，而导向搜索只需要计算5次。</p>\n<h3 id=\"导向搜索\"><a href=\"#导向搜索\" class=\"headerlink\" title=\"导向搜索\"></a>导向搜索</h3><p>要实现导向搜索，需要对数据集中的每个点和它的邻居创建树状结构，创建索引的时候为每个结点划分子空间，导向搜索时还要有获取与查询点处于同一象限的邻居的过程。</p>\n<h4 id=\"Creation-of-a-tree-structure-to-search-in-subspaces\"><a href=\"#Creation-of-a-tree-structure-to-search-in-subspaces\" class=\"headerlink\" title=\"Creation of a tree structure to search in subspaces\"></a>Creation of a tree structure to search in subspaces</h4><p><strong>主要思想：</strong></p>\n<p>对于已经建立的图上的某点 $p$ ，它的邻居将以树状的结构存储。在这个树状结构中，除了根结点 $p$ 和叶子结点（所有的叶子结点包含了 $p$ 的所有邻居），其它内部结点只是存储了用来划分空间的维度值（用的哪一维来划分的空间）；对于某个内部结点，它存储了某个维度值，它的两个子树是根据该维度值划分的，怎么划分呢？拿处于这个子空间的所有邻居在该维的值与点 $p$ 在该维的值比较，值小于 $p$ 的邻居被划分到 $neg$ 子树，值不小于 $p$ 的邻居被划分到 $pos$ 子树，然后再分别对这两个子树重复上述过程的划分直到对某个子树（子空间）按某维划分时得到的两个子树其中一个为空为止，此时就不用再建立存储该维的内部结点了，直接将该子树作为叶子就行了。</p>\n<p>根据维度划分，但是这个维度怎么选呢？维度选不好的话可能建立的这个子树只是一个线性表了，这样的话建立这个树状结构就没意义了，为此要好好地选，建立的树要尽可能的保证平衡，这就要求每次选维度时要看看它是否能尽可能地等分子空间的邻居。</p>\n<p><strong>划分子空间伪代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function DivideSubspace( p, Np )</span><br><span class=\"line\">\tData : point of graph p, neighbors points Np</span><br><span class=\"line\">\tResult : space partition tree T</span><br><span class=\"line\">\tdim ← select dimension based on Np</span><br><span class=\"line\">\tneg ← &#123; v ∈ N p | v [ dim ] &lt; p[ dim ] &#125;</span><br><span class=\"line\">\tpos ← &#123; v ∈ N p | v [ dim ] ≥ p[ dim ] &#125;</span><br><span class=\"line\">\tif | neg| = 0 or | pos | = 0 then</span><br><span class=\"line\">\t\tT .points ← Np</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\tT .dim ← dim</span><br><span class=\"line\">\tT .neg ← DivideSubspace (p, neg)</span><br><span class=\"line\">\tT .pos ← DivideSubspace (p, pos )</span><br><span class=\"line\">return T</span><br></pre></td></tr></table></figure>\n<p>随记：为了实现导向搜索，在已经建好的图上对每个结点和它的邻居都建立一个树状结构（相当于附加了一个结构），这将提升搜索性能，但是会增加索引构建时间和内存占用。</p>\n<h4 id=\"Identification-of-neighbors-at-the-same-subspace-of-the-query\"><a href=\"#Identification-of-neighbors-at-the-same-subspace-of-the-query\" class=\"headerlink\" title=\"Identification of neighbors at the same subspace of the query\"></a>Identification of neighbors at the same subspace of the query</h4><p><strong>主要思想：</strong></p>\n<p>在搜索的过程中，对于遍历到的某点 $p$ ，要获取其与查询点 $q$ 处于同一象限（二维情况，高维类似）的邻居，需要从根节点（点 $p$）开始一直遍历到叶子结点，遍历过程中遇到内部结点时（要确定下一步走哪个子树）将点 $q$ 在该维的值与内部结点的值进行比较以确定下一步走哪个子树，走到叶子结点时，把其中 $p$ 的所有邻居返回（这就是找到的与 $q$ 处于同一象限的邻居）。另外，这个过程消耗的时间微不足道。</p>\n<p><strong>获取特定邻居伪代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function GetNeighbors( q , p, node )</span><br><span class=\"line\">\tData : query point q , point of graph p, node of space partition tree node</span><br><span class=\"line\">\tResult : neighbors in query&apos;s subspace Nq</span><br><span class=\"line\">\tNq ← φ</span><br><span class=\"line\">\tif node is a tree leaf then</span><br><span class=\"line\">\t\tNq ← node.points</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tif q [ node.dim ] &lt; p[ node.dim ] then</span><br><span class=\"line\">\t\t\tNq ← GetNeighbors (q, p, node.neg)</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\tNq ← GetNeighbors (q, p, node.pos )</span><br><span class=\"line\">\treturn Nq</span><br></pre></td></tr></table></figure>\n<h2 id=\"构建搜索的大致过程\"><a href=\"#构建搜索的大致过程\" class=\"headerlink\" title=\"构建搜索的大致过程\"></a>构建搜索的大致过程</h2><ol>\n<li>进行一定次数的分层聚类过程来建近邻图（在每个簇中用 $MST3$ 的方法连边，与<a href=\"https://ieeexplore.ieee.org/document/6247790\" target=\"_blank\" rel=\"noopener\">Wang2012</a>类似）</li>\n<li>为建立的近邻图中每个结点和其邻居建立树结构</li>\n<li>创建一定数量的 $KD-Tree$ （内部结点为维数），从这些树中返回的结点中寻找离查询点最近的结点作为入口点</li>\n<li>从入口点执行导向搜索（返回的邻居中找不到离查询更近的，还可转向相邻的叶子结点）</li>\n</ol>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]Javier Vargas Muñoz,Marcos A. Gonçalves,Zanoni Dias,Ricardo da S. Torres. Hierarchical Clustering-Based Graphs for Large Scale Approximate Nearest Neighbor Search[J]. Pattern Recognition,2019,96.</p>\n</blockquote>\n"},{"title":"C++读取ivecs格式数据","date":"2019-08-12T13:54:50.000Z","_content":"\n## 引言\n\n近似最近邻搜索中通常会涉及到`fvecs`和`ivecs`格式的数据，其中，原始数据一般为`fvecs`格式的数据，查询结果一般为`ivecs`格式的。`ivecs`内部存储的主要是数据的`id`，数据类型为`unsigned`类型。就其内部数据结构而言，行数为查询点的个数，列数为对每个查询点查询返回个数再加1，因为每行的第一个位置存储的是对每个查询点查询返回个数。\n\n可以通过程序来读取`ivecs`格式数据的内容，下面是用`c++`程序读取`ivecs`格式数据内容并输出其查询数据个数和对每个查询点查询返回个数。\n\n## C++读取`ivecs`格式数据\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nvoid load_ivecs_data(const char* filename,\n                 std::vector<std::vector<unsigned> >& results, unsigned &num, unsigned &dim) {\n  std::ifstream in(filename, std::ios::binary);\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\n  //std::cout<<\"data dimension: \"<<dim<<std::endl;\n  in.seekg(0, std::ios::end);\n  std::ios::pos_type ss = in.tellg();\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\n  results.resize(num);\n  for (unsigned i = 0; i < num; i++) results[i].resize(dim);\n\n  in.seekg(0, std::ios::beg);\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\n    in.read((char*)results[i].data(), dim * 4);\n  }\n  in.close();\n}\n\nint main(int argc, char** argv) {\n  std::vector<std::vector<unsigned> > true_load;\n  unsigned dim, num;\n  load_ivecs_data(argv[1], true_load, num, dim);\n  for(size_t i = 0; i < num; i++) {\n    for(size_t j = 0; j < dim; j++) {\n      std::cout << true_load[i][j] << \" \";\n    }\n    std::cout << std::endl;\n  }\n  std::cout << \"result_num：\"<< num << std::endl << \"result dimension：\" << dim << std::endl;\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","source":"_posts/anns-nsg-code1.md","raw":"---\ntitle: C++读取ivecs格式数据\ndate: 2019-08-12 21:54:50\ntags:\n- C/C++\n- ANNS\n- 源码阅读\ncategories:\n- 近似最近邻搜索\n---\n\n## 引言\n\n近似最近邻搜索中通常会涉及到`fvecs`和`ivecs`格式的数据，其中，原始数据一般为`fvecs`格式的数据，查询结果一般为`ivecs`格式的。`ivecs`内部存储的主要是数据的`id`，数据类型为`unsigned`类型。就其内部数据结构而言，行数为查询点的个数，列数为对每个查询点查询返回个数再加1，因为每行的第一个位置存储的是对每个查询点查询返回个数。\n\n可以通过程序来读取`ivecs`格式数据的内容，下面是用`c++`程序读取`ivecs`格式数据内容并输出其查询数据个数和对每个查询点查询返回个数。\n\n## C++读取`ivecs`格式数据\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nvoid load_ivecs_data(const char* filename,\n                 std::vector<std::vector<unsigned> >& results, unsigned &num, unsigned &dim) {\n  std::ifstream in(filename, std::ios::binary);\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\n  //std::cout<<\"data dimension: \"<<dim<<std::endl;\n  in.seekg(0, std::ios::end);\n  std::ios::pos_type ss = in.tellg();\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\n  results.resize(num);\n  for (unsigned i = 0; i < num; i++) results[i].resize(dim);\n\n  in.seekg(0, std::ios::beg);\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\n    in.read((char*)results[i].data(), dim * 4);\n  }\n  in.close();\n}\n\nint main(int argc, char** argv) {\n  std::vector<std::vector<unsigned> > true_load;\n  unsigned dim, num;\n  load_ivecs_data(argv[1], true_load, num, dim);\n  for(size_t i = 0; i < num; i++) {\n    for(size_t j = 0; j < dim; j++) {\n      std::cout << true_load[i][j] << \" \";\n    }\n    std::cout << std::endl;\n  }\n  std::cout << \"result_num：\"<< num << std::endl << \"result dimension：\" << dim << std::endl;\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","slug":"anns-nsg-code1","published":1,"updated":"2019-08-16T13:48:37.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx8200006wtfkrn402he2","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>近似最近邻搜索中通常会涉及到<code>fvecs</code>和<code>ivecs</code>格式的数据，其中，原始数据一般为<code>fvecs</code>格式的数据，查询结果一般为<code>ivecs</code>格式的。<code>ivecs</code>内部存储的主要是数据的<code>id</code>，数据类型为<code>unsigned</code>类型。就其内部数据结构而言，行数为查询点的个数，列数为对每个查询点查询返回个数再加1，因为每行的第一个位置存储的是对每个查询点查询返回个数。</p>\n<p>可以通过程序来读取<code>ivecs</code>格式数据的内容，下面是用<code>c++</code>程序读取<code>ivecs</code>格式数据内容并输出其查询数据个数和对每个查询点查询返回个数。</p>\n<h2 id=\"C-读取ivecs格式数据\"><a href=\"#C-读取ivecs格式数据\" class=\"headerlink\" title=\"C++读取ivecs格式数据\"></a>C++读取<code>ivecs</code>格式数据</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_ivecs_data</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filename,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt;&amp; results, <span class=\"keyword\">unsigned</span> &amp;num, <span class=\"keyword\">unsigned</span> &amp;dim)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"comment\">//std::cout&lt;&lt;\"data dimension: \"&lt;&lt;dim&lt;&lt;std::endl;</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);</span><br><span class=\"line\">  results.resize(num);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>; i &lt; num; i++) results[i].resize(dim);</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);</span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)results[i].data(), dim * <span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_load;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> dim, num;</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">1</span>], true_load, num, dim);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; dim; j++) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; true_load[i][j] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"result_num：\"</span>&lt;&lt; num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"result dimension：\"</span> &lt;&lt; dim &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>近似最近邻搜索中通常会涉及到<code>fvecs</code>和<code>ivecs</code>格式的数据，其中，原始数据一般为<code>fvecs</code>格式的数据，查询结果一般为<code>ivecs</code>格式的。<code>ivecs</code>内部存储的主要是数据的<code>id</code>，数据类型为<code>unsigned</code>类型。就其内部数据结构而言，行数为查询点的个数，列数为对每个查询点查询返回个数再加1，因为每行的第一个位置存储的是对每个查询点查询返回个数。</p>\n<p>可以通过程序来读取<code>ivecs</code>格式数据的内容，下面是用<code>c++</code>程序读取<code>ivecs</code>格式数据内容并输出其查询数据个数和对每个查询点查询返回个数。</p>\n<h2 id=\"C-读取ivecs格式数据\"><a href=\"#C-读取ivecs格式数据\" class=\"headerlink\" title=\"C++读取ivecs格式数据\"></a>C++读取<code>ivecs</code>格式数据</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_ivecs_data</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filename,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt;&amp; results, <span class=\"keyword\">unsigned</span> &amp;num, <span class=\"keyword\">unsigned</span> &amp;dim)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"comment\">//std::cout&lt;&lt;\"data dimension: \"&lt;&lt;dim&lt;&lt;std::endl;</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);</span><br><span class=\"line\">  results.resize(num);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>; i &lt; num; i++) results[i].resize(dim);</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);</span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)results[i].data(), dim * <span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_load;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> dim, num;</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">1</span>], true_load, num, dim);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; dim; j++) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; true_load[i][j] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"result_num：\"</span>&lt;&lt; num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"result dimension：\"</span> &lt;&lt; dim &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n"},{"title":"C++读取fvecs格式数据（SIFT1M数据集的结构）","date":"2019-08-12T14:00:18.000Z","mathjax":true,"_content":"\n## 引言\n\nsift1M是一个近似最近邻搜索（ANNS）的数据集，它可用于评估ANNS的性能。它包含3个向量子集，分别为：\n\n* 基矢量：执行搜索的矢量\n* 查询向量 \n* 学习向量：查找特定方法中涉及的参数\n\n此外，它以预先计算的k个最近邻居及其平方欧式距离的形式为每个集合提供真值。\n每个向量取 $ 4+d\\times 4B$ ，其中 $ d$ 是维数，$B$ 是字节，具体如下：\n\n| 域值 | 域值类型 | 描述     |\n| ---- | :------: | -------- |\n| d    |   int    | 向量维度 |\n| d*4B |  float   | 向量分量 |\n\n## C++读取`.fvecs`格式数据\n\n```cpp\n#include <iostream>\n#include <fstream>\n\nvoid load_data(char* filename, float*& data, unsigned& num, unsigned& dim) { \n  std::ifstream in(filename, std::ios::binary);\t//以二进制的方式打开文件\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\t//读取向量维度\n  in.seekg(0, std::ios::end);\t//光标定位到文件末尾\n  std::ios::pos_type ss = in.tellg();\t//获取文件大小（多少字节）\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\t//数据的个数\n  data = new float[(size_t)num * (size_t)dim];\n\n  in.seekg(0, std::ios::beg);\t//光标定位到起始处\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\t//光标向右移动4个字节\n    in.read((char*)(data + i * dim), dim * 4);\t//读取数据到一维数据data中\n  }\n  for(size_t i = 0; i < num * dim; i++) {\t//输出数据\n    std::cout << (float)data[i];\n    if(!i) {\n        std::cout << \" \";\n        continue;\n    }\n    if(i % (dim - 1) != 0) {\n      std::cout << \" \";\n    }\n    else{\n      std::cout << std::endl;\n    }\n  }\n  in.close();\n}\n\nint main(int argc, char** argv) {\n  float* data_load = NULL;\n  unsigned points_num, dim;\n  load_data(argv[1], data_load, points_num, dim);\n  std::cout << \"points_num：\"<< points_num << std::endl << \"data dimension：\" << dim << std::endl;\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","source":"_posts/anns-nsg-code2.md","raw":"---\ntitle: C++读取fvecs格式数据（SIFT1M数据集的结构）\ndate: 2019-08-12 22:00:18\ntags:\n- C/C++\n- ANNS\n- 源码阅读\ncategories:\n- 近似最近邻搜索\nmathjax: true\n---\n\n## 引言\n\nsift1M是一个近似最近邻搜索（ANNS）的数据集，它可用于评估ANNS的性能。它包含3个向量子集，分别为：\n\n* 基矢量：执行搜索的矢量\n* 查询向量 \n* 学习向量：查找特定方法中涉及的参数\n\n此外，它以预先计算的k个最近邻居及其平方欧式距离的形式为每个集合提供真值。\n每个向量取 $ 4+d\\times 4B$ ，其中 $ d$ 是维数，$B$ 是字节，具体如下：\n\n| 域值 | 域值类型 | 描述     |\n| ---- | :------: | -------- |\n| d    |   int    | 向量维度 |\n| d*4B |  float   | 向量分量 |\n\n## C++读取`.fvecs`格式数据\n\n```cpp\n#include <iostream>\n#include <fstream>\n\nvoid load_data(char* filename, float*& data, unsigned& num, unsigned& dim) { \n  std::ifstream in(filename, std::ios::binary);\t//以二进制的方式打开文件\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\t//读取向量维度\n  in.seekg(0, std::ios::end);\t//光标定位到文件末尾\n  std::ios::pos_type ss = in.tellg();\t//获取文件大小（多少字节）\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\t//数据的个数\n  data = new float[(size_t)num * (size_t)dim];\n\n  in.seekg(0, std::ios::beg);\t//光标定位到起始处\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\t//光标向右移动4个字节\n    in.read((char*)(data + i * dim), dim * 4);\t//读取数据到一维数据data中\n  }\n  for(size_t i = 0; i < num * dim; i++) {\t//输出数据\n    std::cout << (float)data[i];\n    if(!i) {\n        std::cout << \" \";\n        continue;\n    }\n    if(i % (dim - 1) != 0) {\n      std::cout << \" \";\n    }\n    else{\n      std::cout << std::endl;\n    }\n  }\n  in.close();\n}\n\nint main(int argc, char** argv) {\n  float* data_load = NULL;\n  unsigned points_num, dim;\n  load_data(argv[1], data_load, points_num, dim);\n  std::cout << \"points_num：\"<< points_num << std::endl << \"data dimension：\" << dim << std::endl;\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","slug":"anns-nsg-code2","published":1,"updated":"2019-08-16T13:48:37.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx8210007wtfk18ref2kn","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>sift1M是一个近似最近邻搜索（ANNS）的数据集，它可用于评估ANNS的性能。它包含3个向量子集，分别为：</p>\n<ul>\n<li>基矢量：执行搜索的矢量</li>\n<li>查询向量 </li>\n<li>学习向量：查找特定方法中涉及的参数</li>\n</ul>\n<p>此外，它以预先计算的k个最近邻居及其平方欧式距离的形式为每个集合提供真值。<br>每个向量取 $ 4+d\\times 4B$ ，其中 $ d$ 是维数，$B$ 是字节，具体如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>域值</th>\n<th style=\"text-align:center\">域值类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>d</td>\n<td style=\"text-align:center\">int</td>\n<td>向量维度</td>\n</tr>\n<tr>\n<td>d*4B</td>\n<td style=\"text-align:center\">float</td>\n<td>向量分量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"C-读取-fvecs格式数据\"><a href=\"#C-读取-fvecs格式数据\" class=\"headerlink\" title=\"C++读取.fvecs格式数据\"></a>C++读取<code>.fvecs</code>格式数据</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_data</span><span class=\"params\">(<span class=\"keyword\">char</span>* filename, <span class=\"keyword\">float</span>*&amp; data, <span class=\"keyword\">unsigned</span>&amp; num, <span class=\"keyword\">unsigned</span>&amp; dim)</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;\t<span class=\"comment\">//以二进制的方式打开文件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);\t<span class=\"comment\">//读取向量维度</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);\t<span class=\"comment\">//光标定位到文件末尾</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();\t<span class=\"comment\">//获取文件大小（多少字节）</span></span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);\t<span class=\"comment\">//数据的个数</span></span><br><span class=\"line\">  data = <span class=\"keyword\">new</span> <span class=\"keyword\">float</span>[(<span class=\"keyword\">size_t</span>)num * (<span class=\"keyword\">size_t</span>)dim];</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);\t<span class=\"comment\">//光标定位到起始处</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);\t<span class=\"comment\">//光标向右移动4个字节</span></span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)(data + i * dim), dim * <span class=\"number\">4</span>);\t<span class=\"comment\">//读取数据到一维数据data中</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num * dim; i++) &#123;\t<span class=\"comment\">//输出数据</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; (<span class=\"keyword\">float</span>)data[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i % (dim - <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">float</span>* data_load = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> points_num, dim;</span><br><span class=\"line\">  load_data(argv[<span class=\"number\">1</span>], data_load, points_num, dim);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"points_num：\"</span>&lt;&lt; points_num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"data dimension：\"</span> &lt;&lt; dim &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>sift1M是一个近似最近邻搜索（ANNS）的数据集，它可用于评估ANNS的性能。它包含3个向量子集，分别为：</p>\n<ul>\n<li>基矢量：执行搜索的矢量</li>\n<li>查询向量 </li>\n<li>学习向量：查找特定方法中涉及的参数</li>\n</ul>\n<p>此外，它以预先计算的k个最近邻居及其平方欧式距离的形式为每个集合提供真值。<br>每个向量取 $ 4+d\\times 4B$ ，其中 $ d$ 是维数，$B$ 是字节，具体如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>域值</th>\n<th style=\"text-align:center\">域值类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>d</td>\n<td style=\"text-align:center\">int</td>\n<td>向量维度</td>\n</tr>\n<tr>\n<td>d*4B</td>\n<td style=\"text-align:center\">float</td>\n<td>向量分量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"C-读取-fvecs格式数据\"><a href=\"#C-读取-fvecs格式数据\" class=\"headerlink\" title=\"C++读取.fvecs格式数据\"></a>C++读取<code>.fvecs</code>格式数据</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_data</span><span class=\"params\">(<span class=\"keyword\">char</span>* filename, <span class=\"keyword\">float</span>*&amp; data, <span class=\"keyword\">unsigned</span>&amp; num, <span class=\"keyword\">unsigned</span>&amp; dim)</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;\t<span class=\"comment\">//以二进制的方式打开文件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);\t<span class=\"comment\">//读取向量维度</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);\t<span class=\"comment\">//光标定位到文件末尾</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();\t<span class=\"comment\">//获取文件大小（多少字节）</span></span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);\t<span class=\"comment\">//数据的个数</span></span><br><span class=\"line\">  data = <span class=\"keyword\">new</span> <span class=\"keyword\">float</span>[(<span class=\"keyword\">size_t</span>)num * (<span class=\"keyword\">size_t</span>)dim];</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);\t<span class=\"comment\">//光标定位到起始处</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);\t<span class=\"comment\">//光标向右移动4个字节</span></span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)(data + i * dim), dim * <span class=\"number\">4</span>);\t<span class=\"comment\">//读取数据到一维数据data中</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num * dim; i++) &#123;\t<span class=\"comment\">//输出数据</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; (<span class=\"keyword\">float</span>)data[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i % (dim - <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">float</span>* data_load = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> points_num, dim;</span><br><span class=\"line\">  load_data(argv[<span class=\"number\">1</span>], data_load, points_num, dim);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"points_num：\"</span>&lt;&lt; points_num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"data dimension：\"</span> &lt;&lt; dim &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n"},{"title":"C++计算召回率","date":"2019-08-12T14:00:22.000Z","mathjax":true,"_content":"\n## 引言\n\n近似最近邻搜索中评估算法的搜索性能经常用到召回率，召回率的计算公式一般为：\n$$\nRecall@K = \\frac{R_1 \\bigcap R_2}{K}\n$$\n其中，$R_1$ 为搜索算法返回的 $K$ 个元素组成的集合，$R_2$ 为查询点真实的 $K$ 个近邻点，$Recall@K$ 为返回 $K$ 个近邻点时的召回率。\n\n## C++代码实现召回率的计算\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nvoid load_ivecs_data(const char* filename,\t//从文件中读取ivecs格式的数据\n                 std::vector<std::vector<unsigned> >& results, unsigned &num, unsigned &dim) {\n  std::ifstream in(filename, std::ios::binary);\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\n  //std::cout<<\"data dimension: \"<<dim<<std::endl;\n  in.seekg(0, std::ios::end);\n  std::ios::pos_type ss = in.tellg();\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\n  results.resize(num);\n  for (unsigned i = 0; i < num; i++) results[i].resize(dim);\n\n  in.seekg(0, std::ios::beg);\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\n    in.read((char*)results[i].data(), dim * 4);\n  }\n  in.close();\n}\n\nvoid cal_recall(std::vector<std::vector<unsigned> > results, std::vector<std::vector<unsigned> > true_data, unsigned num, unsigned k) {//召回率计算\n  float mean_acc = 0;\n  for(size_t i = 0; i < num; i++) {\n    float acc = 0;\n    for(size_t j = 0; j < k; j++) {\n      for(size_t m = 0; m < k; m++) {\n        if(results[i][j] == true_data[i][m]) {\n          acc++;\n          break;\n        }\n      }\n    }\n    mean_acc += acc / k;\n  }\n  std::cout << \"recall: \" << mean_acc / num << std::endl;\n}\n\nint main(int argc, char** argv) {\n  std::vector<std::vector<unsigned> > true_data;\n  std::vector<std::vector<unsigned> > results;\n  unsigned dim, num;\n  load_ivecs_data(argv[1], true_data, num, dim);\n  load_ivecs_data(argv[2], results, num, dim);\n  cal_recall(results, true_data, num, dim);\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","source":"_posts/anns-nsg-code3.md","raw":"---\ntitle: C++计算召回率\ndate: 2019-08-12 22:00:22\ntags:\n- C/C++\n- ANNS\n- 源码阅读\ncategories:\n- 近似最近邻搜索\nmathjax: true\n---\n\n## 引言\n\n近似最近邻搜索中评估算法的搜索性能经常用到召回率，召回率的计算公式一般为：\n$$\nRecall@K = \\frac{R_1 \\bigcap R_2}{K}\n$$\n其中，$R_1$ 为搜索算法返回的 $K$ 个元素组成的集合，$R_2$ 为查询点真实的 $K$ 个近邻点，$Recall@K$ 为返回 $K$ 个近邻点时的召回率。\n\n## C++代码实现召回率的计算\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nvoid load_ivecs_data(const char* filename,\t//从文件中读取ivecs格式的数据\n                 std::vector<std::vector<unsigned> >& results, unsigned &num, unsigned &dim) {\n  std::ifstream in(filename, std::ios::binary);\n  if (!in.is_open()) {\n    std::cout << \"open file error\" << std::endl;\n    exit(-1);\n  }\n  in.read((char*)&dim, 4);\n  //std::cout<<\"data dimension: \"<<dim<<std::endl;\n  in.seekg(0, std::ios::end);\n  std::ios::pos_type ss = in.tellg();\n  size_t fsize = (size_t)ss;\n  num = (unsigned)(fsize / (dim + 1) / 4);\n  results.resize(num);\n  for (unsigned i = 0; i < num; i++) results[i].resize(dim);\n\n  in.seekg(0, std::ios::beg);\n  for (size_t i = 0; i < num; i++) {\n    in.seekg(4, std::ios::cur);\n    in.read((char*)results[i].data(), dim * 4);\n  }\n  in.close();\n}\n\nvoid cal_recall(std::vector<std::vector<unsigned> > results, std::vector<std::vector<unsigned> > true_data, unsigned num, unsigned k) {//召回率计算\n  float mean_acc = 0;\n  for(size_t i = 0; i < num; i++) {\n    float acc = 0;\n    for(size_t j = 0; j < k; j++) {\n      for(size_t m = 0; m < k; m++) {\n        if(results[i][j] == true_data[i][m]) {\n          acc++;\n          break;\n        }\n      }\n    }\n    mean_acc += acc / k;\n  }\n  std::cout << \"recall: \" << mean_acc / num << std::endl;\n}\n\nint main(int argc, char** argv) {\n  std::vector<std::vector<unsigned> > true_data;\n  std::vector<std::vector<unsigned> > results;\n  unsigned dim, num;\n  load_ivecs_data(argv[1], true_data, num, dim);\n  load_ivecs_data(argv[2], results, num, dim);\n  cal_recall(results, true_data, num, dim);\n  return 0;\n}\n```\n\n## 参考文献\n\n> [1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, https://github.com/ZJULearning/nsg, 2019.8.12.","slug":"anns-nsg-code3","published":1,"updated":"2019-08-16T13:48:37.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx8220008wtfkacsr4h8r","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>近似最近邻搜索中评估算法的搜索性能经常用到召回率，召回率的计算公式一般为：</p>\n<script type=\"math/tex; mode=display\">\nRecall@K = \\frac{R_1 \\bigcap R_2}{K}</script><p>其中，$R_1$ 为搜索算法返回的 $K$ 个元素组成的集合，$R_2$ 为查询点真实的 $K$ 个近邻点，$Recall@K$ 为返回 $K$ 个近邻点时的召回率。</p>\n<h2 id=\"C-代码实现召回率的计算\"><a href=\"#C-代码实现召回率的计算\" class=\"headerlink\" title=\"C++代码实现召回率的计算\"></a>C++代码实现召回率的计算</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"CPP\"><figure class=\"iseeu highlight /cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_ivecs_data</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filename,\t<span class=\"comment\">//从文件中读取ivecs格式的数据</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt;&amp; results, <span class=\"keyword\">unsigned</span> &amp;num, <span class=\"keyword\">unsigned</span> &amp;dim)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"comment\">//std::cout&lt;&lt;\"data dimension: \"&lt;&lt;dim&lt;&lt;std::endl;</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);</span><br><span class=\"line\">  results.resize(num);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>; i &lt; num; i++) results[i].resize(dim);</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);</span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)results[i].data(), dim * <span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cal_recall</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; results, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_data, <span class=\"keyword\">unsigned</span> num, <span class=\"keyword\">unsigned</span> k)</span> </span>&#123;<span class=\"comment\">//召回率计算</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> mean_acc = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> acc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; k; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> m = <span class=\"number\">0</span>; m &lt; k; m++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(results[i][j] == true_data[i][m]) &#123;</span><br><span class=\"line\">          acc++;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mean_acc += acc / k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"recall: \"</span> &lt;&lt; mean_acc / num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_data;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; results;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> dim, num;</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">1</span>], true_data, num, dim);</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">2</span>], results, num, dim);</span><br><span class=\"line\">  cal_recall(results, true_data, num, dim);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>近似最近邻搜索中评估算法的搜索性能经常用到召回率，召回率的计算公式一般为：</p>\n<script type=\"math/tex; mode=display\">\nRecall@K = \\frac{R_1 \\bigcap R_2}{K}</script><p>其中，$R_1$ 为搜索算法返回的 $K$ 个元素组成的集合，$R_2$ 为查询点真实的 $K$ 个近邻点，$Recall@K$ 为返回 $K$ 个近邻点时的召回率。</p>\n<h2 id=\"C-代码实现召回率的计算\"><a href=\"#C-代码实现召回率的计算\" class=\"headerlink\" title=\"C++代码实现召回率的计算\"></a>C++代码实现召回率的计算</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load_ivecs_data</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* filename,\t<span class=\"comment\">//从文件中读取ivecs格式的数据</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                 <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt;&amp; results, <span class=\"keyword\">unsigned</span> &amp;num, <span class=\"keyword\">unsigned</span> &amp;dim)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(filename, <span class=\"built_in\">std</span>::ios::binary)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in.is_open()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"open file error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.read((<span class=\"keyword\">char</span>*)&amp;dim, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"comment\">//std::cout&lt;&lt;\"data dimension: \"&lt;&lt;dim&lt;&lt;std::endl;</span></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::end);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::ios::pos_type ss = in.tellg();</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> fsize = (<span class=\"keyword\">size_t</span>)ss;</span><br><span class=\"line\">  num = (<span class=\"keyword\">unsigned</span>)(fsize / (dim + <span class=\"number\">1</span>) / <span class=\"number\">4</span>);</span><br><span class=\"line\">  results.resize(num);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>; i &lt; num; i++) results[i].resize(dim);</span><br><span class=\"line\"></span><br><span class=\"line\">  in.seekg(<span class=\"number\">0</span>, <span class=\"built_in\">std</span>::ios::beg);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    in.seekg(<span class=\"number\">4</span>, <span class=\"built_in\">std</span>::ios::cur);</span><br><span class=\"line\">    in.read((<span class=\"keyword\">char</span>*)results[i].data(), dim * <span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  in.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cal_recall</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; results, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_data, <span class=\"keyword\">unsigned</span> num, <span class=\"keyword\">unsigned</span> k)</span> </span>&#123;<span class=\"comment\">//召回率计算</span></span><br><span class=\"line\">  <span class=\"keyword\">float</span> mean_acc = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> acc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; k; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> m = <span class=\"number\">0</span>; m &lt; k; m++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(results[i][j] == true_data[i][m]) &#123;</span><br><span class=\"line\">          acc++;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mean_acc += acc / k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"recall: \"</span> &lt;&lt; mean_acc / num &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; true_data;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">unsigned</span>&gt; &gt; results;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> dim, num;</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">1</span>], true_data, num, dim);</span><br><span class=\"line\">  load_ivecs_data(argv[<span class=\"number\">2</span>], results, num, dim);</span><br><span class=\"line\">  cal_recall(results, true_data, num, dim);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>[1]付聪, NSG : Navigating Spread-out Graph For Approximate Nearest Neighbor Search, <a href=\"https://github.com/ZJULearning/nsg\" target=\"_blank\" rel=\"noopener\">https://github.com/ZJULearning/nsg</a>, 2019.8.12.</p>\n</blockquote>\n"},{"title":"PAT乙级1001 || 害死人不偿命的(3n+1)猜想（详解，C/C++示例，测试点分析）","date":"2019-08-09T06:33:15.000Z","_content":"\n# 害死人不偿命的(3n+1)猜想\n## 题目描述\n卡拉兹(Callatz)猜想：\n对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……\n我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1\n## 输入格式\n每个测试输入包含 1 个测试用例，即给出正整数 *n*的值。\n## 输出格式\n输出从 *n* 计算到 1 需要的步数。\n## 输入样例\n```\n 3\n```\n ## 输出样例\n```\n 5\n```\n\n## 问题解决\n\n### 解题思想\n\n用递归的方法，设置一个全局变量，用于统计砍的步数。n=1时直接返回；n=偶数时加一步，然后除以2；n=奇数时乘以3加1后递归调用函数继续计算。\n\n### 代码示例(C语言)\n\n```c\n#include <stdio.h>\nint count=0;//使用全局变量在递归调用中统计砍的次数\nvoid Count(int n);\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    Count(n);\n    printf(\"%d\\n\",count);\n    return 0;\n}\nvoid Count(int n)\n{\n    if(n==1){\n        return;\n    }\n    else if(n%2==0){\n        count++;\n        Count(n/2);\n    }\n    else{\n        Count(3*n+1);\n    }\n}\n\n```\n> 题目来源：PAT乙级1001\n> 作者：CHEN, Yue\n> 单位：浙江大学","source":"_posts/pat1001.md","raw":"---\ntitle: PAT乙级1001 || 害死人不偿命的(3n+1)猜想（详解，C/C++示例，测试点分析）\ndate: 2019-08-09 14:33:15\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# 害死人不偿命的(3n+1)猜想\n## 题目描述\n卡拉兹(Callatz)猜想：\n对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……\n我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1\n## 输入格式\n每个测试输入包含 1 个测试用例，即给出正整数 *n*的值。\n## 输出格式\n输出从 *n* 计算到 1 需要的步数。\n## 输入样例\n```\n 3\n```\n ## 输出样例\n```\n 5\n```\n\n## 问题解决\n\n### 解题思想\n\n用递归的方法，设置一个全局变量，用于统计砍的步数。n=1时直接返回；n=偶数时加一步，然后除以2；n=奇数时乘以3加1后递归调用函数继续计算。\n\n### 代码示例(C语言)\n\n```c\n#include <stdio.h>\nint count=0;//使用全局变量在递归调用中统计砍的次数\nvoid Count(int n);\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    Count(n);\n    printf(\"%d\\n\",count);\n    return 0;\n}\nvoid Count(int n)\n{\n    if(n==1){\n        return;\n    }\n    else if(n%2==0){\n        count++;\n        Count(n/2);\n    }\n    else{\n        Count(3*n+1);\n    }\n}\n\n```\n> 题目来源：PAT乙级1001\n> 作者：CHEN, Yue\n> 单位：浙江大学","slug":"pat1001","published":1,"updated":"2019-08-16T13:48:37.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx824000bwtfkwjdpykj9","content":"<h1 id=\"害死人不偿命的-3n-1-猜想\"><a href=\"#害死人不偿命的-3n-1-猜想\" class=\"headerlink\" title=\"害死人不偿命的(3n+1)猜想\"></a>害死人不偿命的(3n+1)猜想</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>卡拉兹(Callatz)猜想：<br>对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……<br>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em>的值。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>输出从 <em>n</em> 计算到 1 需要的步数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>用递归的方法，设置一个全局变量，用于统计砍的步数。n=1时直接返回；n=偶数时加一步，然后除以2；n=奇数时乘以3加1后递归调用函数继续计算。</p>\n<h3 id=\"代码示例-C语言\"><a href=\"#代码示例-C语言\" class=\"headerlink\" title=\"代码示例(C语言)\"></a>代码示例(C语言)</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;<span class=\"comment\">//使用全局变量在递归调用中统计砍的次数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    Count(n);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        Count(n/<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        Count(<span class=\"number\">3</span>*n+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1001<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"害死人不偿命的-3n-1-猜想\"><a href=\"#害死人不偿命的-3n-1-猜想\" class=\"headerlink\" title=\"害死人不偿命的(3n+1)猜想\"></a>害死人不偿命的(3n+1)猜想</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>卡拉兹(Callatz)猜想：<br>对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……<br>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em>的值。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>输出从 <em>n</em> 计算到 1 需要的步数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>用递归的方法，设置一个全局变量，用于统计砍的步数。n=1时直接返回；n=偶数时加一步，然后除以2；n=奇数时乘以3加1后递归调用函数继续计算。</p>\n<h3 id=\"代码示例-C语言\"><a href=\"#代码示例-C语言\" class=\"headerlink\" title=\"代码示例(C语言)\"></a>代码示例(C语言)</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;<span class=\"comment\">//使用全局变量在递归调用中统计砍的次数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    Count(n);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        Count(n/<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        Count(<span class=\"number\">3</span>*n+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1001<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1002 || 写出这个数（详解，C/C++示例，测试点分析）","date":"2019-08-09T06:34:15.000Z","mathjax":true,"_content":"\n# 写出这个数 \n## 题目描述\n读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。\n## 输入格式\n每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 $10^{100}$。\n## 输出格式\n在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。\n## 输入样例\n```lsl\n12345678901234567\n```\n## 输出样例\n```lsl\nqi san\n```\n\n## 问题解决\n### 解题思想\n此题重点需要解决以下问题：\n1. 大数输入问题\n$10^{100}$ 用int和long long都是远远不够的，因此用字符数组来输入，然后再转换成整数\n2. 数字与拼音的转换\n本题用最基本的方法，使用switch开关语句实现转换\n3. 拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。\n此类问题一般使用以下代码实现：\n```c\nfor(i=0; i < n; i++){\n    printf(\"%d\", a[i]);\n    if(i < n-1){\n        printf(\" \");\n    }\n    else{\n        printf(\"\\n\");\n    }\n}\n```\n\n### 知识拓展\n* 绝对值在 $10^9$范围以内的整数都可以定义成int型\n* 如果在 $10^9$以上，在 $10^{18}$ 以内用long long型来存放\n\n### 代码示例（C）\n```c\n#include <stdio.h>\n#define N 101\nint main()\n{\n    int sum=0,i=0,a[N];\n    char str[N];\n    gets(str);//以字符的方式读入大整数\n    while(str[i]!='\\0'){\n        sum+=str[i]-'0';\n        i++;\n    }\n    i=0;\n    do{\n        a[i]=sum%10;\n        sum=sum/10;\n        i++;\n    }while(sum);//将sum的每一位逆向存入数组a中\n    i--;//循环退出时i多加1\n    do{\n        switch(a[i])\n        {\n            case 0:\n                printf(\"ling\");break;\n            case 1:\n                printf(\"yi\");break;\n            case 2:\n                printf(\"er\");break;\n            case 3:\n                printf(\"san\");break;\n            case 4:\n                printf(\"si\");break;\n            case 5:\n                printf(\"wu\");break;\n            case 6:\n                printf(\"liu\");break;\n            case 7:\n                printf(\"qi\");break;\n            case 8:\n                printf(\"ba\");break;\n            default:\n                printf(\"jiu\");\n        }\n        if(i>0){\n            printf(\" \");\n        }\n        else{\n            printf(\"\\n\");\n        }//每两个输出之间用空格隔开，最后不加空格\n        i--;\n    }while(i>=0);\n    return 0;\n}\n```\n>题目来源：PAT乙级1002\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1002.md","raw":"---\ntitle: PAT乙级1002 || 写出这个数（详解，C/C++示例，测试点分析）\ndate: 2019-08-09 14:34:15\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# 写出这个数 \n## 题目描述\n读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。\n## 输入格式\n每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 $10^{100}$。\n## 输出格式\n在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。\n## 输入样例\n```lsl\n12345678901234567\n```\n## 输出样例\n```lsl\nqi san\n```\n\n## 问题解决\n### 解题思想\n此题重点需要解决以下问题：\n1. 大数输入问题\n$10^{100}$ 用int和long long都是远远不够的，因此用字符数组来输入，然后再转换成整数\n2. 数字与拼音的转换\n本题用最基本的方法，使用switch开关语句实现转换\n3. 拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。\n此类问题一般使用以下代码实现：\n```c\nfor(i=0; i < n; i++){\n    printf(\"%d\", a[i]);\n    if(i < n-1){\n        printf(\" \");\n    }\n    else{\n        printf(\"\\n\");\n    }\n}\n```\n\n### 知识拓展\n* 绝对值在 $10^9$范围以内的整数都可以定义成int型\n* 如果在 $10^9$以上，在 $10^{18}$ 以内用long long型来存放\n\n### 代码示例（C）\n```c\n#include <stdio.h>\n#define N 101\nint main()\n{\n    int sum=0,i=0,a[N];\n    char str[N];\n    gets(str);//以字符的方式读入大整数\n    while(str[i]!='\\0'){\n        sum+=str[i]-'0';\n        i++;\n    }\n    i=0;\n    do{\n        a[i]=sum%10;\n        sum=sum/10;\n        i++;\n    }while(sum);//将sum的每一位逆向存入数组a中\n    i--;//循环退出时i多加1\n    do{\n        switch(a[i])\n        {\n            case 0:\n                printf(\"ling\");break;\n            case 1:\n                printf(\"yi\");break;\n            case 2:\n                printf(\"er\");break;\n            case 3:\n                printf(\"san\");break;\n            case 4:\n                printf(\"si\");break;\n            case 5:\n                printf(\"wu\");break;\n            case 6:\n                printf(\"liu\");break;\n            case 7:\n                printf(\"qi\");break;\n            case 8:\n                printf(\"ba\");break;\n            default:\n                printf(\"jiu\");\n        }\n        if(i>0){\n            printf(\" \");\n        }\n        else{\n            printf(\"\\n\");\n        }//每两个输出之间用空格隔开，最后不加空格\n        i--;\n    }while(i>=0);\n    return 0;\n}\n```\n>题目来源：PAT乙级1002\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1002","published":1,"updated":"2019-08-16T13:48:37.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx825000cwtfk18af5s51","content":"<h1 id=\"写出这个数\"><a href=\"#写出这个数\" class=\"headerlink\" title=\"写出这个数\"></a>写出这个数</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 $10^{100}$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">12345678901234567</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qi san</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题重点需要解决以下问题：</p>\n<ol>\n<li>大数输入问题<br>$10^{100}$ 用int和long long都是远远不够的，因此用字符数组来输入，然后再转换成整数</li>\n<li>数字与拼音的转换<br>本题用最基本的方法，使用switch开关语句实现转换</li>\n<li>拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。<br>此类问题一般使用以下代码实现：<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, a[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; n<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n</li>\n</ol>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><ul>\n<li>绝对值在 $10^9$范围以内的整数都可以定义成int型</li>\n<li>如果在 $10^9$以上，在 $10^{18}$ 以内用long long型来存放</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>,i=<span class=\"number\">0</span>,a[N];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[N];</span><br><span class=\"line\">    gets(str);<span class=\"comment\">//以字符的方式读入大整数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[i]!=<span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        sum+=str[i]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        a[i]=sum%<span class=\"number\">10</span>;</span><br><span class=\"line\">        sum=sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(sum);<span class=\"comment\">//将sum的每一位逆向存入数组a中</span></span><br><span class=\"line\">    i--;<span class=\"comment\">//循环退出时i多加1</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(a[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"ling\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"yi\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"er\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"san\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"si\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"wu\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"liu\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"qi\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"ba\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"jiu\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"comment\">//每两个输出之间用空格隔开，最后不加空格</span></span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(i&gt;=<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1002<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"写出这个数\"><a href=\"#写出这个数\" class=\"headerlink\" title=\"写出这个数\"></a>写出这个数</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 $10^{100}$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">12345678901234567</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qi san</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题重点需要解决以下问题：</p>\n<ol>\n<li>大数输入问题<br>$10^{100}$ 用int和long long都是远远不够的，因此用字符数组来输入，然后再转换成整数</li>\n<li>数字与拼音的转换<br>本题用最基本的方法，使用switch开关语句实现转换</li>\n<li>拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。<br>此类问题一般使用以下代码实现：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, a[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; n<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><ul>\n<li>绝对值在 $10^9$范围以内的整数都可以定义成int型</li>\n<li>如果在 $10^9$以上，在 $10^{18}$ 以内用long long型来存放</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>,i=<span class=\"number\">0</span>,a[N];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[N];</span><br><span class=\"line\">    gets(str);<span class=\"comment\">//以字符的方式读入大整数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str[i]!=<span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">        sum+=str[i]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        a[i]=sum%<span class=\"number\">10</span>;</span><br><span class=\"line\">        sum=sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(sum);<span class=\"comment\">//将sum的每一位逆向存入数组a中</span></span><br><span class=\"line\">    i--;<span class=\"comment\">//循环退出时i多加1</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(a[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"ling\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"yi\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"er\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"san\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"si\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"wu\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"liu\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"qi\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"ba\"</span>);<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"jiu\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"comment\">//每两个输出之间用空格隔开，最后不加空格</span></span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(i&gt;=<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1002<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1003 || 我要通过！（详解，C/C++示例，测试点分析）","date":"2019-08-10T06:34:15.000Z","mathjax":true,"_content":"\n# **我要通过！**\n## 题目描述\n“**答案正确**”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“**答案正确**”大派送 —— 只要读入的字符串满足下列条件，系统就输出“**答案正确**”，否则输出“**答案错误**”。\n得到“**答案正确**”的条件是：\n1. 字符串中必须仅有 `P`、 `A`、 `T`这三种字符，不可以包含其它字符；\n2. 任意形如 `xPATx` 的字符串都可以获得“**答案正确**”，其中 `x` 或者是空字符串，或者是仅由字母 `A` 组成的字符串；\n3. 如果 `aPbTc` 是正确的，那么 `aPbATca` 也是正确的，其中 `a`、 `b`、 `c` 均或者是空字符串，或者是仅由字母 `A` 组成的字符串。\n现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“**答案正确**”的。\n\n## 输入格式\n每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 *n* (<10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。\n## 输出格式\n每个字符串的检测结果占一行，如果该字符串可以获得“**答案正确**”，则输出 `YES`，否则输出 `NO`。\n## 输入样例\n```lsl\n8\nPAT\nPAAT\nAAPATAA\nAAPAATAAAA\nxPATx\nPT\nWhatever\nAPAAATAA\n```\n## 输出样例\n```lsl\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n```\n\n\n## 问题解决\n### 解题思想\n此题难点在于理解题意，有描述的3个条件可知，“**答案正确**”的字符串应满足以下条件：\n1. 必须只包含'P'，'A'，'T'三种字符，含有其它字符时必然是“**答案错误**”\n\n2. 'PAT'两端只能含有'A'，由条件2知，两端'A'的个数相等时，此字符串输出“**答案正确**”\n\n3. 条件3是最难理解的，要使 `aPbTc` 是正确的，则`b`必定是'A'，`a`与`c`中'A'的个数相等时（可同时为0）恰好是条件2的情况，此时 `aPbATca` 也是正确的，以此迭代下去可以得到如下规律（设'P'之前、'P'与'T'之间及'T'之后'A'的个数为count1、count2和count3）：\n$$\n   count1 \\times count2=count3\n$$\n\n理解了题意，代码过程就比较简单了。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#define N 101\nint main()\n{\n    int n,i,j,count1,count2,count3;\n    //count1统计P之前A的个数\n    //count2统计P与T之间A的个数\n    //count3统计T之后A的个数\n    char str[N];\n    scanf(\"%d\",&n);\n    getchar();//吸收掉缓冲区的换行符\n    for(i = 0; i < n; i++){\n        gets(str);\n        j = 0;\n        count1 = count2 = count3 = 0;\n        while(str[j] != '\\0'){\n            if(str[j] == 'P'||str[j] == 'A'||str[j] == 'T'){\n                //首先判断是否满足条件1\n                //找到第一个P\n                while(str[j] == 'A'&&str[j] != '\\0'){\n                    count1++;\n                    j++;\n                }\n                if(str[j]!='\\0'&&str[j] == 'P'){\n                    j++;\n                    while(str[j] == 'A'&&str[j] != '\\0'){\n                        count2++;\n                        j++;\n                    }\n                    if(str[j]!='\\0'&&str[j] == 'T'){\n                        j++;\n                        while(str[j] == 'A'&&str[j] != '\\0'){\n                            count3++;\n                            j++;\n                        }\n                        if(str[j] != '\\0'){//T之后还有除A之外的字符\n                            printf(\"NO\\n\");\n                            break;\n                        }\n                        else{\n                            //满足count1 * count2 == count3且三者不同时为零\n                            if((count1 * count2 == count3)&&(count1||count2||count3)){\n                                printf(\"YES\\n\");\n                                break;\n                            }\n                            else{\n                                printf(\"NO\\n\");\n                                break;\n                            }\n                        }\n                    }\n                    else{\n                        printf(\"NO\\n\");\n                        break;\n                    }\n                }\n                else{\n                    printf(\"NO\\n\");\n                    break;\n                }\n            }\n            else{//不满足条件1\n                printf(\"NO\\n\");\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n```\n>题目来源：PAT乙级1003\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1003.md","raw":"---\ntitle: PAT乙级1003 || 我要通过！（详解，C/C++示例，测试点分析）\ndate: 2019-08-10 14:34:15\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **我要通过！**\n## 题目描述\n“**答案正确**”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“**答案正确**”大派送 —— 只要读入的字符串满足下列条件，系统就输出“**答案正确**”，否则输出“**答案错误**”。\n得到“**答案正确**”的条件是：\n1. 字符串中必须仅有 `P`、 `A`、 `T`这三种字符，不可以包含其它字符；\n2. 任意形如 `xPATx` 的字符串都可以获得“**答案正确**”，其中 `x` 或者是空字符串，或者是仅由字母 `A` 组成的字符串；\n3. 如果 `aPbTc` 是正确的，那么 `aPbATca` 也是正确的，其中 `a`、 `b`、 `c` 均或者是空字符串，或者是仅由字母 `A` 组成的字符串。\n现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“**答案正确**”的。\n\n## 输入格式\n每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 *n* (<10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。\n## 输出格式\n每个字符串的检测结果占一行，如果该字符串可以获得“**答案正确**”，则输出 `YES`，否则输出 `NO`。\n## 输入样例\n```lsl\n8\nPAT\nPAAT\nAAPATAA\nAAPAATAAAA\nxPATx\nPT\nWhatever\nAPAAATAA\n```\n## 输出样例\n```lsl\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n```\n\n\n## 问题解决\n### 解题思想\n此题难点在于理解题意，有描述的3个条件可知，“**答案正确**”的字符串应满足以下条件：\n1. 必须只包含'P'，'A'，'T'三种字符，含有其它字符时必然是“**答案错误**”\n\n2. 'PAT'两端只能含有'A'，由条件2知，两端'A'的个数相等时，此字符串输出“**答案正确**”\n\n3. 条件3是最难理解的，要使 `aPbTc` 是正确的，则`b`必定是'A'，`a`与`c`中'A'的个数相等时（可同时为0）恰好是条件2的情况，此时 `aPbATca` 也是正确的，以此迭代下去可以得到如下规律（设'P'之前、'P'与'T'之间及'T'之后'A'的个数为count1、count2和count3）：\n$$\n   count1 \\times count2=count3\n$$\n\n理解了题意，代码过程就比较简单了。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#define N 101\nint main()\n{\n    int n,i,j,count1,count2,count3;\n    //count1统计P之前A的个数\n    //count2统计P与T之间A的个数\n    //count3统计T之后A的个数\n    char str[N];\n    scanf(\"%d\",&n);\n    getchar();//吸收掉缓冲区的换行符\n    for(i = 0; i < n; i++){\n        gets(str);\n        j = 0;\n        count1 = count2 = count3 = 0;\n        while(str[j] != '\\0'){\n            if(str[j] == 'P'||str[j] == 'A'||str[j] == 'T'){\n                //首先判断是否满足条件1\n                //找到第一个P\n                while(str[j] == 'A'&&str[j] != '\\0'){\n                    count1++;\n                    j++;\n                }\n                if(str[j]!='\\0'&&str[j] == 'P'){\n                    j++;\n                    while(str[j] == 'A'&&str[j] != '\\0'){\n                        count2++;\n                        j++;\n                    }\n                    if(str[j]!='\\0'&&str[j] == 'T'){\n                        j++;\n                        while(str[j] == 'A'&&str[j] != '\\0'){\n                            count3++;\n                            j++;\n                        }\n                        if(str[j] != '\\0'){//T之后还有除A之外的字符\n                            printf(\"NO\\n\");\n                            break;\n                        }\n                        else{\n                            //满足count1 * count2 == count3且三者不同时为零\n                            if((count1 * count2 == count3)&&(count1||count2||count3)){\n                                printf(\"YES\\n\");\n                                break;\n                            }\n                            else{\n                                printf(\"NO\\n\");\n                                break;\n                            }\n                        }\n                    }\n                    else{\n                        printf(\"NO\\n\");\n                        break;\n                    }\n                }\n                else{\n                    printf(\"NO\\n\");\n                    break;\n                }\n            }\n            else{//不满足条件1\n                printf(\"NO\\n\");\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n```\n>题目来源：PAT乙级1003\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1003","published":1,"updated":"2019-08-16T13:48:37.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx828000gwtfk7xosx3vi","content":"<h1 id=\"我要通过！\"><a href=\"#我要通过！\" class=\"headerlink\" title=\"我要通过！\"></a><strong>我要通过！</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>“<strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。<br>得到“<strong>答案正确</strong>”的条件是：</p>\n<ol>\n<li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li>\n<li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li>\n<li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。<br>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</li>\n</ol>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 <em>n</em> (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\">PAT</span><br><span class=\"line\">PAAT</span><br><span class=\"line\">AAPATAA</span><br><span class=\"line\">AAPAATAAAA</span><br><span class=\"line\">xPATx</span><br><span class=\"line\">PT</span><br><span class=\"line\">Whatever</span><br><span class=\"line\">APAAATAA</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题难点在于理解题意，有描述的3个条件可知，“<strong>答案正确</strong>”的字符串应满足以下条件：</p>\n<ol>\n<li><p>必须只包含’P’，’A’，’T’三种字符，含有其它字符时必然是“<strong>答案错误</strong>”</p>\n</li>\n<li><p>‘PAT’两端只能含有’A’，由条件2知，两端’A’的个数相等时，此字符串输出“<strong>答案正确</strong>”</p>\n</li>\n<li><p>条件3是最难理解的，要使 <code>aPbTc</code> 是正确的，则<code>b</code>必定是’A’，<code>a</code>与<code>c</code>中’A’的个数相等时（可同时为0）恰好是条件2的情况，此时 <code>aPbATca</code> 也是正确的，以此迭代下去可以得到如下规律（设’P’之前、’P’与’T’之间及’T’之后’A’的个数为count1、count2和count3）：</p>\n<script type=\"math/tex; mode=display\">\ncount1 \\times count2=count3</script></li>\n</ol>\n<p>理解了题意，代码过程就比较简单了。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,j,count1,count2,count3;</span><br><span class=\"line\">    <span class=\"comment\">//count1统计P之前A的个数</span></span><br><span class=\"line\">    <span class=\"comment\">//count2统计P与T之间A的个数</span></span><br><span class=\"line\">    <span class=\"comment\">//count3统计T之后A的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[N];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    getchar();<span class=\"comment\">//吸收掉缓冲区的换行符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        gets(str);</span><br><span class=\"line\">        j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        count1 = count2 = count3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[j] == <span class=\"string\">'P'</span>||str[j] == <span class=\"string\">'A'</span>||str[j] == <span class=\"string\">'T'</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//首先判断是否满足条件1</span></span><br><span class=\"line\">                <span class=\"comment\">//找到第一个P</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                    count1++;</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[j]!=<span class=\"string\">'\\0'</span>&amp;&amp;str[j] == <span class=\"string\">'P'</span>)&#123;</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                        count2++;</span><br><span class=\"line\">                        j++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(str[j]!=<span class=\"string\">'\\0'</span>&amp;&amp;str[j] == <span class=\"string\">'T'</span>)&#123;</span><br><span class=\"line\">                        j++;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                            count3++;</span><br><span class=\"line\">                            j++;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(str[j] != <span class=\"string\">'\\0'</span>)&#123;<span class=\"comment\">//T之后还有除A之外的字符</span></span><br><span class=\"line\">                            <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">//满足count1 * count2 == count3且三者不同时为零</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span>((count1 * count2 == count3)&amp;&amp;(count1||count2||count3))&#123;</span><br><span class=\"line\">                                <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                                <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//不满足条件1</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1003<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"我要通过！\"><a href=\"#我要通过！\" class=\"headerlink\" title=\"我要通过！\"></a><strong>我要通过！</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>“<strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。<br>得到“<strong>答案正确</strong>”的条件是：</p>\n<ol>\n<li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li>\n<li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li>\n<li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。<br>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</li>\n</ol>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 <em>n</em> (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\">PAT</span><br><span class=\"line\">PAAT</span><br><span class=\"line\">AAPATAA</span><br><span class=\"line\">AAPAATAAAA</span><br><span class=\"line\">xPATx</span><br><span class=\"line\">PT</span><br><span class=\"line\">Whatever</span><br><span class=\"line\">APAAATAA</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题难点在于理解题意，有描述的3个条件可知，“<strong>答案正确</strong>”的字符串应满足以下条件：</p>\n<ol>\n<li><p>必须只包含’P’，’A’，’T’三种字符，含有其它字符时必然是“<strong>答案错误</strong>”</p>\n</li>\n<li><p>‘PAT’两端只能含有’A’，由条件2知，两端’A’的个数相等时，此字符串输出“<strong>答案正确</strong>”</p>\n</li>\n<li><p>条件3是最难理解的，要使 <code>aPbTc</code> 是正确的，则<code>b</code>必定是’A’，<code>a</code>与<code>c</code>中’A’的个数相等时（可同时为0）恰好是条件2的情况，此时 <code>aPbATca</code> 也是正确的，以此迭代下去可以得到如下规律（设’P’之前、’P’与’T’之间及’T’之后’A’的个数为count1、count2和count3）：</p>\n<script type=\"math/tex; mode=display\">\ncount1 \\times count2=count3</script></li>\n</ol>\n<p>理解了题意，代码过程就比较简单了。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,j,count1,count2,count3;</span><br><span class=\"line\">    <span class=\"comment\">//count1统计P之前A的个数</span></span><br><span class=\"line\">    <span class=\"comment\">//count2统计P与T之间A的个数</span></span><br><span class=\"line\">    <span class=\"comment\">//count3统计T之后A的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[N];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    getchar();<span class=\"comment\">//吸收掉缓冲区的换行符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        gets(str);</span><br><span class=\"line\">        j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        count1 = count2 = count3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[j] == <span class=\"string\">'P'</span>||str[j] == <span class=\"string\">'A'</span>||str[j] == <span class=\"string\">'T'</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//首先判断是否满足条件1</span></span><br><span class=\"line\">                <span class=\"comment\">//找到第一个P</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                    count1++;</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[j]!=<span class=\"string\">'\\0'</span>&amp;&amp;str[j] == <span class=\"string\">'P'</span>)&#123;</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                        count2++;</span><br><span class=\"line\">                        j++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(str[j]!=<span class=\"string\">'\\0'</span>&amp;&amp;str[j] == <span class=\"string\">'T'</span>)&#123;</span><br><span class=\"line\">                        j++;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(str[j] == <span class=\"string\">'A'</span>&amp;&amp;str[j] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                            count3++;</span><br><span class=\"line\">                            j++;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(str[j] != <span class=\"string\">'\\0'</span>)&#123;<span class=\"comment\">//T之后还有除A之外的字符</span></span><br><span class=\"line\">                            <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">//满足count1 * count2 == count3且三者不同时为零</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span>((count1 * count2 == count3)&amp;&amp;(count1||count2||count3))&#123;</span><br><span class=\"line\">                                <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                                <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//不满足条件1</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1003<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1004 || 成绩排名（详解，C/C++示例，测试点分析）","date":"2019-08-11T07:03:42.000Z","_content":"\n\n# **成绩排名**\n## **题目描述**\n读入 n（>0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。\n## **输入格式**\n每个测试输入包含 1 个测试用例，格式为\n```\n第 1 行：正整数 n\n第 2 行：第 1 个学生的姓名 学号 成绩\n第 3 行：第 2 个学生的姓名 学号 成绩\n... ... ...\n第 n+1 行：第 n 个学生的姓名 学号 成绩\n```\n其中`姓名`和`学号`均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保>证在一组测试用例中没有两个学生的成绩是相同的。\n## **输出格式**\n对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。\n## **输入样例**\n```\n3\nJoe Math990112 89\nMike CS991301 100\nMary EE990830 95\n```\n## **输出样例**\n```lsl\nMike CS991301\nJoe Math990112\n```\n\n##  问题解决\n### 解题思想\n此题注意以下几点即可：\n\n* 输入整数n后，输入缓冲区会有一个换行符，在输入字符串之前要把它吸收掉\n* 由于在一行内输入多个字符串且用空格隔开，因此，不能用gets来输入字符串了，因为gets会把空格也读入，这里用了scanf\n* 不能用赋值符 `=` 来将一个字符串赋给另一个，要用字符串拷贝函数strcpy，此函数包含在头文件 `string.h` 中\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <string.h>//下面要用到strcpy()函数\n#define N 11\nint main()\n{\n    int n,i,score,maxscore,minscore;\n    char name[N],snum[N];\n    char minname[N],minsnum[N],maxname[N],maxsnum[N];\n    maxscore = -1;//最小分数初始化\n    minscore = 101;//最大分数初始化\n    scanf(\"%d\",&n);\n    getchar();//吸收掉缓冲区的换行符\n    for(i = 0; i < n; i++){\n        //下面要使用scanf()函数输入字符串，不能用gets()\n        //因为scanf()函数是以空格、换行等作为字符串结束符，\n        //而gets()只以换行作为输入结束符\n        scanf(\"%s%s%d\",name,snum,&score);\n        if(maxscore<score){\n            maxscore = score;\n            //注意下面要使用字符串拷贝函数，不可直接赋值\n            strcpy(maxname,name);\n            strcpy(maxsnum,snum);\n        }\n        if(minscore>score){\n            minscore = score;\n            strcpy(minname,name);\n            strcpy(minsnum,snum);\n        }\n    }\n    printf(\"%s %s\\n\",maxname,maxsnum);\n    printf(\"%s %s\\n\",minname,minsnum);\n    return 0;\n}\n\n```\n>题目来源：PAT乙级1004\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1004.md","raw":"---\ntitle: PAT乙级1004 || 成绩排名（详解，C/C++示例，测试点分析）\ndate: 2019-08-11 15:03:42\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n\n# **成绩排名**\n## **题目描述**\n读入 n（>0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。\n## **输入格式**\n每个测试输入包含 1 个测试用例，格式为\n```\n第 1 行：正整数 n\n第 2 行：第 1 个学生的姓名 学号 成绩\n第 3 行：第 2 个学生的姓名 学号 成绩\n... ... ...\n第 n+1 行：第 n 个学生的姓名 学号 成绩\n```\n其中`姓名`和`学号`均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保>证在一组测试用例中没有两个学生的成绩是相同的。\n## **输出格式**\n对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。\n## **输入样例**\n```\n3\nJoe Math990112 89\nMike CS991301 100\nMary EE990830 95\n```\n## **输出样例**\n```lsl\nMike CS991301\nJoe Math990112\n```\n\n##  问题解决\n### 解题思想\n此题注意以下几点即可：\n\n* 输入整数n后，输入缓冲区会有一个换行符，在输入字符串之前要把它吸收掉\n* 由于在一行内输入多个字符串且用空格隔开，因此，不能用gets来输入字符串了，因为gets会把空格也读入，这里用了scanf\n* 不能用赋值符 `=` 来将一个字符串赋给另一个，要用字符串拷贝函数strcpy，此函数包含在头文件 `string.h` 中\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <string.h>//下面要用到strcpy()函数\n#define N 11\nint main()\n{\n    int n,i,score,maxscore,minscore;\n    char name[N],snum[N];\n    char minname[N],minsnum[N],maxname[N],maxsnum[N];\n    maxscore = -1;//最小分数初始化\n    minscore = 101;//最大分数初始化\n    scanf(\"%d\",&n);\n    getchar();//吸收掉缓冲区的换行符\n    for(i = 0; i < n; i++){\n        //下面要使用scanf()函数输入字符串，不能用gets()\n        //因为scanf()函数是以空格、换行等作为字符串结束符，\n        //而gets()只以换行作为输入结束符\n        scanf(\"%s%s%d\",name,snum,&score);\n        if(maxscore<score){\n            maxscore = score;\n            //注意下面要使用字符串拷贝函数，不可直接赋值\n            strcpy(maxname,name);\n            strcpy(maxsnum,snum);\n        }\n        if(minscore>score){\n            minscore = score;\n            strcpy(minname,name);\n            strcpy(minsnum,snum);\n        }\n    }\n    printf(\"%s %s\\n\",maxname,maxsnum);\n    printf(\"%s %s\\n\",minname,minsnum);\n    return 0;\n}\n\n```\n>题目来源：PAT乙级1004\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1004","published":1,"updated":"2019-08-16T13:48:37.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx829000jwtfku60y58d2","content":"<h1 id=\"成绩排名\"><a href=\"#成绩排名\" class=\"headerlink\" title=\"成绩排名\"></a><strong>成绩排名</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，格式为<br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第 <span class=\"number\">1</span> 行：正整数 n</span><br><span class=\"line\">第 <span class=\"number\">2</span> 行：第 <span class=\"number\">1</span> 个学生的姓名 学号 成绩</span><br><span class=\"line\">第 <span class=\"number\">3</span> 行：第 <span class=\"number\">2</span> 个学生的姓名 学号 成绩</span><br><span class=\"line\">... ... ...</span><br><span class=\"line\">第 n+<span class=\"number\">1</span> 行：第 n 个学生的姓名 学号 成绩</span><br></pre></td></tr></table></figure></div></p>\n<p>其中<code>姓名</code>和<code>学号</code>均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保&gt;证在一组测试用例中没有两个学生的成绩是相同的。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">Joe Math990112 <span class=\"number\">89</span></span><br><span class=\"line\">Mike CS991301 <span class=\"number\">100</span></span><br><span class=\"line\">Mary EE990830 <span class=\"number\">95</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"LSL\"><figure class=\"iseeu highlight /lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mike CS991301</span><br><span class=\"line\">Joe Math990112</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题注意以下几点即可：</p>\n<ul>\n<li>输入整数n后，输入缓冲区会有一个换行符，在输入字符串之前要把它吸收掉</li>\n<li>由于在一行内输入多个字符串且用空格隔开，因此，不能用gets来输入字符串了，因为gets会把空格也读入，这里用了scanf</li>\n<li>不能用赋值符 <code>=</code> 来将一个字符串赋给另一个，要用字符串拷贝函数strcpy，此函数包含在头文件 <code>string.h</code> 中</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;//下面要用到strcpy()函数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 11</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,score,maxscore,minscore;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[N],snum[N];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> minname[N],minsnum[N],maxname[N],maxsnum[N];</span><br><span class=\"line\">    maxscore = <span class=\"number\">-1</span>;<span class=\"comment\">//最小分数初始化</span></span><br><span class=\"line\">    minscore = <span class=\"number\">101</span>;<span class=\"comment\">//最大分数初始化</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    getchar();<span class=\"comment\">//吸收掉缓冲区的换行符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//下面要使用scanf()函数输入字符串，不能用gets()</span></span><br><span class=\"line\">        <span class=\"comment\">//因为scanf()函数是以空格、换行等作为字符串结束符，</span></span><br><span class=\"line\">        <span class=\"comment\">//而gets()只以换行作为输入结束符</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s%d\"</span>,name,snum,&amp;score);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(maxscore&lt;score)&#123;</span><br><span class=\"line\">            maxscore = score;</span><br><span class=\"line\">            <span class=\"comment\">//注意下面要使用字符串拷贝函数，不可直接赋值</span></span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(maxname,name);</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(maxsnum,snum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(minscore&gt;score)&#123;</span><br><span class=\"line\">            minscore = score;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(minname,name);</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(minsnum,snum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s\\n\"</span>,maxname,maxsnum);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s\\n\"</span>,minname,minsnum);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1004<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"成绩排名\"><a href=\"#成绩排名\" class=\"headerlink\" title=\"成绩排名\"></a><strong>成绩排名</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，格式为<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第 <span class=\"number\">1</span> 行：正整数 n</span><br><span class=\"line\">第 <span class=\"number\">2</span> 行：第 <span class=\"number\">1</span> 个学生的姓名 学号 成绩</span><br><span class=\"line\">第 <span class=\"number\">3</span> 行：第 <span class=\"number\">2</span> 个学生的姓名 学号 成绩</span><br><span class=\"line\">... ... ...</span><br><span class=\"line\">第 n+<span class=\"number\">1</span> 行：第 n 个学生的姓名 学号 成绩</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>姓名</code>和<code>学号</code>均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保&gt;证在一组测试用例中没有两个学生的成绩是相同的。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">Joe Math990112 <span class=\"number\">89</span></span><br><span class=\"line\">Mike CS991301 <span class=\"number\">100</span></span><br><span class=\"line\">Mary EE990830 <span class=\"number\">95</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mike CS991301</span><br><span class=\"line\">Joe Math990112</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题注意以下几点即可：</p>\n<ul>\n<li>输入整数n后，输入缓冲区会有一个换行符，在输入字符串之前要把它吸收掉</li>\n<li>由于在一行内输入多个字符串且用空格隔开，因此，不能用gets来输入字符串了，因为gets会把空格也读入，这里用了scanf</li>\n<li>不能用赋值符 <code>=</code> 来将一个字符串赋给另一个，要用字符串拷贝函数strcpy，此函数包含在头文件 <code>string.h</code> 中</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;//下面要用到strcpy()函数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 11</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,score,maxscore,minscore;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[N],snum[N];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> minname[N],minsnum[N],maxname[N],maxsnum[N];</span><br><span class=\"line\">    maxscore = <span class=\"number\">-1</span>;<span class=\"comment\">//最小分数初始化</span></span><br><span class=\"line\">    minscore = <span class=\"number\">101</span>;<span class=\"comment\">//最大分数初始化</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    getchar();<span class=\"comment\">//吸收掉缓冲区的换行符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//下面要使用scanf()函数输入字符串，不能用gets()</span></span><br><span class=\"line\">        <span class=\"comment\">//因为scanf()函数是以空格、换行等作为字符串结束符，</span></span><br><span class=\"line\">        <span class=\"comment\">//而gets()只以换行作为输入结束符</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%s%d\"</span>,name,snum,&amp;score);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(maxscore&lt;score)&#123;</span><br><span class=\"line\">            maxscore = score;</span><br><span class=\"line\">            <span class=\"comment\">//注意下面要使用字符串拷贝函数，不可直接赋值</span></span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(maxname,name);</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(maxsnum,snum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(minscore&gt;score)&#123;</span><br><span class=\"line\">            minscore = score;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(minname,name);</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(minsnum,snum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s\\n\"</span>,maxname,maxsnum);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s\\n\"</span>,minname,minsnum);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1004<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1005 || 继续(3n+1)猜想（详解，C/C++示例，测试点分析）","date":"2019-08-14T04:22:24.000Z","_content":"\n# **继续(3n+1)猜想**\n## **题目描述**\n卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。\n当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。\n现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。\n## **输入格式**\n每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 *K* (<100)，第 2 行给出 *K* 个互不相同的待验证的正整数 *n* (1<*n*≤100)的值，数字间用空格隔开。\n## **输出格式**\n每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。\n## **输入样例**\n```null\n6\n3 5 6 7 8 11\n```\n## **输出样例**\n```null\n7 6\n```\n\n##  问题解决\n### 解题思想\n解决此题的关键是*散列思想*，输入格式给出的n的范围已经暗示了这一思想。\n\n1. 用一个标记数组mark（初始化为-1），将输入的每个待判定的数（各数互不相同）作为数组的下标，输入一个r，就把mark[r]的值置为0；\n2. 然后按照从小到大的顺序（想一想为什么从小到大呢？若从大到小呢？其实是一样的）对每个待检测的数（mark[r]==0的r）找r在砍的时候遇到的数j（比如3在砍的时候会依次遇到5、8、4、2、1），并把mark[j]置为1；\n3. 重复过程2，最后从大到小输出mark数组中mark[r]==0的r，即为题目要求的按从大到小的顺序输出关键数字。\n\n`注`：之前在提交时，部分数据出现了段错误(一般是数组下标越界或栈溢出等引起)，费了好大劲才找到错误（低级错误），错误如下，希望大家不要出现我这种错误。\n\n判断j在砍的时候遇到的数时（错误代码）：\n\n```c\nif((j % 2 == 0)&&(j / 2 < 100)){\n    j /= 2;\n    mark[j] = 1;\n}\nelse{\n    j = 3 * j + 1;\n}\n```\n更正后：\n\n```c\nif(j % 2 == 0){\n    j /= 2;\n    if(j < 100){\n        mark[j] = 1;\n    }\n}\nelse{\n    j = 3 * j + 1;\n}\n```\n### 知识拓展\n* 非顺序输出情况下，各个数之间有空格，最后一个数后无空格。借助flag作标记即可\n\n```c\nint flag = 0;\nif(flag == 0){\n    printf(\"%d\",a[i]);\n    flag = 1;\n}\nelse{\n    printf(\" %d\",a[i]);\n}\n```\n\n* memset函数（对数组的每一个元素赋相同的值）格式为：memset(数组名，值，sizeof(数组名));使用memset时，需要在程序开头添加 `string.h` 头文件。初学者最好只用memset给数组赋-1或0，因为-1二进制补码为全1，0的二进制补码为全0，而memset是按字节赋值的。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <string.h>\n#define N 101\nint main()\n{\n    int n,i,r,j,flag = 0,mark[N];//flag作为标记以控制输出格式\n    scanf(\"%d\",&n);\n    memset(mark,-1,sizeof(mark));//mark数组初始化为-1\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&r);\n        mark[r] = 0;//输入以数组下标形式存入数组mark\n    }\n    for(r = 2; r <= 100; r++){\n        j = r;\n        if(mark[j] == 0){\n            do{\n                if(j % 2 == 0){\n                    //下面的if条件中加上j < 100是为了\n                    //防止数组下标越界\n                    j /= 2;\n                    if(j<100){\n                       mark[j] = 1;\n                    }\n                }\n                else{\n                    j = 3 * j + 1;\n                }\n            }while(j != 2);\n        }\n    }\n    for(i = 100; i > 1; i--){\n        //flag==0时为第一次输出数据，其前面不需加空格\n        //flag==1时为第二次以上输出数据，前面加一空格\n        if((mark[i] == 0)&&(flag == 0)){\n            printf(\"%d\",i);\n            flag = 1;\n        }\n        else if((mark[i] == 0)&&(flag == 1)){\n            printf(\" %d\",i);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1005\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1005.md","raw":"---\ntitle: PAT乙级1005 || 继续(3n+1)猜想（详解，C/C++示例，测试点分析）\ndate: 2019-08-14 12:22:24\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **继续(3n+1)猜想**\n## **题目描述**\n卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。\n当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。\n现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。\n## **输入格式**\n每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 *K* (<100)，第 2 行给出 *K* 个互不相同的待验证的正整数 *n* (1<*n*≤100)的值，数字间用空格隔开。\n## **输出格式**\n每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。\n## **输入样例**\n```null\n6\n3 5 6 7 8 11\n```\n## **输出样例**\n```null\n7 6\n```\n\n##  问题解决\n### 解题思想\n解决此题的关键是*散列思想*，输入格式给出的n的范围已经暗示了这一思想。\n\n1. 用一个标记数组mark（初始化为-1），将输入的每个待判定的数（各数互不相同）作为数组的下标，输入一个r，就把mark[r]的值置为0；\n2. 然后按照从小到大的顺序（想一想为什么从小到大呢？若从大到小呢？其实是一样的）对每个待检测的数（mark[r]==0的r）找r在砍的时候遇到的数j（比如3在砍的时候会依次遇到5、8、4、2、1），并把mark[j]置为1；\n3. 重复过程2，最后从大到小输出mark数组中mark[r]==0的r，即为题目要求的按从大到小的顺序输出关键数字。\n\n`注`：之前在提交时，部分数据出现了段错误(一般是数组下标越界或栈溢出等引起)，费了好大劲才找到错误（低级错误），错误如下，希望大家不要出现我这种错误。\n\n判断j在砍的时候遇到的数时（错误代码）：\n\n```c\nif((j % 2 == 0)&&(j / 2 < 100)){\n    j /= 2;\n    mark[j] = 1;\n}\nelse{\n    j = 3 * j + 1;\n}\n```\n更正后：\n\n```c\nif(j % 2 == 0){\n    j /= 2;\n    if(j < 100){\n        mark[j] = 1;\n    }\n}\nelse{\n    j = 3 * j + 1;\n}\n```\n### 知识拓展\n* 非顺序输出情况下，各个数之间有空格，最后一个数后无空格。借助flag作标记即可\n\n```c\nint flag = 0;\nif(flag == 0){\n    printf(\"%d\",a[i]);\n    flag = 1;\n}\nelse{\n    printf(\" %d\",a[i]);\n}\n```\n\n* memset函数（对数组的每一个元素赋相同的值）格式为：memset(数组名，值，sizeof(数组名));使用memset时，需要在程序开头添加 `string.h` 头文件。初学者最好只用memset给数组赋-1或0，因为-1二进制补码为全1，0的二进制补码为全0，而memset是按字节赋值的。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <string.h>\n#define N 101\nint main()\n{\n    int n,i,r,j,flag = 0,mark[N];//flag作为标记以控制输出格式\n    scanf(\"%d\",&n);\n    memset(mark,-1,sizeof(mark));//mark数组初始化为-1\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&r);\n        mark[r] = 0;//输入以数组下标形式存入数组mark\n    }\n    for(r = 2; r <= 100; r++){\n        j = r;\n        if(mark[j] == 0){\n            do{\n                if(j % 2 == 0){\n                    //下面的if条件中加上j < 100是为了\n                    //防止数组下标越界\n                    j /= 2;\n                    if(j<100){\n                       mark[j] = 1;\n                    }\n                }\n                else{\n                    j = 3 * j + 1;\n                }\n            }while(j != 2);\n        }\n    }\n    for(i = 100; i > 1; i--){\n        //flag==0时为第一次输出数据，其前面不需加空格\n        //flag==1时为第二次以上输出数据，前面加一空格\n        if((mark[i] == 0)&&(flag == 0)){\n            printf(\"%d\",i);\n            flag = 1;\n        }\n        else if((mark[i] == 0)&&(flag == 1)){\n            printf(\" %d\",i);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1005\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1005","published":1,"updated":"2019-08-16T13:48:37.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx82a000owtfkh65qlpya","content":"<h1 id=\"继续-3n-1-猜想\"><a href=\"#继续-3n-1-猜想\" class=\"headerlink\" title=\"继续(3n+1)猜想\"></a><strong>继续(3n+1)猜想</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。<br>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。<br>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 <em>K</em> (&lt;100)，第 2 行给出 <em>K</em> 个互不相同的待验证的正整数 <em>n</em> (1&lt;<em>n</em>≤100)的值，数字间用空格隔开。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">3 5 6 7 8 11</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 6</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>解决此题的关键是<em>散列思想</em>，输入格式给出的n的范围已经暗示了这一思想。</p>\n<ol>\n<li>用一个标记数组mark（初始化为-1），将输入的每个待判定的数（各数互不相同）作为数组的下标，输入一个r，就把mark[r]的值置为0；</li>\n<li>然后按照从小到大的顺序（想一想为什么从小到大呢？若从大到小呢？其实是一样的）对每个待检测的数（mark[r]==0的r）找r在砍的时候遇到的数j（比如3在砍的时候会依次遇到5、8、4、2、1），并把mark[j]置为1；</li>\n<li>重复过程2，最后从大到小输出mark数组中mark[r]==0的r，即为题目要求的按从大到小的顺序输出关键数字。</li>\n</ol>\n<p><code>注</code>：之前在提交时，部分数据出现了段错误(一般是数组下标越界或栈溢出等引起)，费了好大劲才找到错误（低级错误），错误如下，希望大家不要出现我这种错误。</p>\n<p>判断j在砍的时候遇到的数时（错误代码）：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&amp;&amp;(j / <span class=\"number\">2</span> &lt; <span class=\"number\">100</span>))&#123;</span><br><span class=\"line\">    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>更正后：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j &lt; <span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">        mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><ul>\n<li>非顺序输出情况下，各个数之间有空格，最后一个数后无空格。借助flag作标记即可</li>\n</ul>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>memset函数（对数组的每一个元素赋相同的值）格式为：memset(数组名，值，sizeof(数组名));使用memset时，需要在程序开头添加 <code>string.h</code> 头文件。初学者最好只用memset给数组赋-1或0，因为-1二进制补码为全1，0的二进制补码为全0，而memset是按字节赋值的。</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,r,j,flag = <span class=\"number\">0</span>,mark[N];<span class=\"comment\">//flag作为标记以控制输出格式</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(mark,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(mark));<span class=\"comment\">//mark数组初始化为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;r);</span><br><span class=\"line\">        mark[r] = <span class=\"number\">0</span>;<span class=\"comment\">//输入以数组下标形式存入数组mark</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(r = <span class=\"number\">2</span>; r &lt;= <span class=\"number\">100</span>; r++)&#123;</span><br><span class=\"line\">        j = r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mark[j] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//下面的if条件中加上j &lt; 100是为了</span></span><br><span class=\"line\">                    <span class=\"comment\">//防止数组下标越界</span></span><br><span class=\"line\">                    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                       mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">while</span>(j != <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">100</span>; i &gt; <span class=\"number\">1</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//flag==0时为第一次输出数据，其前面不需加空格</span></span><br><span class=\"line\">        <span class=\"comment\">//flag==1时为第二次以上输出数据，前面加一空格</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((mark[i] == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((mark[i] == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1005<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"继续-3n-1-猜想\"><a href=\"#继续-3n-1-猜想\" class=\"headerlink\" title=\"继续(3n+1)猜想\"></a><strong>继续(3n+1)猜想</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。<br>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。<br>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 <em>K</em> (&lt;100)，第 2 行给出 <em>K</em> 个互不相同的待验证的正整数 <em>n</em> (1&lt;<em>n</em>≤100)的值，数字间用空格隔开。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">3 5 6 7 8 11</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 6</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>解决此题的关键是<em>散列思想</em>，输入格式给出的n的范围已经暗示了这一思想。</p>\n<ol>\n<li>用一个标记数组mark（初始化为-1），将输入的每个待判定的数（各数互不相同）作为数组的下标，输入一个r，就把mark[r]的值置为0；</li>\n<li>然后按照从小到大的顺序（想一想为什么从小到大呢？若从大到小呢？其实是一样的）对每个待检测的数（mark[r]==0的r）找r在砍的时候遇到的数j（比如3在砍的时候会依次遇到5、8、4、2、1），并把mark[j]置为1；</li>\n<li>重复过程2，最后从大到小输出mark数组中mark[r]==0的r，即为题目要求的按从大到小的顺序输出关键数字。</li>\n</ol>\n<p><code>注</code>：之前在提交时，部分数据出现了段错误(一般是数组下标越界或栈溢出等引起)，费了好大劲才找到错误（低级错误），错误如下，希望大家不要出现我这种错误。</p>\n<p>判断j在砍的时候遇到的数时（错误代码）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&amp;&amp;(j / <span class=\"number\">2</span> &lt; <span class=\"number\">100</span>))&#123;</span><br><span class=\"line\">    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更正后：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j &lt; <span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">        mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><ul>\n<li>非顺序输出情况下，各个数之间有空格，最后一个数后无空格。借助flag作标记即可</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>memset函数（对数组的每一个元素赋相同的值）格式为：memset(数组名，值，sizeof(数组名));使用memset时，需要在程序开头添加 <code>string.h</code> 头文件。初学者最好只用memset给数组赋-1或0，因为-1二进制补码为全1，0的二进制补码为全0，而memset是按字节赋值的。</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,r,j,flag = <span class=\"number\">0</span>,mark[N];<span class=\"comment\">//flag作为标记以控制输出格式</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(mark,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(mark));<span class=\"comment\">//mark数组初始化为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;r);</span><br><span class=\"line\">        mark[r] = <span class=\"number\">0</span>;<span class=\"comment\">//输入以数组下标形式存入数组mark</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(r = <span class=\"number\">2</span>; r &lt;= <span class=\"number\">100</span>; r++)&#123;</span><br><span class=\"line\">        j = r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mark[j] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//下面的if条件中加上j &lt; 100是为了</span></span><br><span class=\"line\">                    <span class=\"comment\">//防止数组下标越界</span></span><br><span class=\"line\">                    j /= <span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                       mark[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    j = <span class=\"number\">3</span> * j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">while</span>(j != <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">100</span>; i &gt; <span class=\"number\">1</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//flag==0时为第一次输出数据，其前面不需加空格</span></span><br><span class=\"line\">        <span class=\"comment\">//flag==1时为第二次以上输出数据，前面加一空格</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((mark[i] == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((mark[i] == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1005<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1006 || 换个格式输出整数（详解，C/C++示例，测试点分析）","date":"2019-08-14T04:37:22.000Z","_content":"\n# **换个格式输出整数**\n## **题目描述**\n让我们用字母 `B` 来表示“百”、字母 `S` 表示“十”，用 `12...n` 来表示不为零的个位数字 `n`（<10），换个格式来输出任一个不超过 3 位的正整数。例如 `234` 应该被输出为 `BBSSS1234`，因为它有 2 个“百”、3 个“十”、以及个位的 4。\n## **输入格式**\n## **输入格式**\n每个测试输入包含 1 个测试用例，给出正整数 *n*（<1000）。\n## **输出格式**\n每个测试用例的输出占一行，用规定的格式输出 *n*。\n## **输入样例**\n```null\n234\n```\n## **输出样例**\n```null\nBBSSS1234\n```\n\n## 问题解决\n\n### 解题思想\n\n如果会提取一个多位数的各位数字，那么此题就没有什么难度。\n\n### 知识拓展\n循环n次可以用for循环，也可以用while简洁的方式。\n\n```c\nfor(i = 0; i < n; i++){\n    //循环体\n}\n```\nwhile更简洁形式\n\n```c\nwhile(n--){\n    //循环体\n}\n```\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\nint main()\n{\n    int n,i,h,t,u;\n    scanf(\"%d\",&n);\n    h = n / 100;//百位\n    t = (n % 100) / 10;//十位\n    u = n % 10;//个位\n    for(i = 0; i < h; i++){\n        printf(\"B\");\n    }\n    for(i = 0; i < t; i++){\n        printf(\"S\");\n    }\n    for(i = 0; i < u; i++){\n        printf(\"%d\",i+1);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1006\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1006.md","raw":"---\ntitle: PAT乙级1006 || 换个格式输出整数（详解，C/C++示例，测试点分析）\ndate: 2019-08-14 12:37:22\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **换个格式输出整数**\n## **题目描述**\n让我们用字母 `B` 来表示“百”、字母 `S` 表示“十”，用 `12...n` 来表示不为零的个位数字 `n`（<10），换个格式来输出任一个不超过 3 位的正整数。例如 `234` 应该被输出为 `BBSSS1234`，因为它有 2 个“百”、3 个“十”、以及个位的 4。\n## **输入格式**\n## **输入格式**\n每个测试输入包含 1 个测试用例，给出正整数 *n*（<1000）。\n## **输出格式**\n每个测试用例的输出占一行，用规定的格式输出 *n*。\n## **输入样例**\n```null\n234\n```\n## **输出样例**\n```null\nBBSSS1234\n```\n\n## 问题解决\n\n### 解题思想\n\n如果会提取一个多位数的各位数字，那么此题就没有什么难度。\n\n### 知识拓展\n循环n次可以用for循环，也可以用while简洁的方式。\n\n```c\nfor(i = 0; i < n; i++){\n    //循环体\n}\n```\nwhile更简洁形式\n\n```c\nwhile(n--){\n    //循环体\n}\n```\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\nint main()\n{\n    int n,i,h,t,u;\n    scanf(\"%d\",&n);\n    h = n / 100;//百位\n    t = (n % 100) / 10;//十位\n    u = n % 10;//个位\n    for(i = 0; i < h; i++){\n        printf(\"B\");\n    }\n    for(i = 0; i < t; i++){\n        printf(\"S\");\n    }\n    for(i = 0; i < u; i++){\n        printf(\"%d\",i+1);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1006\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1006","published":1,"updated":"2019-08-16T13:48:37.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx82b000qwtfk8rkxjic5","content":"<h1 id=\"换个格式输出整数\"><a href=\"#换个格式输出整数\" class=\"headerlink\" title=\"换个格式输出整数\"></a><strong>换个格式输出整数</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>让我们用字母 <code>B</code> 来表示“百”、字母 <code>S</code> 表示“十”，用 <code>12...n</code> 来表示不为零的个位数字 <code>n</code>（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 <code>234</code> 应该被输出为 <code>BBSSS1234</code>，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><h2 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，给出正整数 <em>n</em>（&lt;1000）。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，用规定的格式输出 <em>n</em>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">234</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BBSSS1234</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>如果会提取一个多位数的各位数字，那么此题就没有什么难度。</p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>循环n次可以用for循环，也可以用while简洁的方式。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//循环体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>while更简洁形式</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//循环体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,h,t,u;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    h = n / <span class=\"number\">100</span>;<span class=\"comment\">//百位</span></span><br><span class=\"line\">    t = (n % <span class=\"number\">100</span>) / <span class=\"number\">10</span>;<span class=\"comment\">//十位</span></span><br><span class=\"line\">    u = n % <span class=\"number\">10</span>;<span class=\"comment\">//个位</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; t; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"S\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; u; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1006<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"换个格式输出整数\"><a href=\"#换个格式输出整数\" class=\"headerlink\" title=\"换个格式输出整数\"></a><strong>换个格式输出整数</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>让我们用字母 <code>B</code> 来表示“百”、字母 <code>S</code> 表示“十”，用 <code>12...n</code> 来表示不为零的个位数字 <code>n</code>（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 <code>234</code> 应该被输出为 <code>BBSSS1234</code>，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><h2 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个测试输入包含 1 个测试用例，给出正整数 <em>n</em>（&lt;1000）。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，用规定的格式输出 <em>n</em>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">234</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BBSSS1234</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>如果会提取一个多位数的各位数字，那么此题就没有什么难度。</p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>循环n次可以用for循环，也可以用while简洁的方式。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//循环体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>while更简洁形式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//循环体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,h,t,u;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    h = n / <span class=\"number\">100</span>;<span class=\"comment\">//百位</span></span><br><span class=\"line\">    t = (n % <span class=\"number\">100</span>) / <span class=\"number\">10</span>;<span class=\"comment\">//十位</span></span><br><span class=\"line\">    u = n % <span class=\"number\">10</span>;<span class=\"comment\">//个位</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; t; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"S\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; u; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,i+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1006<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1007 || 素数对猜想（详解，C/C++示例，测试点分析）","date":"2019-08-15T04:19:52.000Z","mathjax":true,"_content":"\n# **素数对猜想**\n## **题目描述**\n让我们定义$d_n$为：$d_n$=p(n+1)-p(n)，其中p(i)是第 $i$ 个素数。显然有$d_1$=1，且对于 $n>1$ 有$d_n$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。\n现给定任意正整数`N`(<$10^5$)，请计算不超过`N`的满足猜想的素数对的个数。\n\n## **输入格式**\n输入在一行给出正整数`N`。\n## **输出格式**\n在一行中输出不超过`N`的满足猜想的素数对的个数。\n## **输入样例**\n```null\n20\n```\n## **输出样例**\n```null\n4\n```\n\n## 问题解决\n\n### 解题思想\n\n此题的关键点为：\n\n* 判断一个数i是否为素数\n* 记录下刚刚判断的最近邻的素数\n\n判定i是否为素数这里我们用判断 $i$ 能够被$2 - \\sqrt{i}$中的某个数所整除，如果$2 - \\sqrt{i}$中存在一个数能整除 $i$，则i就不是素数；反之，如果$2 - \\sqrt{i}$中没有能整除 $i​$ 的数，则i就是素数。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <math.h>\nint main()\n{\n    int n,i,j,pre_prime,count = 0,flag;\n    scanf(\"%d\",&n);\n    pre_prime = 2;//初始化上一个素数为2\n    for(i = 3; i <= n; i++){//当前素数的判定从3开始\n        flag = 0;\n        for(j = 2; j <= sqrt(i); j++){\n            if(i % j == 0){\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0){\n            //如果i是素数（即flag == 0）\n            //且当前素数与上一个素数差为2\n            if(i-pre_prime == 2){\n                count++;\n            }\n            pre_prime = i;//更新上一个素数为当前素数\n        }\n    }\n    printf(\"%d\\n\",count);\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1007\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1007.md","raw":"---\ntitle: PAT乙级1007 || 素数对猜想（详解，C/C++示例，测试点分析）\ndate: 2019-08-15 12:19:52\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **素数对猜想**\n## **题目描述**\n让我们定义$d_n$为：$d_n$=p(n+1)-p(n)，其中p(i)是第 $i$ 个素数。显然有$d_1$=1，且对于 $n>1$ 有$d_n$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。\n现给定任意正整数`N`(<$10^5$)，请计算不超过`N`的满足猜想的素数对的个数。\n\n## **输入格式**\n输入在一行给出正整数`N`。\n## **输出格式**\n在一行中输出不超过`N`的满足猜想的素数对的个数。\n## **输入样例**\n```null\n20\n```\n## **输出样例**\n```null\n4\n```\n\n## 问题解决\n\n### 解题思想\n\n此题的关键点为：\n\n* 判断一个数i是否为素数\n* 记录下刚刚判断的最近邻的素数\n\n判定i是否为素数这里我们用判断 $i$ 能够被$2 - \\sqrt{i}$中的某个数所整除，如果$2 - \\sqrt{i}$中存在一个数能整除 $i$，则i就不是素数；反之，如果$2 - \\sqrt{i}$中没有能整除 $i​$ 的数，则i就是素数。\n\n### 代码示例（C）\n\n```c\n#include <stdio.h>\n#include <math.h>\nint main()\n{\n    int n,i,j,pre_prime,count = 0,flag;\n    scanf(\"%d\",&n);\n    pre_prime = 2;//初始化上一个素数为2\n    for(i = 3; i <= n; i++){//当前素数的判定从3开始\n        flag = 0;\n        for(j = 2; j <= sqrt(i); j++){\n            if(i % j == 0){\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0){\n            //如果i是素数（即flag == 0）\n            //且当前素数与上一个素数差为2\n            if(i-pre_prime == 2){\n                count++;\n            }\n            pre_prime = i;//更新上一个素数为当前素数\n        }\n    }\n    printf(\"%d\\n\",count);\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1007\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1007","published":1,"updated":"2019-08-16T13:48:37.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx82d000uwtfkc6rtmpdt","content":"<h1 id=\"素数对猜想\"><a href=\"#素数对猜想\" class=\"headerlink\" title=\"素数对猜想\"></a><strong>素数对猜想</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>让我们定义$d_n$为：$d_n$=p(n+1)-p(n)，其中p(i)是第 $i$ 个素数。显然有$d_1$=1，且对于 $n&gt;1$ 有$d_n$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。<br>现给定任意正整数<code>N</code>(&lt;$10^5$)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行给出正整数<code>N</code>。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题的关键点为：</p>\n<ul>\n<li>判断一个数i是否为素数</li>\n<li>记录下刚刚判断的最近邻的素数</li>\n</ul>\n<p>判定i是否为素数这里我们用判断 $i$ 能够被$2 - \\sqrt{i}$中的某个数所整除，如果$2 - \\sqrt{i}$中存在一个数能整除 $i$，则i就不是素数；反之，如果$2 - \\sqrt{i}$中没有能整除 $i​$ 的数，则i就是素数。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,j,pre_prime,count = <span class=\"number\">0</span>,flag;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    pre_prime = <span class=\"number\">2</span>;<span class=\"comment\">//初始化上一个素数为2</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;<span class=\"comment\">//当前素数的判定从3开始</span></span><br><span class=\"line\">        flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">2</span>; j &lt;= <span class=\"built_in\">sqrt</span>(i); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i % j == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果i是素数（即flag == 0）</span></span><br><span class=\"line\">            <span class=\"comment\">//且当前素数与上一个素数差为2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i-pre_prime == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre_prime = i;<span class=\"comment\">//更新上一个素数为当前素数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1007<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"素数对猜想\"><a href=\"#素数对猜想\" class=\"headerlink\" title=\"素数对猜想\"></a><strong>素数对猜想</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>让我们定义$d_n$为：$d_n$=p(n+1)-p(n)，其中p(i)是第 $i$ 个素数。显然有$d_1$=1，且对于 $n&gt;1$ 有$d_n$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。<br>现给定任意正整数<code>N</code>(&lt;$10^5$)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>输入在一行给出正整数<code>N</code>。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>此题的关键点为：</p>\n<ul>\n<li>判断一个数i是否为素数</li>\n<li>记录下刚刚判断的最近邻的素数</li>\n</ul>\n<p>判定i是否为素数这里我们用判断 $i$ 能够被$2 - \\sqrt{i}$中的某个数所整除，如果$2 - \\sqrt{i}$中存在一个数能整除 $i$，则i就不是素数；反之，如果$2 - \\sqrt{i}$中没有能整除 $i​$ 的数，则i就是素数。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,i,j,pre_prime,count = <span class=\"number\">0</span>,flag;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    pre_prime = <span class=\"number\">2</span>;<span class=\"comment\">//初始化上一个素数为2</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;<span class=\"comment\">//当前素数的判定从3开始</span></span><br><span class=\"line\">        flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">2</span>; j &lt;= <span class=\"built_in\">sqrt</span>(i); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i % j == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果i是素数（即flag == 0）</span></span><br><span class=\"line\">            <span class=\"comment\">//且当前素数与上一个素数差为2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i-pre_prime == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre_prime = i;<span class=\"comment\">//更新上一个素数为当前素数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1007<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1008 || 数组元素循环右移问题（详解，C/C++示例，测试点分析）","date":"2019-08-15T04:20:10.000Z","_content":"\n# **数组元素循环右移问题**\n## **题目描述**\n一个数组A中存有N（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A(0),A(1),...,A(N-1))变换为（A(N-M),...,A(N-1),A(0),A(1),...,A(N-M-1)）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？\n## **输入格式**\n每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。\n## **输出格式**\n在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n## **输入样例**\n```null\n6 2\n1 2 3 4 5 6\n```\n## **输出样例**\n```null\n5 6 1 2 3 4\n```\n\n## 问题解决\n\n### 解题思想\n*方法1* (见下面`代码1`)\n题目要求不能用辅助数组，但是由于只需要输出循环右移后的结果，因此，可以“投机取巧”地控制输出就行，这样就比较水了。\n\n*方法2* (见下面`代码2`)\n其实，本题也有高逼格的算法，采用逆置的思想，具体过程如下：\n\n*  对数组a[0],a[1],...,a[n-m-1],a[n-m],...,a[n-1]进行原地逆置得到数组a[n-1],...,a[n-m],a[n-m-1],...,a[1],a[0];\n*  对逆置后的数组的前m个元素进行原地逆置得到a[n-m],...,a[n-1];\n*  对逆置后的数组的后n-m个元素进行原地逆置得到a[0],a[1],...,a[n-m-1];\n*  对上面两个子序列分别逆置后便可得到对原数组循环右移m位的结果。\n\n### 代码示例（C）\n\n`代码1`\n\n```c\n#include <stdio.h>\n#define MAXN 101\nint main()\n{\n    int n,m,i,a[MAXN],flag = 0;//用flag作标记控制输出格式\n    scanf(\"%d%d\",&n,&m);\n    m = m % n;//这一点容易忽略，题目中只给出了M>=0，而没有\n              //说明M与N的大小关系，M是可以大于N的，M大于N\n              //时，右移M位与右移M % N位是等效的\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&a[i]);\n    }\n    for(i = n-m; i < n; i++){\n        if(flag == 0){\n            printf(\"%d\",a[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %d\",a[i]);\n        }\n    }\n    for(i = 0; i < n-m; i++){\n        if(flag == 0){\n            printf(\"%d\",a[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %d\",a[i]);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n`代码2`\n```c\n#include <stdio.h>\n#define MAXN 101\nvoid Reverse_Array(int a[],int start,int stop);\nint main()\n{\n    int n,m,i,a[MAXN];\n    scanf(\"%d%d\",&n,&m);\n    m = m % n;\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&a[i]);\n    }\n    Reverse_Array(a,0,n-1);\n    Reverse_Array(a,0,m-1);\n    Reverse_Array(a,m,n-1);\n    for(i = 0; i < n; i++){\n        printf(\"%d\",a[i]);\n        if(i != n-1){\n            printf(\" \");\n        }\n    }\n    return 0;\n}\n//逆置函数——将数组从下标start位置到stop位置原地逆置\nvoid Reverse_Array(int a[],int start,int stop)\n{\n    int temp;\n    while(start < stop){\n        temp = a[start];\n        a[start] = a[stop];\n        a[stop] = temp;\n        start++;\n        stop--;\n    }\n}\n```\n\n>题目来源：PAT乙级1008\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1008.md","raw":"---\ntitle: PAT乙级1008 || 数组元素循环右移问题（详解，C/C++示例，测试点分析）\ndate: 2019-08-15 12:20:10\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **数组元素循环右移问题**\n## **题目描述**\n一个数组A中存有N（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A(0),A(1),...,A(N-1))变换为（A(N-M),...,A(N-1),A(0),A(1),...,A(N-M-1)）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？\n## **输入格式**\n每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。\n## **输出格式**\n在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n## **输入样例**\n```null\n6 2\n1 2 3 4 5 6\n```\n## **输出样例**\n```null\n5 6 1 2 3 4\n```\n\n## 问题解决\n\n### 解题思想\n*方法1* (见下面`代码1`)\n题目要求不能用辅助数组，但是由于只需要输出循环右移后的结果，因此，可以“投机取巧”地控制输出就行，这样就比较水了。\n\n*方法2* (见下面`代码2`)\n其实，本题也有高逼格的算法，采用逆置的思想，具体过程如下：\n\n*  对数组a[0],a[1],...,a[n-m-1],a[n-m],...,a[n-1]进行原地逆置得到数组a[n-1],...,a[n-m],a[n-m-1],...,a[1],a[0];\n*  对逆置后的数组的前m个元素进行原地逆置得到a[n-m],...,a[n-1];\n*  对逆置后的数组的后n-m个元素进行原地逆置得到a[0],a[1],...,a[n-m-1];\n*  对上面两个子序列分别逆置后便可得到对原数组循环右移m位的结果。\n\n### 代码示例（C）\n\n`代码1`\n\n```c\n#include <stdio.h>\n#define MAXN 101\nint main()\n{\n    int n,m,i,a[MAXN],flag = 0;//用flag作标记控制输出格式\n    scanf(\"%d%d\",&n,&m);\n    m = m % n;//这一点容易忽略，题目中只给出了M>=0，而没有\n              //说明M与N的大小关系，M是可以大于N的，M大于N\n              //时，右移M位与右移M % N位是等效的\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&a[i]);\n    }\n    for(i = n-m; i < n; i++){\n        if(flag == 0){\n            printf(\"%d\",a[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %d\",a[i]);\n        }\n    }\n    for(i = 0; i < n-m; i++){\n        if(flag == 0){\n            printf(\"%d\",a[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %d\",a[i]);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n`代码2`\n```c\n#include <stdio.h>\n#define MAXN 101\nvoid Reverse_Array(int a[],int start,int stop);\nint main()\n{\n    int n,m,i,a[MAXN];\n    scanf(\"%d%d\",&n,&m);\n    m = m % n;\n    for(i = 0; i < n; i++){\n        scanf(\"%d\",&a[i]);\n    }\n    Reverse_Array(a,0,n-1);\n    Reverse_Array(a,0,m-1);\n    Reverse_Array(a,m,n-1);\n    for(i = 0; i < n; i++){\n        printf(\"%d\",a[i]);\n        if(i != n-1){\n            printf(\" \");\n        }\n    }\n    return 0;\n}\n//逆置函数——将数组从下标start位置到stop位置原地逆置\nvoid Reverse_Array(int a[],int start,int stop)\n{\n    int temp;\n    while(start < stop){\n        temp = a[start];\n        a[start] = a[stop];\n        a[stop] = temp;\n        start++;\n        stop--;\n    }\n}\n```\n\n>题目来源：PAT乙级1008\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1008","published":1,"updated":"2019-08-16T13:51:59.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx82d000wwtfksjh7mo6b","content":"<h1 id=\"数组元素循环右移问题\"><a href=\"#数组元素循环右移问题\" class=\"headerlink\" title=\"数组元素循环右移问题\"></a><strong>数组元素循环右移问题</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A(0),A(1),…,A(N-1))变换为（A(N-M),…,A(N-1),A(0),A(1),…,A(N-M-1)）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 2</span><br><span class=\"line\">1 2 3 4 5 6</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 6 1 2 3 4</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p><em>方法1</em> (见下面<code>代码1</code>)<br>题目要求不能用辅助数组，但是由于只需要输出循环右移后的结果，因此，可以“投机取巧”地控制输出就行，这样就比较水了。</p>\n<p><em>方法2</em> (见下面<code>代码2</code>)<br>其实，本题也有高逼格的算法，采用逆置的思想，具体过程如下：</p>\n<ul>\n<li>对数组a[0],a[1],…,a[n-m-1],a[n-m],…,a[n-1]进行原地逆置得到数组a[n-1],…,a[n-m],a[n-m-1],…,a[1],a[0];</li>\n<li>对逆置后的数组的前m个元素进行原地逆置得到a[n-m],…,a[n-1];</li>\n<li>对逆置后的数组的后n-m个元素进行原地逆置得到a[0],a[1],…,a[n-m-1];</li>\n<li>对上面两个子序列分别逆置后便可得到对原数组循环右移m位的结果。</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><p><code>代码1</code></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,m,i,a[MAXN],flag = <span class=\"number\">0</span>;<span class=\"comment\">//用flag作标记控制输出格式</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    m = m % n;<span class=\"comment\">//这一点容易忽略，题目中只给出了M&gt;=0，而没有</span></span><br><span class=\"line\">              <span class=\"comment\">//说明M与N的大小关系，M是可以大于N的，M大于N</span></span><br><span class=\"line\">              <span class=\"comment\">//时，右移M位与右移M % N位是等效的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = n-m; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n-m; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p><code>代码2</code><br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_Array</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> stop)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,m,i,a[MAXN];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    m = m % n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Reverse_Array(a,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    Reverse_Array(a,<span class=\"number\">0</span>,m<span class=\"number\">-1</span>);</span><br><span class=\"line\">    Reverse_Array(a,m,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i != n<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//逆置函数——将数组从下标start位置到stop位置原地逆置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_Array</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> stop)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(start &lt; stop)&#123;</span><br><span class=\"line\">        temp = a[start];</span><br><span class=\"line\">        a[start] = a[stop];</span><br><span class=\"line\">        a[stop] = temp;</span><br><span class=\"line\">        start++;</span><br><span class=\"line\">        stop--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></p>\n<blockquote>\n<p>题目来源：PAT乙级1008<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组元素循环右移问题\"><a href=\"#数组元素循环右移问题\" class=\"headerlink\" title=\"数组元素循环右移问题\"></a><strong>数组元素循环右移问题</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A(0),A(1),…,A(N-1))变换为（A(N-M),…,A(N-1),A(0),A(1),…,A(N-M-1)）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 2</span><br><span class=\"line\">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 6 1 2 3 4</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p><em>方法1</em> (见下面<code>代码1</code>)<br>题目要求不能用辅助数组，但是由于只需要输出循环右移后的结果，因此，可以“投机取巧”地控制输出就行，这样就比较水了。</p>\n<p><em>方法2</em> (见下面<code>代码2</code>)<br>其实，本题也有高逼格的算法，采用逆置的思想，具体过程如下：</p>\n<ul>\n<li>对数组a[0],a[1],…,a[n-m-1],a[n-m],…,a[n-1]进行原地逆置得到数组a[n-1],…,a[n-m],a[n-m-1],…,a[1],a[0];</li>\n<li>对逆置后的数组的前m个元素进行原地逆置得到a[n-m],…,a[n-1];</li>\n<li>对逆置后的数组的后n-m个元素进行原地逆置得到a[0],a[1],…,a[n-m-1];</li>\n<li>对上面两个子序列分别逆置后便可得到对原数组循环右移m位的结果。</li>\n</ul>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><p><code>代码1</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,m,i,a[MAXN],flag = <span class=\"number\">0</span>;<span class=\"comment\">//用flag作标记控制输出格式</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    m = m % n;<span class=\"comment\">//这一点容易忽略，题目中只给出了M&gt;=0，而没有</span></span><br><span class=\"line\">              <span class=\"comment\">//说明M与N的大小关系，M是可以大于N的，M大于N</span></span><br><span class=\"line\">              <span class=\"comment\">//时，右移M位与右移M % N位是等效的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = n-m; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n-m; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>,a[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>代码2</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_Array</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> stop)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,m,i,a[MAXN];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    m = m % n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Reverse_Array(a,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    Reverse_Array(a,<span class=\"number\">0</span>,m<span class=\"number\">-1</span>);</span><br><span class=\"line\">    Reverse_Array(a,m,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i != n<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//逆置函数——将数组从下标start位置到stop位置原地逆置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse_Array</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> stop)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(start &lt; stop)&#123;</span><br><span class=\"line\">        temp = a[start];</span><br><span class=\"line\">        a[start] = a[stop];</span><br><span class=\"line\">        a[stop] = temp;</span><br><span class=\"line\">        start++;</span><br><span class=\"line\">        stop--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>题目来源：PAT乙级1008<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1009 || 说反话（详解，C/C++示例，测试点分析）","date":"2019-08-15T04:20:16.000Z","_content":"\n# **说反话**\n## **题目描述**\n给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。\n## **输入格式**\n测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。\n## **输出格式**\n每个测试用例的输出占一行，输出倒序后的句子。\n## **输入样例**\n```null\nHello World Here I Come\n```\n## **输出样例**\n```null\nCome I Here World Hello\n```\n\n## 问题解决\n### 解题思想\n*方法1* (见下面`代码1`)\n使用二维数组通过scanf函数输入，遇到一个空格即为一个单词的输入结束，PAT是<u>单点测试</u>，我们知道<u>多点测试</u>的评测系统经常会使用到EOF，scanf函数是有返回值的，它的返回值是其成功读入的参数的个数，scanf函数在读取文件时达到文件末尾导致的无法读取的现象会产生读入失败，读入失败时scanf函数会返回-1，C语言用EOF来表示-1，因此，可用`while(scanf(\"%s\",str[i]) != EOF)`来判断输入是否结束。\n\n**注**：此法代码虽然简单，但有一个点容易出错，如果将如下代码\n\n```c\nwhile(scanf(\"%s\",str[i]) != EOF){\n    i++\n}\n```\n\n写成：\n\n```c\nwhile(scanf(\"%s\",str[i++]) != EOF);\n```\n\n将导致评测系统评测不通过。对于此题，用上面的输入样例检测，上面代码退出循环时i的值是5，而下面的代码退出循环时i的值是6，想一想为什么？可以用笔模拟一下这个过程。\n\n*方法2* (见下面`代码2`)\n使用一维数组，在每个即将输出的单词后面加一个字符串结束符`'\\0'`（否则会输出包含此单词在内后面所有字符串，直到遇到字符串结束符`'\\0'`），用printf函数输出字符串。此法的关键点是控制好i的位置。\n\n### 代码示例（C）\n\n`代码1`\n\n```c\n#include <stdio.h>\n#define MAXN 85\nint main()\n{\n    char str[MAXN][MAXN];\n    int i = 0;\n    //使用EOF来判断输入是否结束\n    while(scanf(\"%s\",str[i]) != EOF){\n        i++;\n    }\n    i--;//i退回到最后一个单词的下标\n    while(i >= 0){\n        //注意要控制输出格式\n        printf(\"%s\",str[i]);\n        if(i > 0){\n            printf(\" \");\n        }\n        i--;\n    }\n    return 0;\n}\n\n```\n\n`代码2`\n```c\n#include <stdio.h>\n#include <string.h>\n#define MAXN 85\n\nint main()\n{\n    int i,flag = 0;\n    char str[MAXN];\n    gets(str);\n    for(i = strlen(str); i >= 0; i--){\n        //在即将输出的单词尾部加一个字符串结束符'\\0'\n        //i移过即将输出的单词\n        str[i] = '\\0';\n        while((str[i] != ' ')&&(i >= 0)){\n            i--;\n        }\n        //如果由于遇到空格退出循环，则i移至即将输出单词的第一个字符\n        if(str[i] == ' '){\n            i++;\n        }\n        //否则i < 0，则即将输出的为第一个单词，i移至其首字符\n        else{\n            i=0;\n        }\n        if(flag == 0){\n            printf(\"%s\",&str[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %s\",&str[i]);\n        }\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1009\n>作者：CHEN, Yue\n>单位：浙江大学","source":"_posts/pat1009.md","raw":"---\ntitle: PAT乙级1009 || 说反话（详解，C/C++示例，测试点分析）\ndate: 2019-08-15 12:20:16\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\n---\n\n# **说反话**\n## **题目描述**\n给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。\n## **输入格式**\n测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。\n## **输出格式**\n每个测试用例的输出占一行，输出倒序后的句子。\n## **输入样例**\n```null\nHello World Here I Come\n```\n## **输出样例**\n```null\nCome I Here World Hello\n```\n\n## 问题解决\n### 解题思想\n*方法1* (见下面`代码1`)\n使用二维数组通过scanf函数输入，遇到一个空格即为一个单词的输入结束，PAT是<u>单点测试</u>，我们知道<u>多点测试</u>的评测系统经常会使用到EOF，scanf函数是有返回值的，它的返回值是其成功读入的参数的个数，scanf函数在读取文件时达到文件末尾导致的无法读取的现象会产生读入失败，读入失败时scanf函数会返回-1，C语言用EOF来表示-1，因此，可用`while(scanf(\"%s\",str[i]) != EOF)`来判断输入是否结束。\n\n**注**：此法代码虽然简单，但有一个点容易出错，如果将如下代码\n\n```c\nwhile(scanf(\"%s\",str[i]) != EOF){\n    i++\n}\n```\n\n写成：\n\n```c\nwhile(scanf(\"%s\",str[i++]) != EOF);\n```\n\n将导致评测系统评测不通过。对于此题，用上面的输入样例检测，上面代码退出循环时i的值是5，而下面的代码退出循环时i的值是6，想一想为什么？可以用笔模拟一下这个过程。\n\n*方法2* (见下面`代码2`)\n使用一维数组，在每个即将输出的单词后面加一个字符串结束符`'\\0'`（否则会输出包含此单词在内后面所有字符串，直到遇到字符串结束符`'\\0'`），用printf函数输出字符串。此法的关键点是控制好i的位置。\n\n### 代码示例（C）\n\n`代码1`\n\n```c\n#include <stdio.h>\n#define MAXN 85\nint main()\n{\n    char str[MAXN][MAXN];\n    int i = 0;\n    //使用EOF来判断输入是否结束\n    while(scanf(\"%s\",str[i]) != EOF){\n        i++;\n    }\n    i--;//i退回到最后一个单词的下标\n    while(i >= 0){\n        //注意要控制输出格式\n        printf(\"%s\",str[i]);\n        if(i > 0){\n            printf(\" \");\n        }\n        i--;\n    }\n    return 0;\n}\n\n```\n\n`代码2`\n```c\n#include <stdio.h>\n#include <string.h>\n#define MAXN 85\n\nint main()\n{\n    int i,flag = 0;\n    char str[MAXN];\n    gets(str);\n    for(i = strlen(str); i >= 0; i--){\n        //在即将输出的单词尾部加一个字符串结束符'\\0'\n        //i移过即将输出的单词\n        str[i] = '\\0';\n        while((str[i] != ' ')&&(i >= 0)){\n            i--;\n        }\n        //如果由于遇到空格退出循环，则i移至即将输出单词的第一个字符\n        if(str[i] == ' '){\n            i++;\n        }\n        //否则i < 0，则即将输出的为第一个单词，i移至其首字符\n        else{\n            i=0;\n        }\n        if(flag == 0){\n            printf(\"%s\",&str[i]);\n            flag = 1;\n        }\n        else{\n            printf(\" %s\",&str[i]);\n        }\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1009\n>作者：CHEN, Yue\n>单位：浙江大学","slug":"pat1009","published":1,"updated":"2019-08-16T13:48:37.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx82f0011wtfkkoaehfix","content":"<h1 id=\"说反话\"><a href=\"#说反话\" class=\"headerlink\" title=\"说反话\"></a><strong>说反话</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，输出倒序后的句子。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World Here I Come</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Come I Here World Hello</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p><em>方法1</em> (见下面<code>代码1</code>)<br>使用二维数组通过scanf函数输入，遇到一个空格即为一个单词的输入结束，PAT是<u>单点测试</u>，我们知道<u>多点测试</u>的评测系统经常会使用到EOF，scanf函数是有返回值的，它的返回值是其成功读入的参数的个数，scanf函数在读取文件时达到文件末尾导致的无法读取的现象会产生读入失败，读入失败时scanf函数会返回-1，C语言用EOF来表示-1，因此，可用<code>while(scanf(&quot;%s&quot;,str[i]) != EOF)</code>来判断输入是否结束。</p>\n<p><strong>注</strong>：此法代码虽然简单，但有一个点容易出错，如果将如下代码</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>写成：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i++]) != EOF);</span><br></pre></td></tr></table></figure></div>\n<p>将导致评测系统评测不通过。对于此题，用上面的输入样例检测，上面代码退出循环时i的值是5，而下面的代码退出循环时i的值是6，想一想为什么？可以用笔模拟一下这个过程。</p>\n<p><em>方法2</em> (见下面<code>代码2</code>)<br>使用一维数组，在每个即将输出的单词后面加一个字符串结束符<code>&#39;\\0&#39;</code>（否则会输出包含此单词在内后面所有字符串，直到遇到字符串结束符<code>&#39;\\0&#39;</code>），用printf函数输出字符串。此法的关键点是控制好i的位置。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><p><code>代码1</code></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 85</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[MAXN][MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//使用EOF来判断输入是否结束</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i--;<span class=\"comment\">//i退回到最后一个单词的下标</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意要控制输出格式</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,str[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p><code>代码2</code><br><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 85</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[MAXN];</span><br><span class=\"line\">    gets(str);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"built_in\">strlen</span>(str); i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//在即将输出的单词尾部加一个字符串结束符'\\0'</span></span><br><span class=\"line\">        <span class=\"comment\">//i移过即将输出的单词</span></span><br><span class=\"line\">        str[i] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>((str[i] != <span class=\"string\">' '</span>)&amp;&amp;(i &gt;= <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果由于遇到空格退出循环，则i移至即将输出单词的第一个字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[i] == <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则i &lt; 0，则即将输出的为第一个单词，i移至其首字符</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,&amp;str[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %s\"</span>,&amp;str[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></p>\n<blockquote>\n<p>题目来源：PAT乙级1009<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说反话\"><a href=\"#说反话\" class=\"headerlink\" title=\"说反话\"></a><strong>说反话</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>每个测试用例的输出占一行，输出倒序后的句子。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World Here I Come</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Come I Here World Hello</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p><em>方法1</em> (见下面<code>代码1</code>)<br>使用二维数组通过scanf函数输入，遇到一个空格即为一个单词的输入结束，PAT是<u>单点测试</u>，我们知道<u>多点测试</u>的评测系统经常会使用到EOF，scanf函数是有返回值的，它的返回值是其成功读入的参数的个数，scanf函数在读取文件时达到文件末尾导致的无法读取的现象会产生读入失败，读入失败时scanf函数会返回-1，C语言用EOF来表示-1，因此，可用<code>while(scanf(&quot;%s&quot;,str[i]) != EOF)</code>来判断输入是否结束。</p>\n<p><strong>注</strong>：此法代码虽然简单，但有一个点容易出错，如果将如下代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i++]) != EOF);</span><br></pre></td></tr></table></figure>\n<p>将导致评测系统评测不通过。对于此题，用上面的输入样例检测，上面代码退出循环时i的值是5，而下面的代码退出循环时i的值是6，想一想为什么？可以用笔模拟一下这个过程。</p>\n<p><em>方法2</em> (见下面<code>代码2</code>)<br>使用一维数组，在每个即将输出的单词后面加一个字符串结束符<code>&#39;\\0&#39;</code>（否则会输出包含此单词在内后面所有字符串，直到遇到字符串结束符<code>&#39;\\0&#39;</code>），用printf函数输出字符串。此法的关键点是控制好i的位置。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><p><code>代码1</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 85</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[MAXN][MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//使用EOF来判断输入是否结束</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i--;<span class=\"comment\">//i退回到最后一个单词的下标</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意要控制输出格式</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,str[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>代码2</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 85</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[MAXN];</span><br><span class=\"line\">    gets(str);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"built_in\">strlen</span>(str); i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//在即将输出的单词尾部加一个字符串结束符'\\0'</span></span><br><span class=\"line\">        <span class=\"comment\">//i移过即将输出的单词</span></span><br><span class=\"line\">        str[i] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>((str[i] != <span class=\"string\">' '</span>)&amp;&amp;(i &gt;= <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果由于遇到空格退出循环，则i移至即将输出单词的第一个字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[i] == <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则i &lt; 0，则即将输出的为第一个单词，i移至其首字符</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,&amp;str[i]);</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %s\"</span>,&amp;str[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>题目来源：PAT乙级1009<br>作者：CHEN, Yue<br>单位：浙江大学</p>\n</blockquote>\n"},{"title":"PAT乙级1010 || 一元多项式求导（详解，C/C++示例，测试点分析）","date":"2019-08-15T04:20:24.000Z","mathjax":true,"_content":"\n# **一元多项式求导**\n## **题目描述**\n设计函数求一元多项式的导数。（注：$x^n$（*n*为整数）的一阶导数为 $n \\cdot x^{n−1}$。)\n## **输入格式**\n以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。\n## **输出格式**\n以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 `0 0`。\n## **输入样例**\n```null\n3 4 -5 2 6 1 -2 0\n```\n## **输出样例**\n```null\n12 3 -10 1 6 0\n```\n\n## 问题解决\n### 解题思想\n本题代码过程非常简单，关键点是要处理到所有的情况，可分为以下3种情况：\n* “零多项式”，求导后仍为“零多项式”，此时输出为：`0 0`\n* 非“零多项式”，求导后变为”零多项式“，此时输出为：`0 0`\n* 非“零多项式”，求导后不为”零多项式“，此时正常输出求导后的系数和指数，但不输出`0 0`\n  对于前两种情况，可用以下条件来判定：\n\n```c\nif((exp == 0)&&(flag == 0))\n```\n\nelse后即为第三种情况，但注意输出格式控制。\n\n### 知识拓展\n我们知道，可以用如下方式来判断是否输入完毕（点击进入相关讲解）：\n\n```c\nwhile(scanf(\"%s\",str[i]) != EOF){\n    //内部操作\n}\n```\n\n这次介绍一种新的方式，如下：\n\n```c\nwhile(~scanf(\"%s\",str[i++])){\n    //内部操作\n}\n```\n\n上面两种方式的效果是完全一样的，原理是什么呢？我们知道，scanf()读入失败时会返回-1，C语言用EOF来表示-1，因此也就有了上面第一种方式。而在机器内部-1的补码表示为全1，`~`是按位取反运算符，全1取反后变为全0，也就是说，当读入结束时，scanf()函数会返回机器补码为全1（也就是-1），经`~`取反后为全0，从而跳出循环。\n\n### 代码示例（C）\n\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int coe,exp,flag = 0;\n    while(~scanf(\"%d%d\",&coe,&exp)){\n        //如果多项式的第一项的指数为0，求导后即为“零多项式”，则应输出0 0\n        //用flag == 0来识别第一项\n        if((exp == 0)&&(flag == 0)){\n            printf(\"%d %d\",exp,exp);\n            break;\n        }\n        //如果第一项的指数不为0，则后面指数为0的项不必输出\n        else if(flag == 0){\n            if(exp != 0){\n                printf(\"%d %d\",coe * exp,exp - 1);\n                flag = 1;\n            }\n        }\n        else{\n            if(exp != 0){\n                printf(\" %d %d\",coe * exp,exp - 1);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1010\n>作者：DS课程组\n>单位：浙江大学","source":"_posts/pat1010.md","raw":"---\ntitle: PAT乙级1010 || 一元多项式求导（详解，C/C++示例，测试点分析）\ndate: 2019-08-15 12:20:24\ntags:\n- PAT\n- C/C++\n- 编程\ncategories:\n- PAT\nmathjax: true\n---\n\n# **一元多项式求导**\n## **题目描述**\n设计函数求一元多项式的导数。（注：$x^n$（*n*为整数）的一阶导数为 $n \\cdot x^{n−1}$。)\n## **输入格式**\n以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。\n## **输出格式**\n以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 `0 0`。\n## **输入样例**\n```null\n3 4 -5 2 6 1 -2 0\n```\n## **输出样例**\n```null\n12 3 -10 1 6 0\n```\n\n## 问题解决\n### 解题思想\n本题代码过程非常简单，关键点是要处理到所有的情况，可分为以下3种情况：\n* “零多项式”，求导后仍为“零多项式”，此时输出为：`0 0`\n* 非“零多项式”，求导后变为”零多项式“，此时输出为：`0 0`\n* 非“零多项式”，求导后不为”零多项式“，此时正常输出求导后的系数和指数，但不输出`0 0`\n  对于前两种情况，可用以下条件来判定：\n\n```c\nif((exp == 0)&&(flag == 0))\n```\n\nelse后即为第三种情况，但注意输出格式控制。\n\n### 知识拓展\n我们知道，可以用如下方式来判断是否输入完毕（点击进入相关讲解）：\n\n```c\nwhile(scanf(\"%s\",str[i]) != EOF){\n    //内部操作\n}\n```\n\n这次介绍一种新的方式，如下：\n\n```c\nwhile(~scanf(\"%s\",str[i++])){\n    //内部操作\n}\n```\n\n上面两种方式的效果是完全一样的，原理是什么呢？我们知道，scanf()读入失败时会返回-1，C语言用EOF来表示-1，因此也就有了上面第一种方式。而在机器内部-1的补码表示为全1，`~`是按位取反运算符，全1取反后变为全0，也就是说，当读入结束时，scanf()函数会返回机器补码为全1（也就是-1），经`~`取反后为全0，从而跳出循环。\n\n### 代码示例（C）\n\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int coe,exp,flag = 0;\n    while(~scanf(\"%d%d\",&coe,&exp)){\n        //如果多项式的第一项的指数为0，求导后即为“零多项式”，则应输出0 0\n        //用flag == 0来识别第一项\n        if((exp == 0)&&(flag == 0)){\n            printf(\"%d %d\",exp,exp);\n            break;\n        }\n        //如果第一项的指数不为0，则后面指数为0的项不必输出\n        else if(flag == 0){\n            if(exp != 0){\n                printf(\"%d %d\",coe * exp,exp - 1);\n                flag = 1;\n            }\n        }\n        else{\n            if(exp != 0){\n                printf(\" %d %d\",coe * exp,exp - 1);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n>题目来源：PAT乙级1010\n>作者：DS课程组\n>单位：浙江大学","slug":"pat1010","published":1,"updated":"2019-08-16T13:48:37.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzewx82g0013wtfkigvqvqvs","content":"<h1 id=\"一元多项式求导\"><a href=\"#一元多项式求导\" class=\"headerlink\" title=\"一元多项式求导\"></a><strong>一元多项式求导</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>设计函数求一元多项式的导数。（注：$x^n$（<em>n</em>为整数）的一阶导数为 $n \\cdot x^{n−1}$。)</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 <code>0 0</code>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 4 -5 2 6 1 -2 0</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight /plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12 3 -10 1 6 0</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题代码过程非常简单，关键点是要处理到所有的情况，可分为以下3种情况：</p>\n<ul>\n<li>“零多项式”，求导后仍为“零多项式”，此时输出为：<code>0 0</code></li>\n<li>非“零多项式”，求导后变为”零多项式“，此时输出为：<code>0 0</code></li>\n<li>非“零多项式”，求导后不为”零多项式“，此时正常输出求导后的系数和指数，但不输出<code>0 0</code><br>对于前两种情况，可用以下条件来判定：</li>\n</ul>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((<span class=\"built_in\">exp</span> == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure></div>\n<p>else后即为第三种情况，但注意输出格式控制。</p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>我们知道，可以用如下方式来判断是否输入完毕（点击进入相关讲解）：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//内部操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>这次介绍一种新的方式，如下：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i++]))&#123;</span><br><span class=\"line\">    <span class=\"comment\">//内部操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>上面两种方式的效果是完全一样的，原理是什么呢？我们知道，scanf()读入失败时会返回-1，C语言用EOF来表示-1，因此也就有了上面第一种方式。而在机器内部-1的补码表示为全1，<code>~</code>是按位取反运算符，全1取反后变为全0，也就是说，当读入结束时，scanf()函数会返回机器补码为全1（也就是-1），经<code>~</code>取反后为全0，从而跳出循环。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"C\"><figure class=\"iseeu highlight /c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> coe,<span class=\"built_in\">exp</span>,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;coe,&amp;<span class=\"built_in\">exp</span>))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果多项式的第一项的指数为0，求导后即为“零多项式”，则应输出0 0</span></span><br><span class=\"line\">        <span class=\"comment\">//用flag == 0来识别第一项</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((<span class=\"built_in\">exp</span> == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>,<span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果第一项的指数不为0，则后面指数为0的项不必输出</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">exp</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>,coe * <span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">exp</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d %d\"</span>,coe * <span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>题目来源：PAT乙级1010<br>作者：DS课程组<br>单位：浙江大学</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一元多项式求导\"><a href=\"#一元多项式求导\" class=\"headerlink\" title=\"一元多项式求导\"></a><strong>一元多项式求导</strong></h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><p>设计函数求一元多项式的导数。（注：$x^n$（<em>n</em>为整数）的一阶导数为 $n \\cdot x^{n−1}$。)</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h2><p>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h2><p>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 <code>0 0</code>。</p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 4 -5 2 6 1 -2 0</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12 3 -10 1 6 0</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"解题思想\"><a href=\"#解题思想\" class=\"headerlink\" title=\"解题思想\"></a>解题思想</h3><p>本题代码过程非常简单，关键点是要处理到所有的情况，可分为以下3种情况：</p>\n<ul>\n<li>“零多项式”，求导后仍为“零多项式”，此时输出为：<code>0 0</code></li>\n<li>非“零多项式”，求导后变为”零多项式“，此时输出为：<code>0 0</code></li>\n<li>非“零多项式”，求导后不为”零多项式“，此时正常输出求导后的系数和指数，但不输出<code>0 0</code><br>对于前两种情况，可用以下条件来判定：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((<span class=\"built_in\">exp</span> == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure>\n<p>else后即为第三种情况，但注意输出格式控制。</p>\n<h3 id=\"知识拓展\"><a href=\"#知识拓展\" class=\"headerlink\" title=\"知识拓展\"></a>知识拓展</h3><p>我们知道，可以用如下方式来判断是否输入完毕（点击进入相关讲解）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i]) != EOF)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//内部操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次介绍一种新的方式，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,str[i++]))&#123;</span><br><span class=\"line\">    <span class=\"comment\">//内部操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种方式的效果是完全一样的，原理是什么呢？我们知道，scanf()读入失败时会返回-1，C语言用EOF来表示-1，因此也就有了上面第一种方式。而在机器内部-1的补码表示为全1，<code>~</code>是按位取反运算符，全1取反后变为全0，也就是说，当读入结束时，scanf()函数会返回机器补码为全1（也就是-1），经<code>~</code>取反后为全0，从而跳出循环。</p>\n<h3 id=\"代码示例（C）\"><a href=\"#代码示例（C）\" class=\"headerlink\" title=\"代码示例（C）\"></a>代码示例（C）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> coe,<span class=\"built_in\">exp</span>,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;coe,&amp;<span class=\"built_in\">exp</span>))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果多项式的第一项的指数为0，求导后即为“零多项式”，则应输出0 0</span></span><br><span class=\"line\">        <span class=\"comment\">//用flag == 0来识别第一项</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((<span class=\"built_in\">exp</span> == <span class=\"number\">0</span>)&amp;&amp;(flag == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>,<span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果第一项的指数不为0，则后面指数为0的项不必输出</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">exp</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\"</span>,coe * <span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">exp</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d %d\"</span>,coe * <span class=\"built_in\">exp</span>,<span class=\"built_in\">exp</span> - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>题目来源：PAT乙级1010<br>作者：DS课程组<br>单位：浙江大学</p>\n</blockquote>\n"}],"PostAsset":[{"_id":"source/_posts/Q-HNSW/SQ量化计算示例.png","slug":"SQ量化计算示例.png","post":"cjzewx81t0000wtfk4n9i3nk2","modified":1,"renderable":0},{"_id":"source/_posts/HCNNG/directed selection1.png","post":"cjzewx81x0002wtfkhp87z45w","slug":"directed selection1.png","modified":1,"renderable":1},{"_id":"source/_posts/HCNNG/guided search2.png","post":"cjzewx81x0002wtfkhp87z45w","slug":"guided search2.png","modified":1,"renderable":1},{"_id":"source/_posts/Q-HNSW/pq.png","post":"cjzewx81t0000wtfk4n9i3nk2","slug":"pq.png","modified":1,"renderable":1},{"_id":"source/_posts/Q-HNSW/pq2.png","post":"cjzewx81t0000wtfk4n9i3nk2","slug":"pq2.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjzewx8210007wtfk18ref2kn","category_id":"cjzewx81z0004wtfkhjt2r4pe","_id":"cjzewx827000dwtfk5srnjs0d"},{"post_id":"cjzewx81t0000wtfk4n9i3nk2","category_id":"cjzewx81z0004wtfkhjt2r4pe","_id":"cjzewx828000hwtfkxffcqcl2"},{"post_id":"cjzewx8220008wtfkacsr4h8r","category_id":"cjzewx81z0004wtfkhjt2r4pe","_id":"cjzewx82a000kwtfkdcc647l5"},{"post_id":"cjzewx81x0002wtfkhp87z45w","category_id":"cjzewx81z0004wtfkhjt2r4pe","_id":"cjzewx82b000pwtfkayi7o8h4"},{"post_id":"cjzewx8200006wtfkrn402he2","category_id":"cjzewx81z0004wtfkhjt2r4pe","_id":"cjzewx82c000rwtfk4n7c517y"},{"post_id":"cjzewx82a000owtfkh65qlpya","category_id":"cjzewx82a000lwtfk3rbkk1uk","_id":"cjzewx82e000xwtfkkx004r6w"},{"post_id":"cjzewx824000bwtfkwjdpykj9","category_id":"cjzewx82a000lwtfk3rbkk1uk","_id":"cjzewx82g0012wtfktzf8trwk"},{"post_id":"cjzewx82b000qwtfk8rkxjic5","category_id":"cjzewx82a000lwtfk3rbkk1uk","_id":"cjzewx82g0014wtfkm8hw0l0t"},{"post_id":"cjzewx82d000uwtfkc6rtmpdt","category_id":"cjzewx82a000lwtfk3rbkk1uk","_id":"cjzewx82h0017wtfko2zm8rma"},{"post_id":"cjzewx825000cwtfk18af5s51","category_id":"cjzewx82a000lwtfk3rbkk1uk","_id":"cjzewx82i0018wtfktt36gzef"},{"post_id":"cjzewx82d000wwtfksjh7mo6b","category_id":"cjzewx82a000lwtfk3rbkk1uk","_id":"cjzewx82i001awtfkkp8vbyqn"},{"post_id":"cjzewx82f0011wtfkkoaehfix","category_id":"cjzewx82a000lwtfk3rbkk1uk","_id":"cjzewx82i001cwtfkvz6ztjol"},{"post_id":"cjzewx828000gwtfk7xosx3vi","category_id":"cjzewx82a000lwtfk3rbkk1uk","_id":"cjzewx82j001fwtfkx8lvgvl3"},{"post_id":"cjzewx82g0013wtfkigvqvqvs","category_id":"cjzewx82a000lwtfk3rbkk1uk","_id":"cjzewx82j001hwtfkq35o46oi"},{"post_id":"cjzewx829000jwtfku60y58d2","category_id":"cjzewx82a000lwtfk3rbkk1uk","_id":"cjzewx82j001jwtfkxg02pi11"}],"PostTag":[{"post_id":"cjzewx81t0000wtfk4n9i3nk2","tag_id":"cjzewx8200005wtfkp3lf97hj","_id":"cjzewx829000iwtfkkpep2bk3"},{"post_id":"cjzewx81t0000wtfk4n9i3nk2","tag_id":"cjzewx823000awtfk5xolqvf3","_id":"cjzewx82a000mwtfkyya9l0bc"},{"post_id":"cjzewx81x0002wtfkhp87z45w","tag_id":"cjzewx8200005wtfkp3lf97hj","_id":"cjzewx82d000vwtfk52ieqaj3"},{"post_id":"cjzewx81x0002wtfkhp87z45w","tag_id":"cjzewx823000awtfk5xolqvf3","_id":"cjzewx82e000ywtfk0k65o07v"},{"post_id":"cjzewx8200006wtfkrn402he2","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82i001bwtfk28ch9v1g"},{"post_id":"cjzewx8200006wtfkrn402he2","tag_id":"cjzewx823000awtfk5xolqvf3","_id":"cjzewx82i001dwtfkld1qidmi"},{"post_id":"cjzewx8200006wtfkrn402he2","tag_id":"cjzewx82h0016wtfk1t06b43b","_id":"cjzewx82j001gwtfk6pw1s83x"},{"post_id":"cjzewx8210007wtfk18ref2kn","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82k001lwtfkvhnbk7vr"},{"post_id":"cjzewx8210007wtfk18ref2kn","tag_id":"cjzewx823000awtfk5xolqvf3","_id":"cjzewx82k001mwtfkgcivuczx"},{"post_id":"cjzewx8210007wtfk18ref2kn","tag_id":"cjzewx82h0016wtfk1t06b43b","_id":"cjzewx82l001owtfkekfdjhno"},{"post_id":"cjzewx8220008wtfkacsr4h8r","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82l001rwtfkdao0ybxy"},{"post_id":"cjzewx8220008wtfkacsr4h8r","tag_id":"cjzewx823000awtfk5xolqvf3","_id":"cjzewx82m001swtfkq4ftv0wf"},{"post_id":"cjzewx8220008wtfkacsr4h8r","tag_id":"cjzewx82h0016wtfk1t06b43b","_id":"cjzewx82m001uwtfkb7na7tqx"},{"post_id":"cjzewx824000bwtfkwjdpykj9","tag_id":"cjzewx82l001qwtfk5o72h1dj","_id":"cjzewx82m001xwtfk5c292600"},{"post_id":"cjzewx824000bwtfkwjdpykj9","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82n001ywtfkw0efyp2r"},{"post_id":"cjzewx824000bwtfkwjdpykj9","tag_id":"cjzewx82m001vwtfks5aidlgl","_id":"cjzewx82n0020wtfkvy59uaq7"},{"post_id":"cjzewx825000cwtfk18af5s51","tag_id":"cjzewx82l001qwtfk5o72h1dj","_id":"cjzewx82o0023wtfkgoznmbxe"},{"post_id":"cjzewx825000cwtfk18af5s51","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82o0024wtfkxlcwishj"},{"post_id":"cjzewx825000cwtfk18af5s51","tag_id":"cjzewx82m001vwtfks5aidlgl","_id":"cjzewx82o0026wtfk4dfuqgzz"},{"post_id":"cjzewx828000gwtfk7xosx3vi","tag_id":"cjzewx82l001qwtfk5o72h1dj","_id":"cjzewx82q0029wtfk0krh6b0w"},{"post_id":"cjzewx828000gwtfk7xosx3vi","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82q002awtfkrgwjfa90"},{"post_id":"cjzewx828000gwtfk7xosx3vi","tag_id":"cjzewx82m001vwtfks5aidlgl","_id":"cjzewx82q002cwtfk401zcycr"},{"post_id":"cjzewx829000jwtfku60y58d2","tag_id":"cjzewx82l001qwtfk5o72h1dj","_id":"cjzewx82r002fwtfk26ikngt2"},{"post_id":"cjzewx829000jwtfku60y58d2","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82r002gwtfk147zhpyl"},{"post_id":"cjzewx829000jwtfku60y58d2","tag_id":"cjzewx82m001vwtfks5aidlgl","_id":"cjzewx82r002iwtfkdducxkdu"},{"post_id":"cjzewx82a000owtfkh65qlpya","tag_id":"cjzewx82l001qwtfk5o72h1dj","_id":"cjzewx82s002lwtfk3d7tj38i"},{"post_id":"cjzewx82a000owtfkh65qlpya","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82s002mwtfk86owm7ra"},{"post_id":"cjzewx82a000owtfkh65qlpya","tag_id":"cjzewx82m001vwtfks5aidlgl","_id":"cjzewx82t002owtfkvd6slfbj"},{"post_id":"cjzewx82b000qwtfk8rkxjic5","tag_id":"cjzewx82l001qwtfk5o72h1dj","_id":"cjzewx82u002rwtfk0xswtc7w"},{"post_id":"cjzewx82b000qwtfk8rkxjic5","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82u002swtfkq43wt6hr"},{"post_id":"cjzewx82b000qwtfk8rkxjic5","tag_id":"cjzewx82m001vwtfks5aidlgl","_id":"cjzewx82u002uwtfk362uyds7"},{"post_id":"cjzewx82d000uwtfkc6rtmpdt","tag_id":"cjzewx82l001qwtfk5o72h1dj","_id":"cjzewx82v002wwtfkt2ax3q4p"},{"post_id":"cjzewx82d000uwtfkc6rtmpdt","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82v002xwtfkbpvkprgo"},{"post_id":"cjzewx82d000uwtfkc6rtmpdt","tag_id":"cjzewx82m001vwtfks5aidlgl","_id":"cjzewx82v002zwtfkyx9wej25"},{"post_id":"cjzewx82d000wwtfksjh7mo6b","tag_id":"cjzewx82l001qwtfk5o72h1dj","_id":"cjzewx82v0031wtfka2xbb5ww"},{"post_id":"cjzewx82d000wwtfksjh7mo6b","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82v0032wtfk7xe3byxz"},{"post_id":"cjzewx82d000wwtfksjh7mo6b","tag_id":"cjzewx82m001vwtfks5aidlgl","_id":"cjzewx82w0034wtfk5q74rqtd"},{"post_id":"cjzewx82f0011wtfkkoaehfix","tag_id":"cjzewx82l001qwtfk5o72h1dj","_id":"cjzewx82w0036wtfkpjsixquh"},{"post_id":"cjzewx82f0011wtfkkoaehfix","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82w0037wtfk6ns6bx1r"},{"post_id":"cjzewx82f0011wtfkkoaehfix","tag_id":"cjzewx82m001vwtfks5aidlgl","_id":"cjzewx82x0039wtfkdb2iyrtg"},{"post_id":"cjzewx82g0013wtfkigvqvqvs","tag_id":"cjzewx82l001qwtfk5o72h1dj","_id":"cjzewx82x003awtfkdkzwwpoh"},{"post_id":"cjzewx82g0013wtfkigvqvqvs","tag_id":"cjzewx82c000twtfkwzv63ulp","_id":"cjzewx82x003bwtfk8dvr8j7h"},{"post_id":"cjzewx82g0013wtfkigvqvqvs","tag_id":"cjzewx82m001vwtfks5aidlgl","_id":"cjzewx82x003cwtfk1uqvca39"}],"Tag":[{"name":"论文阅读","_id":"cjzewx8200005wtfkp3lf97hj"},{"name":"ANNS","_id":"cjzewx823000awtfk5xolqvf3"},{"name":"C/C++","_id":"cjzewx82c000twtfkwzv63ulp"},{"name":"源码阅读","_id":"cjzewx82h0016wtfk1t06b43b"},{"name":"PAT","_id":"cjzewx82l001qwtfk5o72h1dj"},{"name":"编程","_id":"cjzewx82m001vwtfks5aidlgl"}]}}