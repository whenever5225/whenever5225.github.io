---
title: PAT乙级1005 || 继续(3n+1)猜想（详解，C/C++示例，测试点分析）
date: 2019-08-14 12:22:24
tags:
- PAT
- C/C++
- 编程
categories:
- PAT
---

# **继续(3n+1)猜想**
## **题目描述**
卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。
当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。
现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。
## **输入格式**
每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 *K* (<100)，第 2 行给出 *K* 个互不相同的待验证的正整数 *n* (1<*n*≤100)的值，数字间用空格隔开。
## **输出格式**
每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。
## **输入样例**
```null
6
3 5 6 7 8 11
```
## **输出样例**
```null
7 6
```

##  问题解决
### 解题思想
解决此题的关键是*散列思想*，输入格式给出的n的范围已经暗示了这一思想。

1. 用一个标记数组mark（初始化为-1），将输入的每个待判定的数（各数互不相同）作为数组的下标，输入一个r，就把mark[r]的值置为0；
2. 然后按照从小到大的顺序（想一想为什么从小到大呢？若从大到小呢？其实是一样的）对每个待检测的数（mark[r]==0的r）找r在砍的时候遇到的数j（比如3在砍的时候会依次遇到5、8、4、2、1），并把mark[j]置为1；
3. 重复过程2，最后从大到小输出mark数组中mark[r]==0的r，即为题目要求的按从大到小的顺序输出关键数字。

`注`：之前在提交时，部分数据出现了段错误(一般是数组下标越界或栈溢出等引起)，费了好大劲才找到错误（低级错误），错误如下，希望大家不要出现我这种错误。

判断j在砍的时候遇到的数时（错误代码）：

```c
if((j % 2 == 0)&&(j / 2 < 100)){
    j /= 2;
    mark[j] = 1;
}
else{
    j = 3 * j + 1;
}
```
更正后：

```c
if(j % 2 == 0){
    j /= 2;
    if(j < 100){
        mark[j] = 1;
    }
}
else{
    j = 3 * j + 1;
}
```
### 知识拓展
* 非顺序输出情况下，各个数之间有空格，最后一个数后无空格。借助flag作标记即可

```c
int flag = 0;
if(flag == 0){
    printf("%d",a[i]);
    flag = 1;
}
else{
    printf(" %d",a[i]);
}
```

* memset函数（对数组的每一个元素赋相同的值）格式为：memset(数组名，值，sizeof(数组名));使用memset时，需要在程序开头添加 `string.h` 头文件。初学者最好只用memset给数组赋-1或0，因为-1二进制补码为全1，0的二进制补码为全0，而memset是按字节赋值的。

### 代码示例（C）

```c
#include <stdio.h>
#include <string.h>
#define N 101
int main()
{
    int n,i,r,j,flag = 0,mark[N];//flag作为标记以控制输出格式
    scanf("%d",&n);
    memset(mark,-1,sizeof(mark));//mark数组初始化为-1
    for(i = 0; i < n; i++){
        scanf("%d",&r);
        mark[r] = 0;//输入以数组下标形式存入数组mark
    }
    for(r = 2; r <= 100; r++){
        j = r;
        if(mark[j] == 0){
            do{
                if(j % 2 == 0){
                    //下面的if条件中加上j < 100是为了
                    //防止数组下标越界
                    j /= 2;
                    if(j<100){
                       mark[j] = 1;
                    }
                }
                else{
                    j = 3 * j + 1;
                }
            }while(j != 2);
        }
    }
    for(i = 100; i > 1; i--){
        //flag==0时为第一次输出数据，其前面不需加空格
        //flag==1时为第二次以上输出数据，前面加一空格
        if((mark[i] == 0)&&(flag == 0)){
            printf("%d",i);
            flag = 1;
        }
        else if((mark[i] == 0)&&(flag == 1)){
            printf(" %d",i);
        }
    }
    printf("\n");
    return 0;
}
```

>题目来源：PAT乙级1005
>作者：CHEN, Yue
>单位：浙江大学