---
title: PAT乙级1037 || 在霍格沃茨找零钱（详解，C/C++示例，测试点分析）
date: 2019-09-30 20:21:34
tags:
- PAT
- C/C++
- 编程
categories:
- PAT
---

# **在霍格沃茨找零钱**
## **题目描述**
如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 *P* 和他实付的钱 *A*，你的任务是写一个程序来计算他应该被找的零钱。

## **输入格式**
输入在 1 行中分别给出 *P* 和 *A*，格式为 `Galleon.Sickle.Knut`，其间用 1 个空格分隔。这里 `Galleon` 是 [0, 107] 区间内的整数，`Sickle` 是 [0, 17) 区间内的整数，`Knut` 是 [0, 29) 区间内的整数。
## **输出格式**
在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。
## **输入样例1**
```null
10.16.27 14.1.28
```
## **输出样例1**
```null
3.2.1
```
## **输入样例2**
```null
14.1.28 10.16.27
```
## **输出样例2**
```null
-3.2.1
```

## 问题解决
### 解题思想
此题可类比三位十进制减法运算。Knut类比个位，Sickle类别十位，Galleon类比百位，对于三位十进制而言，无论个位、十位还是百位它们的范围都是[0, 10)，但对于 `Galleon.Sickle.Knut`而言，各位的范围均不相同。在进行减法运算时当需要借位的时候根据范围进行类比处理即可。此题可能出现小数减大数的情况，当出现时一定会有某一位为负值，此时为了方便结果处理将两数进行交换再进行相减即可，输出时加上负号。

当然此题也可以将各位统一化为某一位后再进行相减，之后再格式化为 `Galleon.Sickle.Knut`的形式。比如按它们三者的关系将Galleon和Sickle都转化为Knut，注意此时要将knut定义为long long型。

### 代码示例（C/C++）

```cpp
#include <cstdio>
using namespace std;
int main()
{
    int P[3],A[3],R[3]; //P[]为应付钱数，A[]为实付钱数，R[]为被找钱数
    scanf("%d.%d.%d",&P[2],&P[1],&P[0]);    //p[0]为Galleon，P[2]为Knut
    scanf("%d.%d.%d",&A[2],&A[1],&A[0]);
    int flag = 0;   //标记循环次数
    do{
        if(flag){   //若不止一次执行循环体则他没带够钱，交换P[]与A[]以实现大数减小数
            for(int i = 0; i < 3; i++){
                int temp = A[i];
                A[i] = P[i];
                P[i] = temp;
            }
        }
        flag++;
        if(A[0] - P[0] < 0){    //低位不足则需借位
            if(A[1] != 0){
                A[1]--;
                A[0] +=29;
            }
            else{
                if(A[2] != 0){  //连续借位
                    A[2]--;
                    A[1] = 16;
                    A[0] += 29;
                }
            }
        }
        R[0] = A[0] - P[0];
        if(A[1] - P[1] < 0){
            if(A[2] != 0){
                A[2]--;
                A[1] += 17;
            }
        }
        R[1] = A[1] - P[1];
        R[2] = A[2] - P[2];
    }while(R[0] < 0||R[1] < 0||R[2] < 0);
    if(flag > 1){   //循环超过一次则没带够钱，输出负号
        printf("-");
    }
    printf("%d.%d.%d",R[2],R[1],R[0]);
    return 0;
}
```
>题目来源：PAT乙级1037
>作者：CHEN, Yue
>单位：浙江大学