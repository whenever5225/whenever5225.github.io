---
title: PAT乙级1068 || 万绿丛中一点红（详解，C/C++示例，测试点分析）
date: 2019-10-20 12:42:30
tags:
- PAT
- C/C++
- 编程
categories:
- PAT
mathjax: true
---

# **万绿丛中一点红**
## **题目描述**
对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 *M*×*N* 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。

## **输入格式**
输入第一行给出三个正整数，分别是 *M* 和 *N*（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 *N* 行，每行给出 *M* 个像素的颜色值，范围在 [0,$2^{24}$) 内。所有同行数字间用空格或 TAB 分开。

## **输出格式**
在一行中按照 `(x, y): color` 的格式输出所求像素点的位置以及颜色值，其中位置 `x` 和 `y` 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 `Not Unique`；如果这样的点不存在，则输出 `Not Exist`。
## **输入样例1**
```null
8 6 200
0 	 0 	  0 	   0	    0 	     0 	      0        0
65280 	 65280    65280    16711479 65280    65280    65280    65280
16711479 65280    65280    65280    16711680 65280    65280    65280
65280 	 65280    65280    65280    65280    65280    165280   165280
65280 	 65280 	  16777015 65280    65280    165280   65480    165280
16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215
```
## **输出样例1**
```null
(5, 3): 16711680
```
## **输入样例2**
```null
4 5 2
0 0 0 0
0 0 3 0
0 0 0 0
0 5 0 0
0 0 0 0
```
## **输出样例2**
```null
Not Unique
```
## **输入样例3**
```null
3 3 5
1 2 3
3 4 5
5 6 7
```
## **输出样例3**
```null
Not Exist
```


## 问题解决
### 解题思想
本题的难点在于题意的理解。题目描述中说"找出万绿丛中的一点红，即有独一无二颜色的那个像素点"，也就是说如果有两个或两个以上的像素点颜色相同，那么它们永远不可能成为那"一点红"了，此时也就不用检查它们各自的周围的8个相邻像素的颜色与之之差了。

有一个点题目没有描述清楚，就是边缘位置的"独一无二像素"是否能成为"一点红"？显然，它们周围是不足8个像素点的，实践表明，只要它们是"独一无二"的，且与周围像素（有几个算几个）的颜色差足够大，它们同样可为"一点红"。

注意本题中行列号一直是反着来的，而且，编号都是从1开始的，这一点可能会忽略。

清楚上面的几个问题之后，本题就是一道简单的逻辑题了。

### 知识拓展

#### map定义

```cpp
map<int, int> mp;	//键为int型，值为int型（值自动初始化为0）
map<char, int> mp;	//键为char型，值为int型
```

#### map访问

1. 通过键来访问
2. 通过迭代器访问

### 代码示例（C/C++）

```cpp
#include <cstdio>
#include <map>
#include <algorithm>
using namespace std;
//周围各元素位置的相对偏移量
int loc[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};
map <int, int> mp;
int m, n, TOL;
int col[1001][1001];
int main() {
    scanf("%d%d%d", &m, &n, &TOL);
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            scanf("%d", &col[i][j]);
            mp[col[i][j]]++;    //统计每种颜色出现的次数
        }
    }
    int r, c, num = 0;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(mp[col[i][j]] == 1){
                int flag = 0;
                for(int k = 0; k < 8; k++) {
                    int x = i + loc[k][0], y = j + loc[k][1];
                    if(x >= 0 && x < n && y >= 0 && y < m && abs(col[x][y] - col[i][j]) <= TOL) {	//注意此处的条件
                        flag = 1;
                        break;
                    }
                }
                if(flag == 0) {
                    num++;  //统计颜色与其周围 8 个相邻像素的颜色差充分大的颜色数
                    r = i;
                    c = j;
                }
            }
        }
        if(num > 1) {
            printf("Not Unique");
            break;
        }
    }
    switch(num) {
    case 0:
        printf("Not Exist"); break;
    case 1:
        printf("(%d, %d): %d", c + 1, r + 1, col[r][c]);    //注意编号
    }
    return 0;
}
```
题目来源：PAT乙级1068
作者：CHEN, Yue
单位：浙江大学