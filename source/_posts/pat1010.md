---
title: PAT乙级1010 || 一元多项式求导（详解，C/C++示例，测试点分析）
date: 2019-08-15 12:20:24
tags:
- PAT
- C/C++
- 编程
categories:
- PAT
mathjax: true
---

# **一元多项式求导**
## **题目描述**
设计函数求一元多项式的导数。（注：$x^n$（*n*为整数）的一阶导数为 $n \cdot x^{n−1}$。)
## **输入格式**
以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。
## **输出格式**
以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 `0 0`。
## **输入样例**
```null
3 4 -5 2 6 1 -2 0
```
## **输出样例**
```null
12 3 -10 1 6 0
```

## 问题解决
### 解题思想
本题代码过程非常简单，关键点是要处理到所有的情况，可分为以下3种情况：
* “零多项式”，求导后仍为“零多项式”，此时输出为：`0 0`
* 非“零多项式”，求导后变为”零多项式“，此时输出为：`0 0`
* 非“零多项式”，求导后不为”零多项式“，此时正常输出求导后的系数和指数，但不输出`0 0`
  对于前两种情况，可用以下条件来判定：

```c
if((exp == 0)&&(flag == 0))
```

else后即为第三种情况，但注意输出格式控制。

### 知识拓展
我们知道，可以用如下方式来判断是否输入完毕（点击进入相关讲解）：

```c
while(scanf("%s",str[i]) != EOF){
    //内部操作
}
```

这次介绍一种新的方式，如下：

```c
while(~scanf("%s",str[i++])){
    //内部操作
}
```

上面两种方式的效果是完全一样的，原理是什么呢？我们知道，scanf()读入失败时会返回-1，C语言用EOF来表示-1，因此也就有了上面第一种方式。而在机器内部-1的补码表示为全1，`~`是按位取反运算符，全1取反后变为全0，也就是说，当读入结束时，scanf()函数会返回机器补码为全1（也就是-1），经`~`取反后为全0，从而跳出循环。

### 代码示例（C）


```c
#include <stdio.h>

int main()
{
    int coe,exp,flag = 0;
    while(~scanf("%d%d",&coe,&exp)){
        //如果多项式的第一项的指数为0，求导后即为“零多项式”，则应输出0 0
        //用flag == 0来识别第一项
        if((exp == 0)&&(flag == 0)){
            printf("%d %d",exp,exp);
            break;
        }
        //如果第一项的指数不为0，则后面指数为0的项不必输出
        else if(flag == 0){
            if(exp != 0){
                printf("%d %d",coe * exp,exp - 1);
                flag = 1;
            }
        }
        else{
            if(exp != 0){
                printf(" %d %d",coe * exp,exp - 1);
            }
        }
    }
    return 0;
}
```

>题目来源：PAT乙级1010
>作者：DS课程组
>单位：浙江大学