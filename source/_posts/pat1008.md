---
title: PAT乙级1008 || 数组元素循环右移问题（详解，C/C++示例，测试点分析）
date: 2019-08-15 12:20:10
tags:
- PAT
- C/C++
- 编程
categories:
- PAT
---

# **数组元素循环右移问题**
## **题目描述**
一个数组A中存有N（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A(0),A(1),...,A(N-1))变换为（A(N-M),...,A(N-1),A(0),A(1),...,A(N-M-1)）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？
## **输入格式**
每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。
## **输出格式**
在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。
## **输入样例**
```null
6 2
1 2 3 4 5 6
```
## **输出样例**
```null
5 6 1 2 3 4
```

## 问题解决

### 解题思想
*方法1* (见下面`代码1`)
题目要求不能用辅助数组，但是由于只需要输出循环右移后的结果，因此，可以“投机取巧”地控制输出就行，这样就比较水了。

*方法2* (见下面`代码2`)
其实，本题也有高逼格的算法，采用逆置的思想，具体过程如下：

*  对数组a[0],a[1],...,a[n-m-1],a[n-m],...,a[n-1]进行原地逆置得到数组a[n-1],...,a[n-m],a[n-m-1],...,a[1],a[0];
*  对逆置后的数组的前m个元素进行原地逆置得到a[n-m],...,a[n-1];
*  对逆置后的数组的后n-m个元素进行原地逆置得到a[0],a[1],...,a[n-m-1];
*  对上面两个子序列分别逆置后便可得到对原数组循环右移m位的结果。

### 代码示例（C）

`代码1`

```c
#include <stdio.h>
#define MAXN 101
int main()
{
    int n,m,i,a[MAXN],flag = 0;//用flag作标记控制输出格式
    scanf("%d%d",&n,&m);
    m = m % n;//这一点容易忽略，题目中只给出了M>=0，而没有
              //说明M与N的大小关系，M是可以大于N的，M大于N
              //时，右移M位与右移M % N位是等效的
    for(i = 0; i < n; i++){
        scanf("%d",&a[i]);
    }
    for(i = n-m; i < n; i++){
        if(flag == 0){
            printf("%d",a[i]);
            flag = 1;
        }
        else{
            printf(" %d",a[i]);
        }
    }
    for(i = 0; i < n-m; i++){
        if(flag == 0){
            printf("%d",a[i]);
            flag = 1;
        }
        else{
            printf(" %d",a[i]);
        }
    }
    printf("\n");
    return 0;
}
```

`代码2`
```c
#include <stdio.h>
#define MAXN 101
void Reverse_Array(int a[],int start,int stop);
int main()
{
    int n,m,i,a[MAXN];
    scanf("%d%d",&n,&m);
    m = m % n;
    for(i = 0; i < n; i++){
        scanf("%d",&a[i]);
    }
    Reverse_Array(a,0,n-1);
    Reverse_Array(a,0,m-1);
    Reverse_Array(a,m,n-1);
    for(i = 0; i < n; i++){
        printf("%d",a[i]);
        if(i != n-1){
            printf(" ");
        }
    }
    return 0;
}
//逆置函数——将数组从下标start位置到stop位置原地逆置
void Reverse_Array(int a[],int start,int stop)
{
    int temp;
    while(start < stop){
        temp = a[start];
        a[start] = a[stop];
        a[stop] = temp;
        start++;
        stop--;
    }
}
```

>题目来源：PAT乙级1008
>作者：CHEN, Yue
>单位：浙江大学