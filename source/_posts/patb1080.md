---
title: PAT乙级1080 || MOOC期终成绩（详解，C/C++示例，测试点分析）
date: 2019-12-29 18:11:28
tags:
- PAT
- C/C++
- 编程
categories:
- PAT
---

# **MOOC期终成绩**
## **题目描述**
对于在中国大学MOOC（<http://www.icourse163.org/> ）学习“数据结构”课程的学生，想要获得一张合格证书，必须首先获得不少于200分的在线编程作业分，然后总评获得不少于60分（满分100）。总评成绩的计算公式为 G=(G(mid−term)×40%+G(final)×60%)，如果 G(mid−term)>G(final)；否则总评 G 就是G(final)。这里 G(mid−term) 和 G(final) 分别为学生的期中和期末成绩。

现在的问题是，每次考试都产生一张独立的成绩单。本题就请你编写程序，把不同的成绩单合为一张。

## **输入格式**
输入在第一行给出3个整数，分别是 P（做了在线编程作业的学生数）、M（参加了期中考试的学生数）、N（参加了期末考试的学生数）。每个数都不超过10000。

接下来有三块输入。第一块包含 P 个在线编程成绩 G(p)；第二块包含 M 个期中考试成绩 G(mid−term)；第三块包含 N 个期末考试成绩 G(final)。每个成绩占一行，格式为：`学生学号 分数`。其中`学生学号`为不超过20个字符的英文字母和数字；`分数`是非负整数（编程总分最高为900分，期中和期末的最高分为100分）。

## **输出格式**

打印出获得合格证书的学生名单。每个学生占一行，格式为：

`学生学号` G(p) G(mid−term) G(final) G

如果有的成绩不存在（例如某人没参加期中考试），则在相应的位置输出“−1”。输出顺序为按照总评分数（四舍五入精确到整数）递减。若有并列，则按学号递增。题目保证学号没有重复，且至少存在1个合格的学生。

## **输入样例**
```null
6 6 7
01234 880
a1903 199
ydjh2 200
wehu8 300
dx86w 220
missing 400
ydhfu77 99
wehu8 55
ydjh2 98
dx86w 88
a1903 86
01234 39
ydhfu77 88
a1903 66
01234 58
wehu8 84
ydjh2 82
missing 99
dx86w 81
```
## **输出样例**
```null
missing 400 -1 99 99
ydjh2 200 98 82 88
dx86w 220 88 81 84
wehu8 300 55 84 84
```


## 问题解决
### 解题思想
看到这种题首先想到的就是用map容器，学号用字符串`string`型表示，作为`key`，其它的分数用一个结构体表示，作为`value`。

在此需要注意一些map的特性，首先map的键值类型必须是可比较的，比如`int`型，`double`型，或者是`string`型，不能给它随便来个不能作比较的结构体，map会自动按键`key`升序排序。其实，map内部是用**红黑树**实现的，map类型不能用`sort`进行排序，因此，对map类型数据按值进行排序用`sort`是不可行的。

还要注意`sort`的一些特性，调用`sort`进行排序时，`sort`不能保证两个值相同的元素在排序前后顺序不变，这个需要注意，一开始我忽略了这一点，在实现`cmp`函数时，以为`map`已经按学号升序排序了，在`cmp`函数中就没有对其进行处理，写成如下形式（只对总评成绩降序排序）：

```cpp
bool cmp(sort_temp a, sort_temp b) {
	return a.gg > b.gg;
}
```

这样处理的话`测试点3`答案错误，卡了我很长时间，改成下面形式就通过了。

```cpp
bool cmp(sort_temp a, sort_temp b) {
    if (a.gg != b.gg) {
        return a.gg > b.gg;
    }
    else {
        return a.num < b.num;
    }
}
```

还是基础知识没学好啊。

### 坑点提醒

**坑点1**

注意当G(mid−term) > G(final)计算出的总评成绩要先四舍五入，再判断总评成绩是否合格，之后再进行排序，一定要注意四舍五入在最前面。

### 代码示例（C/C++）

```cpp
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;
struct grade {
    int gp = -1, gm = -1, gf = -1, g;	//注意初始化
};

struct sort_temp {
    string num;
    int gg;
};
vector <struct sort_temp> st;

bool cmp(sort_temp a, sort_temp b) {
    if (a.gg != b.gg) {
        return a.gg > b.gg;
    }
    else {
        return a.num < b.num;
    }
}

map <string, struct grade> mp;

int main() {
    int p, m, n;
    cin >> p >> m >> n;
    string t1;
    int t2;
    for (int i = 0; i < p; i++) {
        cin >> t1 >> t2;
        mp[t1].gp = t2;
    }
    for (int i = 0; i < m; i++) {
        cin >> t1 >> t2;
        mp[t1].gm = t2;
    }
    for (int i = 0; i < n; i++) {
        cin >> t1 >> t2;
        mp[t1].gf = t2;
    }
    for (map <string, struct grade> :: iterator  it = mp.begin(); it != mp.end(); ) {
        map <string, struct grade> :: iterator  tmp = it;   //注意
        tmp++;   //注意
        if (it-> second.gp < 200) {	//编程分小于200分的直接剔除
            mp.erase(it);
        }
        else {
            if (it -> second.gm > it -> second.gf) {
                it -> second.g = (int)(it -> second.gm * 0.4 + it -> second.gf * 0.6 + 0.5);
                if (it -> second.g  < 60) {	//注意总评成绩要先四舍五入再判断是否合格
                    mp.erase(it);
                }
            }
            else {
                it -> second.g = it -> second.gf;
                if (it -> second.g < 60) {
                    mp.erase(it);
                }
            }
        }
        it = tmp;
    }
    for (map <string, struct grade> :: iterator  it = mp.begin(); it != mp.end(); it++) {
        sort_temp tmp;
        tmp.num = it -> first;
        tmp.gg = it -> second.g;
        st.push_back(tmp);
    }
    sort(st.begin(), st.end(), cmp);	//不稳定，虽map已按学号字典序升序排序，但需在cmp中再次实现总分相同时按学号升序排序
    for (vector <sort_temp> :: iterator  it = st.begin(); it != st.end(); it++) {
        cout << (*it).num << " " << mp[(*it).num].gp << " " 
            << mp[(*it).num].gm << " " << mp[(*it).num].gf << " " << (*it).gg << endl;
    }
    return 0;
}
```
>题目来源：PAT乙级1080
>作者：CHEN, Yue
>单位：浙江大学